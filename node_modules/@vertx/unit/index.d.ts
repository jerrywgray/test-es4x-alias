/*
 * Copyright 2019 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

import { Future } from '@vertx/core';

export abstract class Async extends Completion<void> {
  /**
   * Completes the future upon completion, otherwise fails it.
   * @param future the future to resolve
   * 
   */
  resolve(future: Future<void>) : void;

  /**
   * Completion handler to receive a completion signal when this completions completes.
   * @param completionHandler the completion handler
   * 
   */
  handler(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   *
   * @return the current count
   * 
   */
  count() : number;

  /**
   * Count down the async.
   * @throws IllegalStateException in strict mode if invoked more than the initial count
   * 
   */
  countDown() : void;

  /**
   * Signals the asynchronous operation is done, this method must be called with a count greater than {@code 0},
   *  otherwise it throws an {@code IllegalStateException} to signal the error.
   * 
   */
  complete() : void;
}

export abstract class Completion<T> {
  /**
   * Completes the future upon completion, otherwise fails it.
   * @param future the future to resolve
   * 
   */
  resolve(future: Future<T>) : void;

  /**
   *
   * @return true if this completion is completed
   * 
   */
  isCompleted() : boolean;

  /**
   *
   * @return true if this completion is completed and succeeded
   * 
   */
  isSucceeded() : boolean;

  /**
   *
   * @return true if the this completion is completed and failed
   * 
   */
  isFailed() : boolean;

  /**
   * Completion handler to receive a completion signal when this completions completes.
   * @param completionHandler the completion handler
   * 
   */
  handler(completionHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Cause the current thread to wait until this completion completes.<p/>
   * 
   *  If the current thread is interrupted, an exception will be thrown.
   * 
   */
  await() : void;

  /**
   * Cause the current thread to wait until this completion completes with a configurable timeout.<p/>
   * 
   *  If completion times out or the current thread is interrupted, an exception will be thrown.
   * @param timeoutMillis the timeout in milliseconds
   * 
   */
  await(timeoutMillis: number) : void;

  /**
   * Cause the current thread to wait until this completion completes and succeeds.<p/>
   * 
   *  If the current thread is interrupted or the suite fails, an exception will be thrown.
   * 
   */
  awaitSuccess() : void;

  /**
   * Cause the current thread to wait until this completion completes and succeeds with a configurable timeout.<p/>
   * 
   *  If completion times out or the current thread is interrupted or the suite fails, an exception will be thrown.
   * @param timeoutMillis the timeout in milliseconds
   * 
   */
  awaitSuccess(timeoutMillis: number) : void;
}

import { Vertx } from '@vertx/core';
import { MessageConsumer } from '@vertx/core';
import { ReportingOptions } from './options';

export abstract class EventBusCollector {
  /**
   * Json {@code type} field value that signals a test suite begins, used as part of the test reporting
   *  protocol for the event bus.
   * 
   */
  static readonly EVENT_TEST_SUITE_BEGIN : string;

  /**
   * Json {@code type} field value that signals a test suite ends, used as part of the test reporting
   *  protocol for the event bus.
   * 
   */
  static readonly EVENT_TEST_SUITE_END : string;

  /**
   * Json {@code type} field value that reports a test suite error, used as part of the test reporting
   *  protocol for the event bus.
   * 
   */
  static readonly EVENT_TEST_SUITE_ERROR : string;

  /**
   * Json {@code type} field value that signals a test case begins, used as part of the test reporting
   *  protocol for the event bus.
   * 
   */
  static readonly EVENT_TEST_CASE_BEGIN : string;

  /**
   * Json {@code type} field value that signals a test case ends, used as part of the test reporting
   *  protocol for the event bus.
   * 
   */
  static readonly EVENT_TEST_CASE_END : string;

  /**
   * Create a message handler reporting with the specified options. The returned
   *  message handler can be registered to an event bus.
   * @param options the reporting options
   * @return the message handler
   * 
   */
  static create(vertx: Vertx, options: ReportingOptions) : EventBusCollector;

  static create(vertx: Vertx, reporter: ((res: TestSuiteReport) => void) | Handler<TestSuiteReport>) : EventBusCollector;

  /**
   * Register the collector as a consumer of the event bus with the specified address.
   * @param address the registration address
   * @return the subscribed message consumer
   * 
   */
  register(address: string) : MessageConsumer<any>;
}

export abstract class Failure {
  /**
   *
   * @return true if the failure is an error failure otherwise it is an assertion failure
   * 
   */
  isError() : boolean;

  /**
   *
   * @return the error message
   * 
   */
  message() : string;

  /**
   *
   * @return the stack trace
   * 
   */
  stackTrace() : string;
}

export abstract class TestCase {
  /**
   * Create a test case.
   * @param name the test case name
   * @param testCase the test case
   * @return the created test case
   * 
   */
  static create(name: string, testCase: ((res: TestContext) => void) | Handler<TestContext>) : TestCase;
}

export abstract class TestCaseReport {
  /**
   *
   * @return the test case name
   * 
   */
  name() : string;

  /**
   * Set a callback for completion, the specified {@code handler} is invoked when the test exec has completed.
   * @param handler the completion handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endHandler(handler: ((res: TestResult) => void) | Handler<TestResult>) : TestCaseReport;
}

export abstract class TestCompletion extends Completion<void> {
  /**
   * Completes the future upon completion, otherwise fails it.
   * @param future the future to resolve
   * 
   */
  resolve(future: Future<void>) : void;

  /**
   * Completion handler to receive a completion signal when this completions completes.
   * @param completionHandler the completion handler
   * 
   */
  handler(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

export abstract class TestContext {
  /**
   * Get some data from the context.
   * @param key  the key of the data
   * @param <T>  the type of the data
   * @return the data
   * 
   */
  get<T>(key: string) : T;

  /**
   * Put some data in the context.
   *  <p>
   *  This can be used to share data between different tests and before/after phases.
   * @param key  the key of the data
   * @param value  the data
   * @return the previous object when it exists
   * 
   */
  put<T>(key: string, value: any) : T;

  /**
   * Remove some data from the context.
   * @param key  the key to remove
   * @return the removed object when it exists
   * 
   */
  remove<T>(key: string) : T;

  /**
   * Assert the {@code expected} argument is {@code null}. If the argument is not, an assertion error is thrown
   *  otherwise the execution continue.
   * @param expected the argument being asserted to be null
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertNull(expected: any) : TestContext;

  /**
   * Assert the {@code expected} argument is {@code null}. If the argument is not, an assertion error is thrown
   *  otherwise the execution continue.
   * @param expected the argument being asserted to be null
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertNull(expected: any, message: string) : TestContext;

  /**
   * Assert the {@code expected} argument is not {@code null}. If the argument is {@code null}, an assertion error is thrown
   *  otherwise the execution continue.
   * @param expected the argument being asserted to be not null
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertNotNull(expected: any) : TestContext;

  /**
   * Assert the {@code expected} argument is not {@code null}. If the argument is {@code null}, an assertion error is thrown
   *  otherwise the execution continue.
   * @param expected the argument being asserted to be not null
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertNotNull(expected: any, message: string) : TestContext;

  /**
   * Assert the specified {@code condition} is {@code true}. If the condition is {@code false}, an assertion error is thrown
   *  otherwise the execution continue.
   * @param condition the condition to assert
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertTrue(condition: boolean) : TestContext;

  /**
   * Assert the specified {@code condition} is {@code true}. If the condition is {@code false}, an assertion error is thrown
   *  otherwise the execution continue.
   * @param condition the condition to assert
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertTrue(condition: boolean, message: string) : TestContext;

  /**
   * Assert the specified {@code condition} is {@code false}. If the condition is {@code true}, an assertion error is thrown
   *  otherwise the execution continue.
   * @param condition the condition to assert
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertFalse(condition: boolean) : TestContext;

  /**
   * Assert the specified {@code condition} is {@code false}. If the condition is {@code true}, an assertion error is thrown
   *  otherwise the execution continue.
   * @param condition the condition to assert
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertFalse(condition: boolean, message: string) : TestContext;

  /**
   * Assert the {@code expected} argument is equals to the {@code actual} argument. If the arguments are not equals
   *  an assertion error is thrown otherwise the execution continue.
   * @param expected the object the actual object is supposedly equals to
   * @param actual the actual object to test
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertEquals(expected: any, actual: any) : TestContext;

  /**
   * Assert the {@code expected} argument is equals to the {@code actual} argument. If the arguments are not equals
   *  an assertion error is thrown otherwise the execution continue.
   * @param expected the object the actual object is supposedly equals to
   * @param actual the actual object to test
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertEquals(expected: any, actual: any, message: string) : TestContext;

  /**
   * Asserts that the {@code expected} double argument is equals to the {@code actual} double argument
   *  within a positive delta. If the arguments do not satisfy this, an assertion error is thrown otherwise
   *  the execution continue.
   * @param expected the object the actual object is supposedly equals to
   * @param actual the actual object to test
   * @param delta the maximum delta
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertInRange(expected: number, actual: number, delta: number) : TestContext;

  /**
   * Asserts that the {@code expected} double argument is equals to the {@code actual} double argument
   *  within a positive delta. If the arguments do not satisfy this, an assertion error is thrown otherwise
   *  the execution continue.
   * @param expected the object the actual object is supposedly equals to
   * @param actual the actual object to test
   * @param delta the maximum delta
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertInRange(expected: number, actual: number, delta: number, message: string) : TestContext;

  /**
   * Assert the {@code first} argument is not equals to the {@code second} argument. If the arguments are equals
   *  an assertion error is thrown otherwise the execution continue.
   * @param first the first object to test
   * @param second the second object to test
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertNotEquals(first: any, second: any) : TestContext;

  /**
   * Assert the {@code first} argument is not equals to the {@code second} argument. If the arguments are equals
   *  an assertion error is thrown otherwise the execution continue.
   * @param first the first object to test
   * @param second the second object to test
   * @param message the failure message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  assertNotEquals(first: any, second: any, message: string) : TestContext;

  /**
   * Execute the provided handler, which may contain assertions, possibly from any third-party assertion framework.
   *  Any {@link AssertionError} thrown will be caught (and propagated) in order to fulfill potential expected async
   *  completeness.
   * @param block block of code to be executed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  verify(block: ((res: void) => void) | Handler<void>) : TestContext;

  /**
   * Throw a failure.
   * 
   */
  fail() : void;

  /**
   * Throw a failure with the specified failure {@code message}.
   * @param message the failure message
   * 
   */
  fail(message: string) : void;

  /**
   * Throw a failure with the specified failure {@code cause}.
   * @param cause the failure cause
   * 
   */
  fail(cause: Error) : void;

  /**
   * Create and returns a new async object, the returned async controls the completion of the test. Calling the
   *  {@link Async#complete()} completes the async operation.<p/>
   * 
   *  The test case will complete when all the async objects have their {@link io.vertx.ext.unit.Async#complete()}
   *  method called at least once.<p/>
   * 
   *  This method shall be used for creating asynchronous exit points for the executed test.
   * @return the async instance
   * 
   */
  async() : Async;

  /**
   * Create and returns a new async object, the returned async controls the completion of the test. This async operation
   *  completes when the {@link Async#countDown()} is called {@code count} times.<p/>
   * 
   *  The test case will complete when all the async objects have their {@link io.vertx.ext.unit.Async#complete()}
   *  method called at least once.<p/>
   * 
   *  This method shall be used for creating asynchronous exit points for the executed test.<p/>
   * @return the async instance
   * 
   */
  async(count: number) : Async;

  /**
   * Create and returns a new async object, the returned async controls the completion of the test.
   *  This async operation completes when the {@link Async#countDown()} is called {@code count} times.<p/>
   *  If {@link Async#countDown()} is called more than {@code count} times, an {@link IllegalStateException} is thrown.<p/>
   * 
   *  The test case will complete when all the async objects have their {@link io.vertx.ext.unit.Async#complete()}
   *  method called at least once.<p/>
   * 
   *  This method shall be used for creating asynchronous exit points for the executed test.<p/>
   * @return the async instance
   * 
   */
  strictAsync(count: number) : Async;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   * 
   *  When the returned handler is called back with a succeeded result it completes the async operation.<p/>
   * 
   *  When the returned handler is called back with a failed result it fails the test with the cause of the failure.<p/>
   * @return the async result handler
   * 
   */
  asyncAssertSuccess<T>() : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   * 
   *  When the returned handler is called back with a succeeded result it invokes the {@code resultHandler} argument
   *  with the async result. The test completes after the result handler is invoked and does not fails.<p/>
   * 
   *  When the returned handler is called back with a failed result it fails the test with the cause of the failure.<p/>
   * 
   *  Note that the result handler can create other async objects during its invocation that would postpone
   *  the completion of the test case until those objects are resolved.
   * @param resultHandler the result handler
   * @return the async result handler
   * 
   */
  asyncAssertSuccess<T>(resultHandler: ((res: T) => void) | Handler<T>) : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   * 
   *  When the returned handler is called back with a failed result it completes the async operation.<p/>
   * 
   *  When the returned handler is called back with a succeeded result it fails the test.<p/>
   * @return the async result handler
   * 
   */
  asyncAssertFailure<T>() : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   * 
   *  When the returned handler is called back with a failed result it completes the async operation.<p/>
   * 
   *  When the returned handler is called back with a succeeded result it fails the test.<p/>
   * @param causeHandler the cause handler
   * @return the async result handler
   * 
   */
  asyncAssertFailure<T>(causeHandler: ((res: Error) => void) | Handler<Error>) : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   *
   * @return an exception handler that will fail this context
   * 
   */
  exceptionHandler() : ((res: Error) => void) | Handler<Error>;
}

export abstract class TestResult {
  /**
   * The test description, may be null if none was provided.
   * 
   */
  name() : string;

  /**
   * The time at which the test began in millis.
   * 
   */
  beginTime() : number;

  /**
   * How long the test lasted in millis.
   * 
   */
  durationTime() : number;

  /**
   * Did it succeed?
   * 
   */
  succeeded() : boolean;

  /**
   * Did it fail?
   * 
   */
  failed() : boolean;

  /**
   * An exception describing failure, null if the test succeeded.
   * 
   */
  failure() : Failure;
}

import { TestOptions } from './options';

export abstract class TestSuite {
  /**
   * Create and return a new test suite.
   * @param name the test suite name
   * @return the created test suite
   * 
   */
  static create(name: string) : TestSuite;

  /**
   * Set a callback executed before the tests.
   * @param callback the callback
   * @return a reference to this, so the API can be used fluently
   * 
   */
  before(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Set a callback executed before each test and after the suite {@code before} callback.
   * @param callback the callback
   * @return a reference to this, so the API can be used fluently
   * 
   */
  beforeEach(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Set a callback executed after the tests.
   * @param callback the callback
   * @return a reference to this, so the API can be used fluently
   * 
   */
  after(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Set a callback executed after each test and before the suite {@code after} callback.
   * @param callback the callback
   * @return a reference to this, so the API can be used fluently
   * 
   */
  afterEach(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Add a new test case to the suite.
   * @param name the test case name
   * @param testCase the test case
   * @return a reference to this, so the API can be used fluently
   * 
   */
  test(name: string, testCase: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Add a new test case to the suite.
   * @param name the test case name
   * @param repeat the number of times the test should be repeated
   * @param testCase the test case
   * @return a reference to this, so the API can be used fluently
   * 
   */
  test(name: string, repeat: number, testCase: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Run the testsuite with the default options.<p/>
   * 
   *  When the test suite is executed in a Vertx context (i.e `Vertx.currentContext()` returns a context) this
   *  context's event loop is used for running the test suite. Otherwise it is executed in the current thread.<p/>
   * 
   *  The returned {@link Completion} object can be used to get a completion callback.
   * @return the related test completion
   * 
   */
  run() : TestCompletion;

  /**
   * Run the testsuite with the specified {@code options}.<p/>
   * 
   *  When the test suite is executed in a Vertx context (i.e `Vertx.currentContext()` returns a context) this
   *  context's event loop is used for running the test suite unless the {@link io.vertx.ext.unit.TestOptions#setUseEventLoop(Boolean)}
   *  is set to {@code false}. In this case it is executed by the current thread.<p/>
   * 
   *  Otherwise, the test suite will be executed in the current thread when {@link io.vertx.ext.unit.TestOptions#setUseEventLoop(Boolean)} is
   *  set to {@code false} or {@code null}. If the value is {@code true}, this methods throws an {@code IllegalStateException}.<p/>
   * 
   *  The returned {@link Completion} object can be used to get a completion callback.
   * @param options the test options
   * @return the related test completion
   * 
   */
  run(options: TestOptions) : TestCompletion;

  /**
   * Run the testsuite with the default options and the specified {@code vertx} instance.<p/>
   * 
   *  The test suite will be executed on the event loop provided by the {@code vertx} argument. The returned
   *  {@link Completion} object can be used to get a completion callback.<p/>
   * @param vertx the vertx instance
   * @return the related test completion
   * 
   */
  run(vertx: Vertx) : TestCompletion;

  /**
   * Run the testsuite with the specified {@code options} and the specified {@code vertx} instance.<p/>
   * 
   *  The test suite will be executed on the event loop provided by the {@code vertx} argument when
   *  {@link io.vertx.ext.unit.TestOptions#setUseEventLoop(Boolean)} is not set to {@code false}. The returned
   *  {@link Completion} object can be used to get a completion callback.
   * @param vertx the vertx instance
   * @param options the test options
   * @return the related test completion
   * 
   */
  run(vertx: Vertx, options: TestOptions) : TestCompletion;
}

import { Pipe } from '@vertx/core';
import { WriteStream } from '@vertx/core';
import { ReadStream } from '@vertx/core';

export abstract class TestSuiteReport implements ReadStream<TestCaseReport> {
  fetch(arg0: number) : ReadStream<TestCaseReport>;

  pipe() : Pipe<TestCaseReport>;

  pipeTo(dst: WriteStream<TestCaseReport>) : void;

  pipeTo(dst: WriteStream<TestCaseReport>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   *
   * @return the test suite name
   * 
   */
  name() : string;

  /**
   * Set an exception handler, the exception handler reports the test suite errors, it can be called mulitple
   *  times before the test ends.
   * @param handler the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : TestSuiteReport;

  handler(handler: ((res: TestCaseReport) => void) | Handler<TestCaseReport> | null | undefined) : TestSuiteReport;

  pause() : TestSuiteReport;

  resume() : TestSuiteReport;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : TestSuiteReport;
}
