/*
 * Copyright 2019 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Buffer } from './index';

export class AddressResolverOptions {

  constructor();
  constructor(obj: AddressResolverOptions);
  /**
   * Set the cache maximum TTL value in seconds. After successful resolution IP addresses are cached with their DNS response TTL,
   *  use this to set a maximum value to all responses TTL.
   * @param cacheMaxTimeToLive the cache max TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getCacheMaxTimeToLive(): number;

  /**
   * Set the cache maximum TTL value in seconds. After successful resolution IP addresses are cached with their DNS response TTL,
   *  use this to set a maximum value to all responses TTL.
   * @param cacheMaxTimeToLive the cache max TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCacheMaxTimeToLive(cacheMaxTimeToLive: number): AddressResolverOptions;

  /**
   * Set the cache minimum TTL value in seconds. After resolution successful IP addresses are cached with their DNS response TTL,
   *  use this to set a minimum value to all responses TTL.
   * @param cacheMinTimeToLive the cache min TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getCacheMinTimeToLive(): number;

  /**
   * Set the cache minimum TTL value in seconds. After resolution successful IP addresses are cached with their DNS response TTL,
   *  use this to set a minimum value to all responses TTL.
   * @param cacheMinTimeToLive the cache min TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCacheMinTimeToLive(cacheMinTimeToLive: number): AddressResolverOptions;

  /**
   * Set the negative cache TTL value in seconds. After a failed hostname resolution, DNS queries won't be retried
   *  for a period of time equals to the negative TTL. This allows to reduce the response time of negative replies
   *  and reduce the amount of messages to DNS servers.
   * @param cacheNegativeTimeToLive the cache negative TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getCacheNegativeTimeToLive(): number;

  /**
   * Set the negative cache TTL value in seconds. After a failed hostname resolution, DNS queries won't be retried
   *  for a period of time equals to the negative TTL. This allows to reduce the response time of negative replies
   *  and reduce the amount of messages to DNS servers.
   * @param cacheNegativeTimeToLive the cache negative TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCacheNegativeTimeToLive(cacheNegativeTimeToLive: number): AddressResolverOptions;

  /**
   * Set the path of an alternate hosts configuration file to use instead of the one provided by the os.
   *  <p/>
   *  The default value is null, so the operating system hosts config is used.
   * @param hostsPath the hosts path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHostsPath(): string;

  /**
   * Set the path of an alternate hosts configuration file to use instead of the one provided by the os.
   *  <p/>
   *  The default value is null, so the operating system hosts config is used.
   * @param hostsPath the hosts path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHostsPath(hostsPath: string): AddressResolverOptions;

  /**
   * Set an alternate hosts configuration file to use instead of the one provided by the os.
   *  <p/>
   *  The value should contain the hosts content literaly, for instance <i>127.0.0.1 localhost</i>
   *  <p/>
   *  The default value is null, so the operating system hosts config is used.
   * @param hostsValue the hosts content
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHostsValue(): Buffer;

  /**
   * Set an alternate hosts configuration file to use instead of the one provided by the os.
   *  <p/>
   *  The value should contain the hosts content literaly, for instance <i>127.0.0.1 localhost</i>
   *  <p/>
   *  The default value is null, so the operating system hosts config is used.
   * @param hostsValue the hosts content
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHostsValue(hostsValue: Buffer): AddressResolverOptions;

  /**
   * Set the maximum number of queries when an hostname is resolved.
   * @param maxQueries the max number of queries to be sent
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxQueries(): number;

  /**
   * Set the maximum number of queries when an hostname is resolved.
   * @param maxQueries the max number of queries to be sent
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxQueries(maxQueries: number): AddressResolverOptions;

  /**
   * Set the ndots value used when resolving using search domains, the default value is {@code -1} which
   *  determines the value from the OS on Linux or uses the value {@code 1}.
   * @param ndots the new ndots value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getNdots(): number;

  /**
   * Set the ndots value used when resolving using search domains, the default value is {@code -1} which
   *  determines the value from the OS on Linux or uses the value {@code 1}.
   * @param ndots the new ndots value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setNdots(ndots: number): AddressResolverOptions;

  /**
   * Set to true to enable the automatic inclusion in DNS queries of an optional record that hints
   *  the remote DNS server about how much data the resolver can read per response.
   * @param optResourceEnabled true to enable, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isOptResourceEnabled(): boolean;

  /**
   * Set to true to enable the automatic inclusion in DNS queries of an optional record that hints
   *  the remote DNS server about how much data the resolver can read per response.
   * @param optResourceEnabled true to enable, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setOptResourceEnabled(optResourceEnabled: boolean): AddressResolverOptions;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   * @param queryTimeout the query timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getQueryTimeout(): number;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   * @param queryTimeout the query timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setQueryTimeout(queryTimeout: number): AddressResolverOptions;

  /**
   * Set the DNS queries <i>Recursion Desired</i> flag value.
   * @param rdFlag the flag value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getRdFlag(): boolean;

  /**
   * Set the DNS queries <i>Recursion Desired</i> flag value.
   * @param rdFlag the flag value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRdFlag(rdFlag: boolean): AddressResolverOptions;

  /**
   * Set to {@code true} to enable round-robin selection of the dns server to use. It spreads the query load
   *  among the servers and avoids all lookup to hit the first server of the list.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isRotateServers(): boolean;

  /**
   * Set to {@code true} to enable round-robin selection of the dns server to use. It spreads the query load
   *  among the servers and avoids all lookup to hit the first server of the list.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRotateServers(rotateServers: boolean): AddressResolverOptions;

  /**
   * Set the lists of DNS search domains.
   *  <p/>
   *  When the search domain list is null, the effective search domain list will be populated using
   *  the system DNS search domains.
   * @param searchDomains the search domains
   * 
   */
  getSearchDomains(): string;

  /**
   * Set the lists of DNS search domains.
   *  <p/>
   *  When the search domain list is null, the effective search domain list will be populated using
   *  the system DNS search domains.
   * @param searchDomains the search domains
   * 
   */
  setSearchDomains(searchDomains: string): AddressResolverOptions;

  /**
   * Set the lists of DNS search domains.
   *  <p/>
   *  When the search domain list is null, the effective search domain list will be populated using
   *  the system DNS search domains.
   * @param searchDomains the search domains
   * 
   */
  addSearchDomain(searchDomains: string): AddressResolverOptions;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   *  colon and a port, e.g {@code 8.8.8.8} or {code 192.168.0.1:40000}. When the list is empty, the resolver
   *  will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   *  it will use Google's public DNS servers {@code "8.8.8.8"} and {@code "8.8.4.4"}.
   * @param servers the list of DNS servers
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getServers(): string;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   *  colon and a port, e.g {@code 8.8.8.8} or {code 192.168.0.1:40000}. When the list is empty, the resolver
   *  will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   *  it will use Google's public DNS servers {@code "8.8.8.8"} and {@code "8.8.4.4"}.
   * @param servers the list of DNS servers
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setServers(servers: string): AddressResolverOptions;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   *  colon and a port, e.g {@code 8.8.8.8} or {code 192.168.0.1:40000}. When the list is empty, the resolver
   *  will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   *  it will use Google's public DNS servers {@code "8.8.8.8"} and {@code "8.8.4.4"}.
   * @param servers the list of DNS servers
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addServer(servers: string): AddressResolverOptions;
}

export class Argument {

  constructor();
  constructor(obj: Argument);
  /**
   * Sets the argument name of this {@link Argument}.
   * @param argName the argument name, must not be {@code null}
   * @return the current {@link Argument} instance
   * 
   */
  getArgName(): string;

  /**
   * Sets the argument name of this {@link Argument}.
   * @param argName the argument name, must not be {@code null}
   * @return the current {@link Argument} instance
   * 
   */
  setArgName(argName: string): Argument;

  /**
   * Sets the default value of this {@link Argument}.
   * @param defaultValue the default value
   * @return the current {@link Argument} instance
   * 
   */
  getDefaultValue(): string;

  /**
   * Sets the default value of this {@link Argument}.
   * @param defaultValue the default value
   * @return the current {@link Argument} instance
   * 
   */
  setDefaultValue(defaultValue: string): Argument;

  /**
   * Sets the description of the {@link Argument}.
   * @param description the description
   * @return the current {@link Argument} instance
   * 
   */
  getDescription(): string;

  /**
   * Sets the description of the {@link Argument}.
   * @param description the description
   * @return the current {@link Argument} instance
   * 
   */
  setDescription(description: string): Argument;

  /**
   * Sets whether or not the current {@link Argument} is hidden.
   * @param hidden enables or disables the visibility of this {@link Argument}
   * @return the current {@link Argument} instance
   * 
   */
  isHidden(): boolean;

  /**
   * Sets whether or not the current {@link Argument} is hidden.
   * @param hidden enables or disables the visibility of this {@link Argument}
   * @return the current {@link Argument} instance
   * 
   */
  setHidden(hidden: boolean): Argument;

  /**
   * Sets the argument index.
   * @param index the index, must not be negative
   * @return the current {@link Argument} instance
   * 
   */
  getIndex(): number;

  /**
   * Sets the argument index.
   * @param index the index, must not be negative
   * @return the current {@link Argument} instance
   * 
   */
  setIndex(index: number): Argument;

  /**
   * Sets whether or not the argument can receive several values. Only the last argument can receive several values.
   * @param multiValued {@code true} to mark this argument as multi-valued.
   * @return the current {@link Argument} instance
   * 
   */
  isMultiValued(): boolean;

  /**
   * Sets whether or not the argument can receive several values. Only the last argument can receive several values.
   * @param multiValued {@code true} to mark this argument as multi-valued.
   * @return the current {@link Argument} instance
   * 
   */
  setMultiValued(multiValued: boolean): Argument;

  /**
   * Sets whether or not the current {@link Argument} is required.
   * @param required {@code true} to make this argument mandatory, {@link false} otherwise
   * @return the current {@link Argument} instance
   * 
   */
  isRequired(): boolean;

  /**
   * Sets whether or not the current {@link Argument} is required.
   * @param required {@code true} to make this argument mandatory, {@link false} otherwise
   * @return the current {@link Argument} instance
   * 
   */
  setRequired(required: boolean): Argument;
}

export abstract class ClientOptionsBase {

  constructor();
  constructor(obj: ClientOptionsBase);
  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getConnectTimeout(): number;

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setConnectTimeout(connectTimeout: number): ClientOptionsBase;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): ClientOptionsBase;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): ClientOptionsBase;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): ClientOptionsBase;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): ClientOptionsBase;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): ClientOptionsBase;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): ClientOptionsBase;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): ClientOptionsBase;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): ClientOptionsBase;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): ClientOptionsBase;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLocalAddress(): string;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLocalAddress(localAddress: string): ClientOptionsBase;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): ClientOptionsBase;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMetricsName(): string;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMetricsName(metricsName: string): ClientOptionsBase;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): ClientOptionsBase;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): ClientOptionsBase;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): ClientOptionsBase;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): ClientOptionsBase;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): ClientOptionsBase;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getProxyOptions(): ProxyOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setProxyOptions(proxyOptions: ProxyOptions): ClientOptionsBase;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): ClientOptionsBase;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): ClientOptionsBase;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): ClientOptionsBase;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): ClientOptionsBase;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): ClientOptionsBase;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): ClientOptionsBase;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): ClientOptionsBase;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): ClientOptionsBase;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): ClientOptionsBase;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): ClientOptionsBase;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): ClientOptionsBase;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): ClientOptionsBase;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): ClientOptionsBase;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): ClientOptionsBase;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustAll(trustAll: boolean): ClientOptionsBase;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): ClientOptionsBase;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): ClientOptionsBase;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): ClientOptionsBase;
}

export class CopyOptions {

  constructor();
  constructor(obj: CopyOptions);
  /**
   * Whether move should be performed as an atomic filesystem operation. Defaults to {@code false}.
   * @param atomicMove true to perform as an atomic filesystem operation, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isAtomicMove(): boolean;

  /**
   * Whether move should be performed as an atomic filesystem operation. Defaults to {@code false}.
   * @param atomicMove true to perform as an atomic filesystem operation, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAtomicMove(atomicMove: boolean): CopyOptions;

  /**
   * Whether the file attributes should be copied. Defaults to {@code false}.
   * @param copyAttributes true to copy attributes, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isCopyAttributes(): boolean;

  /**
   * Whether the file attributes should be copied. Defaults to {@code false}.
   * @param copyAttributes true to copy attributes, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCopyAttributes(copyAttributes: boolean): CopyOptions;

  /**
   * Whether symbolic links should not be followed during copy or move operations. Defaults to {@code false}.
   * @param nofollowLinks true to not follow links, false otherwise. Defaults to {@code false}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isNofollowLinks(): boolean;

  /**
   * Whether symbolic links should not be followed during copy or move operations. Defaults to {@code false}.
   * @param nofollowLinks true to not follow links, false otherwise. Defaults to {@code false}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setNofollowLinks(nofollowLinks: boolean): CopyOptions;

  /**
   * Whether an existing file, empty directory, or link should be replaced. Defaults to {@code false}.
   * @param replaceExisting true to replace, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReplaceExisting(): boolean;

  /**
   * Whether an existing file, empty directory, or link should be replaced. Defaults to {@code false}.
   * @param replaceExisting true to replace, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReplaceExisting(replaceExisting: boolean): CopyOptions;
}

export class DatagramSocketOptions {

  constructor();
  constructor(obj: DatagramSocketOptions);
  /**
   * Set if the socket can send or receive broadcast packets
   * @param broadcast  true if the socket can send or receive broadcast packets
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isBroadcast(): boolean;

  /**
   * Set if the socket can send or receive broadcast packets
   * @param broadcast  true if the socket can send or receive broadcast packets
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setBroadcast(broadcast: boolean): DatagramSocketOptions;

  /**
   * Set if IP v6 should be used
   * @param ipV6  true if IP v6 should be used
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isIpV6(): boolean;

  /**
   * Set if IP v6 should be used
   * @param ipV6  true if IP v6 should be used
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIpV6(ipV6: boolean): DatagramSocketOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): DatagramSocketOptions;

  /**
   * Set if loopback mode is disabled
   * @param loopbackModeDisabled  true if loopback mode is disabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isLoopbackModeDisabled(): boolean;

  /**
   * Set if loopback mode is disabled
   * @param loopbackModeDisabled  true if loopback mode is disabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLoopbackModeDisabled(loopbackModeDisabled: boolean): DatagramSocketOptions;

  /**
   * Set the multicast network interface address
   * @param multicastNetworkInterface  the address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMulticastNetworkInterface(): string;

  /**
   * Set the multicast network interface address
   * @param multicastNetworkInterface  the address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMulticastNetworkInterface(multicastNetworkInterface: string): DatagramSocketOptions;

  /**
   * Set the multicast ttl value
   * @param multicastTimeToLive  the multicast ttl value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMulticastTimeToLive(): number;

  /**
   * Set the multicast ttl value
   * @param multicastTimeToLive  the multicast ttl value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMulticastTimeToLive(multicastTimeToLive: number): DatagramSocketOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): DatagramSocketOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): DatagramSocketOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): DatagramSocketOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): DatagramSocketOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): DatagramSocketOptions;
}

export class DeliveryOptions {

  constructor();
  constructor(obj: DeliveryOptions);
  /**
   * Set the codec name.
   * @param codecName  the codec name
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getCodecName(): string;

  /**
   * Set the codec name.
   * @param codecName  the codec name
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setCodecName(codecName: string): DeliveryOptions;

  /**
   * Add a message header.
   *  <p>
   *  Message headers can be sent with any message and will be accessible with {@link io.vertx.core.eventbus.Message#headers}
   *  at the recipient.
   * @param key  the header key
   * @param value  the header value
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  headers(): string;

  /**
   * Add a message header.
   *  <p>
   *  Message headers can be sent with any message and will be accessible with {@link io.vertx.core.eventbus.Message#headers}
   *  at the recipient.
   * @param key  the header key
   * @param value  the header value
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  addHeader(headers: string): DeliveryOptions;

  /**
   * Whether a message should be delivered to local consumers only. Defaults to {@code false}.
   * 
   *  <p>
   *  <strong>This option is effective in clustered mode only and does not apply to reply messages</strong>.
   * @param localOnly {@code true} to deliver to local consumers only, {@code false} otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isLocalOnly(): boolean;

  /**
   * Whether a message should be delivered to local consumers only. Defaults to {@code false}.
   * 
   *  <p>
   *  <strong>This option is effective in clustered mode only and does not apply to reply messages</strong>.
   * @param localOnly {@code true} to deliver to local consumers only, {@code false} otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLocalOnly(localOnly: boolean): DeliveryOptions;

  /**
   * Set the send timeout.
   * @param timeout  the timeout value, in ms.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getSendTimeout(): number;

  /**
   * Set the send timeout.
   * @param timeout  the timeout value, in ms.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setSendTimeout(sendTimeout: number): DeliveryOptions;
}

export class DeploymentOptions {

  constructor();
  constructor(obj: DeploymentOptions);
  /**
   * Set the JSON configuration that will be passed to the verticle(s) when it's deployed
   * @param config  the JSON config
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getConfig(): { [key: string]: any };

  /**
   * Set the JSON configuration that will be passed to the verticle(s) when it's deployed
   * @param config  the JSON config
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setConfig(config: { [key: string]: any }): DeploymentOptions;

  /**
   * Set any extra classpath to be used when deploying the verticle.
   *  <p>
   *  Ignored if no isolation group is set.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getExtraClasspath(): string;

  /**
   * Set any extra classpath to be used when deploying the verticle.
   *  <p>
   *  Ignored if no isolation group is set.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setExtraClasspath(extraClasspath: string): DeploymentOptions;

  /**
   * Set whether the verticle(s) will be deployed as HA.
   * @param ha  true if to be deployed as HA, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isHa(): boolean;

  /**
   * Set whether the verticle(s) will be deployed as HA.
   * @param ha  true if to be deployed as HA, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHa(ha: boolean): DeploymentOptions;

  /**
   * Set the number of instances that should be deployed.
   * @param instances  the number of instances
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getInstances(): number;

  /**
   * Set the number of instances that should be deployed.
   * @param instances  the number of instances
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setInstances(instances: number): DeploymentOptions;

  /**
   * Set the isolated class names.
   * @param isolatedClasses the list of isolated class names
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIsolatedClasses(): string;

  /**
   * Set the isolated class names.
   * @param isolatedClasses the list of isolated class names
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIsolatedClasses(isolatedClasses: string): DeploymentOptions;

  /**
   * Set the isolation group that will be used when deploying the verticle(s)
   * @param isolationGroup - the isolation group
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIsolationGroup(): string;

  /**
   * Set the isolation group that will be used when deploying the verticle(s)
   * @param isolationGroup - the isolation group
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIsolationGroup(isolationGroup: string): DeploymentOptions;

  /**
   * Sets the value of max worker execute time, in {@link DeploymentOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   *  <p>
   *  The default value of {@link DeploymentOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit} is {@link TimeUnit#NANOSECONDS}
   * @param maxWorkerExecuteTime the value of max worker execute time, in in {@link DeploymentOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWorkerExecuteTime(): number;

  /**
   * Sets the value of max worker execute time, in {@link DeploymentOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   *  <p>
   *  The default value of {@link DeploymentOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit} is {@link TimeUnit#NANOSECONDS}
   * @param maxWorkerExecuteTime the value of max worker execute time, in in {@link DeploymentOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWorkerExecuteTime(maxWorkerExecuteTime: number): DeploymentOptions;

  /**
   * Set the time unit of {@code maxWorkerExecuteTime}
   * @param maxWorkerExecuteTimeUnit the time unit of {@code maxWorkerExecuteTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWorkerExecuteTimeUnit(): any;

  /**
   * Set the time unit of {@code maxWorkerExecuteTime}
   * @param maxWorkerExecuteTimeUnit the time unit of {@code maxWorkerExecuteTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWorkerExecuteTimeUnit(maxWorkerExecuteTimeUnit: any): DeploymentOptions;

  /**
   * Set whether the verticle(s) should be deployed as a multi-threaded worker verticle.
   *  <p>
   *  <strong>WARNING</strong>: Multi-threaded worker verticles are a deprecated feature.
   *  <p>
   *  Most applications will have no need for them. Because of the concurrency in these verticles you have to be
   *  very careful to keep the verticle in a consistent state using standard Java techniques for multi-threaded
   *  programming.
   *  <p>
   *  You can read the documentation that explains how you can replace this feature by the usage of custom worker
   *  pools or {@code executeBlocking} calls.
   * @deprecated as of 3.6.0
   * @param multiThreaded true for multi-threaded worker, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isMultiThreaded(): boolean;

  /**
   * Set whether the verticle(s) should be deployed as a multi-threaded worker verticle.
   *  <p>
   *  <strong>WARNING</strong>: Multi-threaded worker verticles are a deprecated feature.
   *  <p>
   *  Most applications will have no need for them. Because of the concurrency in these verticles you have to be
   *  very careful to keep the verticle in a consistent state using standard Java techniques for multi-threaded
   *  programming.
   *  <p>
   *  You can read the documentation that explains how you can replace this feature by the usage of custom worker
   *  pools or {@code executeBlocking} calls.
   * @deprecated as of 3.6.0
   * @param multiThreaded true for multi-threaded worker, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMultiThreaded(multiThreaded: boolean): DeploymentOptions;

  /**
   * Set whether the verticle(s) should be deployed as a worker verticle
   * @param worker true for worker, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isWorker(): boolean;

  /**
   * Set whether the verticle(s) should be deployed as a worker verticle
   * @param worker true for worker, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWorker(worker: boolean): DeploymentOptions;

  /**
   * Set the worker pool name to use for this verticle. When no name is set, the Vert.x
   *  worker pool will be used, when a name is set, the verticle will use a named worker pool.
   * @param workerPoolName the worker pool name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWorkerPoolName(): string;

  /**
   * Set the worker pool name to use for this verticle. When no name is set, the Vert.x
   *  worker pool will be used, when a name is set, the verticle will use a named worker pool.
   * @param workerPoolName the worker pool name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWorkerPoolName(workerPoolName: string): DeploymentOptions;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   * @param workerPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWorkerPoolSize(): number;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   * @param workerPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWorkerPoolSize(workerPoolSize: number): DeploymentOptions;
}

export class DnsClientOptions {

  constructor();
  constructor(obj: DnsClientOptions);
  /**
   * Set the host name to be used by this client in requests.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHost(): string;

  /**
   * Set the host name to be used by this client in requests.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHost(host: string): DnsClientOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): DnsClientOptions;

  /**
   * Set the port to be used by this client in requests.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPort(): number;

  /**
   * Set the port to be used by this client in requests.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPort(port: number): DnsClientOptions;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   * @param queryTimeout the query timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getQueryTimeout(): number;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   * @param queryTimeout the query timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setQueryTimeout(queryTimeout: number): DnsClientOptions;

  /**
   * Set whether or not recursion is desired
   * @param recursionDesired the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isRecursionDesired(): boolean;

  /**
   * Set whether or not recursion is desired
   * @param recursionDesired the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRecursionDesired(recursionDesired: boolean): DnsClientOptions;
}

import { ClientAuth } from './enums';

export class EventBusOptions {

  constructor();
  constructor(obj: EventBusOptions);
  /**
   * Set the accept back log.
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setAcceptBacklog(int)
   * 
   */
  getAcceptBacklog(): number;

  /**
   * Set the accept back log.
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setAcceptBacklog(int)
   * 
   */
  setAcceptBacklog(acceptBacklog: number): EventBusOptions;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setClientAuth(ClientAuth)
   * 
   */
  getClientAuth(): ClientAuth;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setClientAuth(ClientAuth)
   * 
   */
  setClientAuth(clientAuth: ClientAuth): EventBusOptions;

  /**
   * Set the value of cluster ping interval, in ms.
   * @param clusterPingInterval The value of cluster ping interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getClusterPingInterval(): number;

  /**
   * Set the value of cluster ping interval, in ms.
   * @param clusterPingInterval The value of cluster ping interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClusterPingInterval(clusterPingInterval: number): EventBusOptions;

  /**
   * Set the value of cluster ping reply interval, in ms.
   * @param clusterPingReplyInterval The value of cluster ping reply interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getClusterPingReplyInterval(): number;

  /**
   * Set the value of cluster ping reply interval, in ms.
   * @param clusterPingReplyInterval The value of cluster ping reply interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClusterPingReplyInterval(clusterPingReplyInterval: number): EventBusOptions;

  /**
   * Set the public facing hostname to be used for clustering.
   *  Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is
   *  not the same address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of
   *  proxying. If this is the case you can specify a public hostname which is different from the hostname the
   *  server listens at.
   *  <p>
   *  The default value is null which means use the same as the cluster hostname.
   * @param clusterPublicHost the public host name to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getClusterPublicHost(): string;

  /**
   * Set the public facing hostname to be used for clustering.
   *  Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is
   *  not the same address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of
   *  proxying. If this is the case you can specify a public hostname which is different from the hostname the
   *  server listens at.
   *  <p>
   *  The default value is null which means use the same as the cluster hostname.
   * @param clusterPublicHost the public host name to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClusterPublicHost(clusterPublicHost: string): EventBusOptions;

  /**
   * See {@link #setClusterPublicHost(String)} for an explanation.
   * @param clusterPublicPort  the public port to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getClusterPublicPort(): number;

  /**
   * See {@link #setClusterPublicHost(String)} for an explanation.
   * @param clusterPublicPort  the public port to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClusterPublicPort(clusterPublicPort: number): EventBusOptions;

  /**
   * Sets whether or not the event bus is clustered.
   * @param clustered {@code true} to start the event bus as a clustered event bus.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isClustered(): boolean;

  /**
   * Sets whether or not the event bus is clustered.
   * @param clustered {@code true} to start the event bus as a clustered event bus.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClustered(clustered: boolean): EventBusOptions;

  /**
   * Sets the connect timeout
   * @param connectTimeout connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setConnectTimeout(int)
   * 
   */
  getConnectTimeout(): number;

  /**
   * Sets the connect timeout
   * @param connectTimeout connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setConnectTimeout(int)
   * 
   */
  setConnectTimeout(connectTimeout: number): EventBusOptions;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): EventBusOptions;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): EventBusOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): EventBusOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): EventBusOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): EventBusOptions;

  /**
   * Sets the host.
   * @param host the host
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setHost(String)
   * 
   */
  getHost(): string;

  /**
   * Sets the host.
   * @param host the host
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setHost(String)
   * 
   */
  setHost(host: string): EventBusOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): EventBusOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): EventBusOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): EventBusOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): EventBusOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): EventBusOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): EventBusOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): EventBusOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): EventBusOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): EventBusOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): EventBusOptions;

  /**
   * Sets the port.
   * @param port the port
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setPort(int)
   * 
   */
  getPort(): number;

  /**
   * Sets the port.
   * @param port the port
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setPort(int)
   * 
   */
  setPort(port: number): EventBusOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): EventBusOptions;

  /**
   * Sets the value of reconnect attempts.
   * @param attempts the maximum number of reconnect attempts
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setReconnectAttempts(int)
   * 
   */
  getReconnectAttempts(): number;

  /**
   * Sets the value of reconnect attempts.
   * @param attempts the maximum number of reconnect attempts
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setReconnectAttempts(int)
   * 
   */
  setReconnectAttempts(reconnectAttempts: number): EventBusOptions;

  /**
   * Set the reconnect interval.
   * @param interval the reconnect interval in ms
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setReconnectInterval(long)
   * 
   */
  getReconnectInterval(): number;

  /**
   * Set the reconnect interval.
   * @param interval the reconnect interval in ms
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setReconnectInterval(long)
   * 
   */
  setReconnectInterval(reconnectInterval: number): EventBusOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): EventBusOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): EventBusOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): EventBusOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): EventBusOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): EventBusOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): EventBusOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): EventBusOptions;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): EventBusOptions;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): EventBusOptions;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): EventBusOptions;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): EventBusOptions;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): EventBusOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): EventBusOptions;

  /**
   * Set whether all server certificates should be trusted.
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setTrustAll(boolean)
   * 
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted.
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setTrustAll(boolean)
   * 
   */
  setTrustAll(trustAll: boolean): EventBusOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): EventBusOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): EventBusOptions;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): EventBusOptions;
}

export class FileSystemOptions {

  constructor();
  constructor(obj: FileSystemOptions);
  /**
   * When vert.x cannot find the file on the filesystem it tries to resolve the
   *  file from the class path when this is set to {@code true}.
   * @param classPathResolvingEnabled the value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isClassPathResolvingEnabled(): boolean;

  /**
   * When vert.x cannot find the file on the filesystem it tries to resolve the
   *  file from the class path when this is set to {@code true}.
   * @param classPathResolvingEnabled the value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClassPathResolvingEnabled(classPathResolvingEnabled: boolean): FileSystemOptions;

  /**
   * When vert.x reads a file that is packaged with the application it gets
   *  extracted to this directory first and subsequent reads will use the extracted
   *  file to get better IO performance.
   * @param fileCacheDir the value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getFileCacheDir(): string;

  /**
   * When vert.x reads a file that is packaged with the application it gets
   *  extracted to this directory first and subsequent reads will use the extracted
   *  file to get better IO performance.
   * @param fileCacheDir the value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setFileCacheDir(fileCacheDir: string): FileSystemOptions;

  /**
   * Set to {@code true} to cache files on the real file system
   *  when the filesystem performs class path resolving.
   * @param fileCachingEnabled the value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isFileCachingEnabled(): boolean;

  /**
   * Set to {@code true} to cache files on the real file system
   *  when the filesystem performs class path resolving.
   * @param fileCachingEnabled the value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setFileCachingEnabled(fileCachingEnabled: boolean): FileSystemOptions;
}

export class GoAway {

  constructor();
  constructor(obj: GoAway);
  /**
   * Set the additional debug data
   * @param debugData the data
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getDebugData(): Buffer;

  /**
   * Set the additional debug data
   * @param debugData the data
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDebugData(debugData: Buffer): GoAway;

  /**
   *
   * @return the {@literal GOAWAY} error code
   * 
   */
  getErrorCode(): number;

  /**
   *
   * @return the {@literal GOAWAY} error code
   * 
   */
  setErrorCode(errorCode: number): GoAway;

  /**
   * Set the last stream id.
   * @param lastStreamId the last stream id
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLastStreamId(): number;

  /**
   * Set the last stream id.
   * @param lastStreamId the last stream id
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLastStreamId(lastStreamId: number): GoAway;
}

export class Http2Settings {

  constructor();
  constructor(obj: Http2Settings);
  /**
   * Set {@literal SETTINGS_HEADER_TABLE_SIZE} HTTP/2 setting.
   * @param headerTableSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHeaderTableSize(): number;

  /**
   * Set {@literal SETTINGS_HEADER_TABLE_SIZE} HTTP/2 setting.
   * @param headerTableSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHeaderTableSize(headerTableSize: number): Http2Settings;

  /**
   * Set the {@literal SETTINGS_INITIAL_WINDOW_SIZE} HTTP/2 setting
   * @param initialWindowSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getInitialWindowSize(): number;

  /**
   * Set the {@literal SETTINGS_INITIAL_WINDOW_SIZE} HTTP/2 setting
   * @param initialWindowSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setInitialWindowSize(initialWindowSize: number): Http2Settings;

  /**
   * Set the {@literal SETTINGS_MAX_CONCURRENT_STREAMS} HTTP/2 setting
   * @param maxConcurrentStreams the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxConcurrentStreams(): number;

  /**
   * Set the {@literal SETTINGS_MAX_CONCURRENT_STREAMS} HTTP/2 setting
   * @param maxConcurrentStreams the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxConcurrentStreams(maxConcurrentStreams: number): Http2Settings;

  /**
   * Set the {@literal SETTINGS_MAX_FRAME_SIZE} HTTP/2 setting
   * @param maxFrameSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxFrameSize(): number;

  /**
   * Set the {@literal SETTINGS_MAX_FRAME_SIZE} HTTP/2 setting
   * @param maxFrameSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxFrameSize(maxFrameSize: number): Http2Settings;

  /**
   * Set the {@literal SETTINGS_MAX_HEADER_LIST_SIZE} HTTP/2 setting
   * @param maxHeaderListSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxHeaderListSize(): number;

  /**
   * Set the {@literal SETTINGS_MAX_HEADER_LIST_SIZE} HTTP/2 setting
   * @param maxHeaderListSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxHeaderListSize(maxHeaderListSize: number): Http2Settings;

  /**
   * Set the {@literal SETTINGS_ENABLE_PUSH} HTTP/2 setting
   * @param pushEnabled the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isPushEnabled(): boolean;

  /**
   * Set the {@literal SETTINGS_ENABLE_PUSH} HTTP/2 setting
   * @param pushEnabled the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPushEnabled(pushEnabled: boolean): Http2Settings;
}

import { HttpVersion } from './enums';

export class HttpClientOptions {

  constructor();
  constructor(obj: HttpClientOptions);
  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiation.
   *  When the list is empty, the client provides a best effort list according to {@link #setProtocolVersion}:
   * 
   *  <ul>
   *    <li>{@link HttpVersion#HTTP_2}: [ "h2", "http/1.1" ]</li>
   *    <li>otherwise: [{@link #getProtocolVersion()}]</li>
   *  </ul>
   * @param alpnVersions the versions
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getAlpnVersions(): HttpVersion;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiation.
   *  When the list is empty, the client provides a best effort list according to {@link #setProtocolVersion}:
   * 
   *  <ul>
   *    <li>{@link HttpVersion#HTTP_2}: [ "h2", "http/1.1" ]</li>
   *    <li>otherwise: [{@link #getProtocolVersion()}]</li>
   *  </ul>
   * @param alpnVersions the versions
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAlpnVersions(alpnVersions: HttpVersion): HttpClientOptions;

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getConnectTimeout(): number;

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setConnectTimeout(connectTimeout: number): HttpClientOptions;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): HttpClientOptions;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): HttpClientOptions;

  /**
   * set to {@code initialBufferSizeHttpDecoder} the initial buffer of the HttpDecoder.
   * @param decoderInitialBufferSize the initial buffer size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getDecoderInitialBufferSize(): number;

  /**
   * set to {@code initialBufferSizeHttpDecoder} the initial buffer of the HttpDecoder.
   * @param decoderInitialBufferSize the initial buffer size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDecoderInitialBufferSize(decoderInitialBufferSize: number): HttpClientOptions;

  /**
   * Set the default host name to be used by this client in requests if none is provided when making the request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getDefaultHost(): string;

  /**
   * Set the default host name to be used by this client in requests if none is provided when making the request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDefaultHost(defaultHost: string): HttpClientOptions;

  /**
   * Set the default port to be used by this client in requests if none is provided when making the request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getDefaultPort(): number;

  /**
   * Set the default port to be used by this client in requests if none is provided when making the request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDefaultPort(defaultPort: number): HttpClientOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): HttpClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): HttpClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): HttpClientOptions;

  /**
   * By default, the server name is only sent for Fully Qualified Domain Name (FQDN), setting
   *  this property to {@code true} forces the server name to be always sent.
   * @param forceSni {@code true} when the client should always use SNI on TLS/SSL connections
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isForceSni(): boolean;

  /**
   * By default, the server name is only sent for Fully Qualified Domain Name (FQDN), setting
   *  this property to {@code true} forces the server name to be always sent.
   * @param forceSni {@code true} when the client should always use SNI on TLS/SSL connections
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setForceSni(forceSni: boolean): HttpClientOptions;

  /**
   * Set to {@code true} when an <i>h2c</i> connection is established using an HTTP/1.1 upgrade request, and {@code false}
   *  when an <i>h2c</i> connection is established directly (with prior knowledge).
   * @param value the upgrade value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isHttp2ClearTextUpgrade(): boolean;

  /**
   * Set to {@code true} when an <i>h2c</i> connection is established using an HTTP/1.1 upgrade request, and {@code false}
   *  when an <i>h2c</i> connection is established directly (with prior knowledge).
   * @param value the upgrade value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2ClearTextUpgrade(http2ClearTextUpgrade: boolean): HttpClientOptions;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   *  size set by {@link Http2Settings#getInitialWindowSize}, so the connection window size
   *  is greater than for its streams, in order the data throughput.
   *  <p/>
   *  A value of {@code -1} reuses the initial window size setting.
   * @param http2ConnectionWindowSize the window size applied to the connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHttp2ConnectionWindowSize(): number;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   *  size set by {@link Http2Settings#getInitialWindowSize}, so the connection window size
   *  is greater than for its streams, in order the data throughput.
   *  <p/>
   *  A value of {@code -1} reuses the initial window size setting.
   * @param http2ConnectionWindowSize the window size applied to the connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2ConnectionWindowSize(http2ConnectionWindowSize: number): HttpClientOptions;

  /**
   * Set the keep alive timeout for HTTP/2 connections, in seconds.
   *  <p/>
   *  This value determines how long a connection remains unused in the pool before being evicted and closed.
   * @param keepAliveTimeout the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHttp2KeepAliveTimeout(): number;

  /**
   * Set the keep alive timeout for HTTP/2 connections, in seconds.
   *  <p/>
   *  This value determines how long a connection remains unused in the pool before being evicted and closed.
   * @param keepAliveTimeout the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2KeepAliveTimeout(http2KeepAliveTimeout: number): HttpClientOptions;

  /**
   * Set the maximum pool size for HTTP/2 connections
   * @param max  the maximum pool size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHttp2MaxPoolSize(): number;

  /**
   * Set the maximum pool size for HTTP/2 connections
   * @param max  the maximum pool size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2MaxPoolSize(http2MaxPoolSize: number): HttpClientOptions;

  /**
   * Set a client limit of the number concurrent streams for each HTTP/2 connection, this limits the number
   *  of streams the client can create for a connection. The effective number of streams for a
   *  connection is the min of this value and the server's initial settings.
   *  <p/>
   *  Setting the value to {@code -1} means to use the value sent by the server's initial settings.
   *  {@code -1} is the default value.
   * @param limit the maximum concurrent for an HTTP/2 connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHttp2MultiplexingLimit(): number;

  /**
   * Set a client limit of the number concurrent streams for each HTTP/2 connection, this limits the number
   *  of streams the client can create for a connection. The effective number of streams for a
   *  connection is the min of this value and the server's initial settings.
   *  <p/>
   *  Setting the value to {@code -1} means to use the value sent by the server's initial settings.
   *  {@code -1} is the default value.
   * @param limit the maximum concurrent for an HTTP/2 connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2MultiplexingLimit(http2MultiplexingLimit: number): HttpClientOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): HttpClientOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): HttpClientOptions;

  /**
   * Set the HTTP/2 connection settings immediately sent by to the server when the client connects.
   * @param settings the settings value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getInitialSettings(): Http2Settings;

  /**
   * Set the HTTP/2 connection settings immediately sent by to the server when the client connects.
   * @param settings the settings value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setInitialSettings(initialSettings: Http2Settings): HttpClientOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): HttpClientOptions;

  /**
   * Set whether keep alive is enabled on the client
   * @param keepAlive {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isKeepAlive(): boolean;

  /**
   * Set whether keep alive is enabled on the client
   * @param keepAlive {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeepAlive(keepAlive: boolean): HttpClientOptions;

  /**
   * Set the keep alive timeout for HTTP/1.x, in seconds.
   *  <p/>
   *  This value determines how long a connection remains unused in the pool before being evicted and closed.
   * @param keepAliveTimeout the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeepAliveTimeout(): number;

  /**
   * Set the keep alive timeout for HTTP/1.x, in seconds.
   *  <p/>
   *  This value determines how long a connection remains unused in the pool before being evicted and closed.
   * @param keepAliveTimeout the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeepAliveTimeout(keepAliveTimeout: number): HttpClientOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): HttpClientOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLocalAddress(): string;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLocalAddress(localAddress: string): HttpClientOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): HttpClientOptions;

  /**
   * Set the maximum HTTP chunk size
   * @param maxChunkSize the maximum chunk size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxChunkSize(): number;

  /**
   * Set the maximum HTTP chunk size
   * @param maxChunkSize the maximum chunk size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxChunkSize(maxChunkSize: number): HttpClientOptions;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   * @param maxHeaderSize the new maximum length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxHeaderSize(): number;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   * @param maxHeaderSize the new maximum length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxHeaderSize(maxHeaderSize: number): HttpClientOptions;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. {@code "HTTP/1.1 200 OK"})
   * @param maxInitialLineLength the new maximum initial length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxInitialLineLength(): number;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. {@code "HTTP/1.1 200 OK"})
   * @param maxInitialLineLength the new maximum initial length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxInitialLineLength(maxInitialLineLength: number): HttpClientOptions;

  /**
   * Set the maximum pool size for connections
   * @param maxPoolSize  the maximum pool size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxPoolSize(): number;

  /**
   * Set the maximum pool size for connections
   * @param maxPoolSize  the maximum pool size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxPoolSize(maxPoolSize: number): HttpClientOptions;

  /**
   * Set to {@code maxRedirects} the maximum number of redirection a request can follow.
   * @param maxRedirects the maximum number of redirection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxRedirects(): number;

  /**
   * Set to {@code maxRedirects} the maximum number of redirection a request can follow.
   * @param maxRedirects the maximum number of redirection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxRedirects(maxRedirects: number): HttpClientOptions;

  /**
   * Set the maximum requests allowed in the wait queue, any requests beyond the max size will result in
   *  a ConnectionPoolTooBusyException.  If the value is set to a negative number then the queue will be unbounded.
   * @param maxWaitQueueSize the maximum number of waiting requests
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWaitQueueSize(): number;

  /**
   * Set the maximum requests allowed in the wait queue, any requests beyond the max size will result in
   *  a ConnectionPoolTooBusyException.  If the value is set to a negative number then the queue will be unbounded.
   * @param maxWaitQueueSize the maximum number of waiting requests
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWaitQueueSize(maxWaitQueueSize: number): HttpClientOptions;

  /**
   * Set the max WebSocket frame size
   * @param maxWebsocketFrameSize  the max frame size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWebsocketFrameSize(): number;

  /**
   * Set the max WebSocket frame size
   * @param maxWebsocketFrameSize  the max frame size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWebsocketFrameSize(maxWebsocketFrameSize: number): HttpClientOptions;

  /**
   * Set the max WebSocket message size
   * @param maxWebsocketMessageSize  the max message size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWebsocketMessageSize(): number;

  /**
   * Set the max WebSocket message size
   * @param maxWebsocketMessageSize  the max message size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWebsocketMessageSize(maxWebsocketMessageSize: number): HttpClientOptions;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMetricsName(): string;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMetricsName(metricsName: string): HttpClientOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): HttpClientOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): HttpClientOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): HttpClientOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): HttpClientOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): HttpClientOptions;

  /**
   * Set whether pipe-lining is enabled on the client
   * @param pipelining {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isPipelining(): boolean;

  /**
   * Set whether pipe-lining is enabled on the client
   * @param pipelining {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPipelining(pipelining: boolean): HttpClientOptions;

  /**
   * Set the limit of pending requests a pipe-lined HTTP/1 connection can send.
   * @param limit the limit of pending requests
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPipeliningLimit(): number;

  /**
   * Set the limit of pending requests a pipe-lined HTTP/1 connection can send.
   * @param limit the limit of pending requests
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPipeliningLimit(pipeliningLimit: number): HttpClientOptions;

  /**
   * Set the connection pool cleaner period in milli seconds, a non positive value disables expiration checks and connections
   *  will remain in the pool until they are closed.
   * @param poolCleanerPeriod the pool cleaner period
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPoolCleanerPeriod(): number;

  /**
   * Set the connection pool cleaner period in milli seconds, a non positive value disables expiration checks and connections
   *  will remain in the pool until they are closed.
   * @param poolCleanerPeriod the pool cleaner period
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPoolCleanerPeriod(poolCleanerPeriod: number): HttpClientOptions;

  /**
   * Set the protocol version.
   * @param protocolVersion the protocol version
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getProtocolVersion(): HttpVersion;

  /**
   * Set the protocol version.
   * @param protocolVersion the protocol version
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setProtocolVersion(protocolVersion: HttpVersion): HttpClientOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getProxyOptions(): ProxyOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setProxyOptions(proxyOptions: ProxyOptions): HttpClientOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): HttpClientOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): HttpClientOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): HttpClientOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): HttpClientOptions;

  /**
   * Set {@code true} when the client wants to skip frame masking.
   *  <p>
   *  You may want to set it {@code true} on server by server WebSocket communication: in this case you are by passing
   *  RFC6455 protocol.
   *  <p>
   *  It's {@code false} as default.
   * @param sendUnmaskedFrames  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSendUnmaskedFrames(): boolean;

  /**
   * Set {@code true} when the client wants to skip frame masking.
   *  <p>
   *  You may want to set it {@code true} on server by server WebSocket communication: in this case you are by passing
   *  RFC6455 protocol.
   *  <p>
   *  It's {@code false} as default.
   * @param sendUnmaskedFrames  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendUnmaskedFrames(sendUnmaskedFrames: boolean): HttpClientOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): HttpClientOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): HttpClientOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): HttpClientOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): HttpClientOptions;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): HttpClientOptions;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): HttpClientOptions;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): HttpClientOptions;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): HttpClientOptions;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): HttpClientOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): HttpClientOptions;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustAll(trustAll: boolean): HttpClientOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): HttpClientOptions;

  /**
   * Set whether compression is enabled
   * @param tryUseCompression {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTryUseCompression(): boolean;

  /**
   * Set whether compression is enabled
   * @param tryUseCompression {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTryUseCompression(tryUseCompression: boolean): HttpClientOptions;

  /**
   * Set whether the client will offer the WebSocket per-frame deflate compression extension.
   * @param offer {@code true} to offer the per-frame deflate compression extension
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tryUsePerFrameWebsocketCompression(): boolean;

  /**
   * Set whether the client will offer the WebSocket per-frame deflate compression extension.
   * @param offer {@code true} to offer the per-frame deflate compression extension
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTryUsePerFrameWebsocketCompression(tryUsePerFrameWebsocketCompression: boolean): HttpClientOptions;

  /**
   * Set whether the client will offer the WebSocket per-message deflate compression extension.
   * @param offer {@code true} to offer the per-message deflate compression extension
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getTryUsePerMessageWebsocketCompression(): boolean;

  /**
   * Set whether the client will offer the WebSocket per-message deflate compression extension.
   * @param offer {@code true} to offer the per-message deflate compression extension
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setTryUsePerMessageWebsocketCompression(tryUsePerMessageWebsocketCompression: boolean): HttpClientOptions;

  /**
   *
   * @return {@code true} when the WebSocket per-frame deflate compression extension will be offered
   * 
   */
  getTryWebsocketDeflateFrameCompression(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): HttpClientOptions;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): HttpClientOptions;

  /**
   * Set whether hostname verification is enabled
   * @param verifyHost {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isVerifyHost(): boolean;

  /**
   * Set whether hostname verification is enabled
   * @param verifyHost {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setVerifyHost(verifyHost: boolean): HttpClientOptions;

  /**
   * Set whether the {@code client_no_context_takeover} parameter of the WebSocket per-message
   *  deflate compression extension will be offered.
   * @param offer {@code true} to offer the {@code client_no_context_takeover} parameter
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketCompressionAllowClientNoContext(): boolean;

  /**
   * Set whether the {@code client_no_context_takeover} parameter of the WebSocket per-message
   *  deflate compression extension will be offered.
   * @param offer {@code true} to offer the {@code client_no_context_takeover} parameter
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketCompressionAllowClientNoContext(websocketCompressionAllowClientNoContext: boolean): HttpClientOptions;

  /**
   * Set the Websocket deflate compression level.
   * @param compressionLevel the WebSocket deflate compression level
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketCompressionLevel(): number;

  /**
   * Set the Websocket deflate compression level.
   * @param compressionLevel the WebSocket deflate compression level
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketCompressionLevel(websocketCompressionLevel: number): HttpClientOptions;

  /**
   * Set whether the {@code server_no_context_takeover} parameter of the WebSocket per-message
   *  deflate compression extension will be offered.
   * @param offer {@code true} to offer the {@code server_no_context_takeover} parameter
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketCompressionRequestServerNoContext(): boolean;

  /**
   * Set whether the {@code server_no_context_takeover} parameter of the WebSocket per-message
   *  deflate compression extension will be offered.
   * @param offer {@code true} to offer the {@code server_no_context_takeover} parameter
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketCompressionRequestServerNoContext(websocketCompressionRequestServerNoContext: boolean): HttpClientOptions;
}

export class HttpServerOptions {

  constructor();
  constructor(obj: HttpServerOptions);
  /**
   * Set the accept back log
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getAcceptBacklog(): number;

  /**
   * Set the accept back log
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAcceptBacklog(acceptBacklog: number): HttpServerOptions;

  /**
   * Set {@code true} when the server accepts unmasked frame.
   *  As default Server doesn't accept unmasked frame, you can bypass this behaviour (RFC 6455) setting {@code true}.
   *  It's set to {@code false} as default.
   * @param acceptUnmaskedFrames {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isAcceptUnmaskedFrames(): boolean;

  /**
   * Set {@code true} when the server accepts unmasked frame.
   *  As default Server doesn't accept unmasked frame, you can bypass this behaviour (RFC 6455) setting {@code true}.
   *  It's set to {@code false} as default.
   * @param acceptUnmaskedFrames {@code true} if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAcceptUnmaskedFrames(acceptUnmaskedFrames: boolean): HttpServerOptions;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiatiation.
   * @param alpnVersions the versions
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getAlpnVersions(): HttpVersion;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiatiation.
   * @param alpnVersions the versions
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAlpnVersions(alpnVersions: HttpVersion): HttpServerOptions;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getClientAuth(): ClientAuth;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClientAuth(clientAuth: ClientAuth): HttpServerOptions;

  /**
   * Set whether client auth is required
   * @param clientAuthRequired  true if client auth is required
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.REQUIRED)} or {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.NONE)} instead
   * 
   */
  isClientAuthRequired(): boolean;

  /**
   * Set whether client auth is required
   * @param clientAuthRequired  true if client auth is required
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.REQUIRED)} or {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.NONE)} instead
   * 
   */
  setClientAuthRequired(clientAuthRequired: boolean): HttpServerOptions;

  /**
   * This method allows to set the compression level to be used in http1.x/2 response bodies
   *  when compression support is turned on (@see setCompressionSupported) and the client advertises
   *  to support {@code deflate/gzip} compression in the {@code Accept-Encoding} header
   * 
   *  default value is : 6 (Netty legacy)
   * 
   *  The compression level determines how much the data is compressed on a scale from 1 to 9,
   *  where '9' is trying to achieve the maximum compression ratio while '1' instead is giving
   *  priority to speed instead of compression ratio using some algorithm optimizations and skipping
   *  pedantic loops that usually gives just little improvements
   * 
   *  While one can think that best value is always the maximum compression ratio,
   *  there's a trade-off to consider: the most compressed level requires the most
   *  computational work to compress/decompress data, e.g. more dictionary lookups and loops.
   * 
   *  E.g. you have it set fairly high on a high-volume website, you may experience performance degradation
   *  and latency on resource serving due to CPU overload, and, however - as the computational work is required also client side
   *  while decompressing - setting an higher compression level can result in an overall higher page load time
   *  especially nowadays when many clients are handled mobile devices with a low CPU profile.
   * 
   *  see also: http://www.gzip.org/algorithm.txt
   * @param compressionLevel integer 1-9, 1 means use fastest algorithm, 9 slower algorithm but better compression ratio
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getCompressionLevel(): number;

  /**
   * This method allows to set the compression level to be used in http1.x/2 response bodies
   *  when compression support is turned on (@see setCompressionSupported) and the client advertises
   *  to support {@code deflate/gzip} compression in the {@code Accept-Encoding} header
   * 
   *  default value is : 6 (Netty legacy)
   * 
   *  The compression level determines how much the data is compressed on a scale from 1 to 9,
   *  where '9' is trying to achieve the maximum compression ratio while '1' instead is giving
   *  priority to speed instead of compression ratio using some algorithm optimizations and skipping
   *  pedantic loops that usually gives just little improvements
   * 
   *  While one can think that best value is always the maximum compression ratio,
   *  there's a trade-off to consider: the most compressed level requires the most
   *  computational work to compress/decompress data, e.g. more dictionary lookups and loops.
   * 
   *  E.g. you have it set fairly high on a high-volume website, you may experience performance degradation
   *  and latency on resource serving due to CPU overload, and, however - as the computational work is required also client side
   *  while decompressing - setting an higher compression level can result in an overall higher page load time
   *  especially nowadays when many clients are handled mobile devices with a low CPU profile.
   * 
   *  see also: http://www.gzip.org/algorithm.txt
   * @param compressionLevel integer 1-9, 1 means use fastest algorithm, 9 slower algorithm but better compression ratio
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCompressionLevel(compressionLevel: number): HttpServerOptions;

  /**
   * Set whether the server should support gzip/deflate compression
   *  (serving compressed responses to clients advertising support for them with Accept-Encoding header)
   * @param compressionSupported {@code true} to enable compression support
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isCompressionSupported(): boolean;

  /**
   * Set whether the server should support gzip/deflate compression
   *  (serving compressed responses to clients advertising support for them with Accept-Encoding header)
   * @param compressionSupported {@code true} to enable compression support
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCompressionSupported(compressionSupported: boolean): HttpServerOptions;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): HttpServerOptions;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): HttpServerOptions;

  /**
   * Set the initial buffer size for the HTTP decoder
   * @param decoderInitialBufferSize the initial size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getDecoderInitialBufferSize(): number;

  /**
   * Set the initial buffer size for the HTTP decoder
   * @param decoderInitialBufferSize the initial size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDecoderInitialBufferSize(decoderInitialBufferSize: number): HttpServerOptions;

  /**
   * Set whether the server supports decompression
   * @param decompressionSupported {@code true} if decompression supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isDecompressionSupported(): boolean;

  /**
   * Set whether the server supports decompression
   * @param decompressionSupported {@code true} if decompression supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDecompressionSupported(decompressionSupported: boolean): HttpServerOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): HttpServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): HttpServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): HttpServerOptions;

  /**
   * Set whether 100 Continue should be handled automatically
   * @param handle100ContinueAutomatically {@code true} if it should be handled automatically
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isHandle100ContinueAutomatically(): boolean;

  /**
   * Set whether 100 Continue should be handled automatically
   * @param handle100ContinueAutomatically {@code true} if it should be handled automatically
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHandle100ContinueAutomatically(handle100ContinueAutomatically: boolean): HttpServerOptions;

  /**
   * Set the host
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHost(): string;

  /**
   * Set the host
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHost(host: string): HttpServerOptions;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   *  size set by {@link Http2Settings#getInitialWindowSize}, so the connection window size
   *  is greater than for its streams, in order the data throughput.
   *  <p/>
   *  A value of {@code -1} reuses the initial window size setting.
   * @param http2ConnectionWindowSize the window size applied to the connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHttp2ConnectionWindowSize(): number;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   *  size set by {@link Http2Settings#getInitialWindowSize}, so the connection window size
   *  is greater than for its streams, in order the data throughput.
   *  <p/>
   *  A value of {@code -1} reuses the initial window size setting.
   * @param http2ConnectionWindowSize the window size applied to the connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2ConnectionWindowSize(http2ConnectionWindowSize: number): HttpServerOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): HttpServerOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): HttpServerOptions;

  /**
   * Set the HTTP/2 connection settings immediatly sent by the server when a client connects.
   * @param settings the settings value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getInitialSettings(): Http2Settings;

  /**
   * Set the HTTP/2 connection settings immediatly sent by the server when a client connects.
   * @param settings the settings value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setInitialSettings(initialSettings: Http2Settings): HttpServerOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): HttpServerOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): HttpServerOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): HttpServerOptions;

  /**
   * Set the maximum HTTP chunk size that {@link HttpServerRequest#handler(Handler)} will receive
   * @param maxChunkSize the maximum chunk size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxChunkSize(): number;

  /**
   * Set the maximum HTTP chunk size that {@link HttpServerRequest#handler(Handler)} will receive
   * @param maxChunkSize the maximum chunk size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxChunkSize(maxChunkSize: number): HttpServerOptions;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   * @param maxHeaderSize the new maximum length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxHeaderSize(): number;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   * @param maxHeaderSize the new maximum length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxHeaderSize(maxHeaderSize: number): HttpServerOptions;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. {@code "GET / HTTP/1.0"})
   * @param maxInitialLineLength the new maximum initial length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxInitialLineLength(): number;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. {@code "GET / HTTP/1.0"})
   * @param maxInitialLineLength the new maximum initial length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxInitialLineLength(maxInitialLineLength: number): HttpServerOptions;

  /**
   * Set the maximum WebSocket frames size
   * @param maxWebsocketFrameSize  the maximum frame size in bytes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWebsocketFrameSize(): number;

  /**
   * Set the maximum WebSocket frames size
   * @param maxWebsocketFrameSize  the maximum frame size in bytes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWebsocketFrameSize(maxWebsocketFrameSize: number): HttpServerOptions;

  /**
   * Set the maximum WebSocket message size
   * @param maxWebsocketMessageSize  the maximum message size in bytes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWebsocketMessageSize(): number;

  /**
   * Set the maximum WebSocket message size
   * @param maxWebsocketMessageSize  the maximum message size in bytes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWebsocketMessageSize(maxWebsocketMessageSize: number): HttpServerOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): HttpServerOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): HttpServerOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): HttpServerOptions;

  /**
   * Enable or disable support for the WebSocket per-frame deflate compression extension.
   * @param supported {@code true} when the per-frame deflate compression extension is supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPerFrameWebsocketCompressionSupported(): boolean;

  /**
   * Enable or disable support for the WebSocket per-frame deflate compression extension.
   * @param supported {@code true} when the per-frame deflate compression extension is supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPerFrameWebsocketCompressionSupported(perFrameWebsocketCompressionSupported: boolean): HttpServerOptions;

  /**
   * Enable or disable support for WebSocket per-message deflate compression extension.
   * @param supported {@code true} when the per-message Websocket compression extension is supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPerMessageWebsocketCompressionSupported(): boolean;

  /**
   * Enable or disable support for WebSocket per-message deflate compression extension.
   * @param supported {@code true} when the per-message Websocket compression extension is supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPerMessageWebsocketCompressionSupported(perMessageWebsocketCompressionSupported: boolean): HttpServerOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): HttpServerOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): HttpServerOptions;

  /**
   * Set the port
   * @param port  the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPort(): number;

  /**
   * Set the port
   * @param port  the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPort(port: number): HttpServerOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): HttpServerOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): HttpServerOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): HttpServerOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): HttpServerOptions;

  /**
   * Set whether the server supports Server Name Indiciation
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSni(): boolean;

  /**
   * Set whether the server supports Server Name Indiciation
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSni(sni: boolean): HttpServerOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): HttpServerOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): HttpServerOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): HttpServerOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): HttpServerOptions;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): HttpServerOptions;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): HttpServerOptions;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): HttpServerOptions;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): HttpServerOptions;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): HttpServerOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): HttpServerOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): HttpServerOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): HttpServerOptions;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): HttpServerOptions;

  /**
   * Set whether the WebSocket server will accept the {@code server_no_context_takeover} parameter of the per-message
   *  deflate compression extension offered by the client.
   * @param accept {@code true} to accept the {@literal server_no_context_takeover} parameter when the client offers it
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketAllowServerNoContext(): boolean;

  /**
   * Set whether the WebSocket server will accept the {@code server_no_context_takeover} parameter of the per-message
   *  deflate compression extension offered by the client.
   * @param accept {@code true} to accept the {@literal server_no_context_takeover} parameter when the client offers it
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketAllowServerNoContext(websocketAllowServerNoContext: boolean): HttpServerOptions;

  /**
   * Set the WebSocket compression level.
   * @param compressionLevel the compression level
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketCompressionLevel(): number;

  /**
   * Set the WebSocket compression level.
   * @param compressionLevel the compression level
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketCompressionLevel(websocketCompressionLevel: number): HttpServerOptions;

  /**
   * Set whether the WebSocket server will accept the {@code client_no_context_takeover} parameter of the per-message
   *  deflate compression extension offered by the client.
   * @param accept {@code true} to accept the {@code client_no_context_takeover} parameter when the client offers it
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketPreferredClientNoContext(): boolean;

  /**
   * Set whether the WebSocket server will accept the {@code client_no_context_takeover} parameter of the per-message
   *  deflate compression extension offered by the client.
   * @param accept {@code true} to accept the {@code client_no_context_takeover} parameter when the client offers it
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketPreferredClientNoContext(websocketPreferredClientNoContext: boolean): HttpServerOptions;

  /**
   * Set the WebSocket sub-protocols supported by the server.
   * @param subProtocols  comma separated list of subprotocols
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWebsocketSubProtocols(): string;

  /**
   * Set the WebSocket sub-protocols supported by the server.
   * @param subProtocols  comma separated list of subprotocols
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWebsocketSubProtocols(websocketSubProtocols: string): HttpServerOptions;
}

export class JdkSSLEngineOptions {

  constructor();
  constructor(obj: JdkSSLEngineOptions);
}

export class JksOptions {

  constructor();
  constructor(obj: JksOptions);
  /**
   * Set the password for the key store
   * @param password  the password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPassword(): string;

  /**
   * Set the password for the key store
   * @param password  the password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPassword(password: string): JksOptions;

  /**
   * Set the path to the key store
   * @param path  the path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPath(): string;

  /**
   * Set the path to the key store
   * @param path  the path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPath(path: string): JksOptions;

  /**
   * Set the key store as a buffer
   * @param value  the key store as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getValue(): Buffer;

  /**
   * Set the key store as a buffer
   * @param value  the key store as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setValue(value: Buffer): JksOptions;
}

export class MetricsOptions {

  constructor();
  constructor(obj: MetricsOptions);
  /**
   * Set whether metrics will be enabled on the Vert.x instance.
   * @param enable true if metrics enabled, or false if not.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isEnabled(): boolean;

  /**
   * Set whether metrics will be enabled on the Vert.x instance.
   * @param enable true if metrics enabled, or false if not.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabled(enabled: boolean): MetricsOptions;
}

export class NetClientOptions {

  constructor();
  constructor(obj: NetClientOptions);
  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getConnectTimeout(): number;

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setConnectTimeout(connectTimeout: number): NetClientOptions;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): NetClientOptions;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): NetClientOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): NetClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): NetClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): NetClientOptions;

  /**
   * Set the hostname verification algorithm interval
   *  To disable hostname verification, set hostnameVerificationAlgorithm to an empty String
   * @param hostnameVerificationAlgorithm should be HTTPS, LDAPS or an empty String
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHostnameVerificationAlgorithm(): string;

  /**
   * Set the hostname verification algorithm interval
   *  To disable hostname verification, set hostnameVerificationAlgorithm to an empty String
   * @param hostnameVerificationAlgorithm should be HTTPS, LDAPS or an empty String
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHostnameVerificationAlgorithm(hostnameVerificationAlgorithm: string): NetClientOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): NetClientOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): NetClientOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): NetClientOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): NetClientOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLocalAddress(): string;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLocalAddress(localAddress: string): NetClientOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): NetClientOptions;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMetricsName(): string;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMetricsName(metricsName: string): NetClientOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): NetClientOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): NetClientOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): NetClientOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): NetClientOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): NetClientOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getProxyOptions(): ProxyOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setProxyOptions(proxyOptions: ProxyOptions): NetClientOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): NetClientOptions;

  /**
   * Set the value of reconnect attempts
   * @param attempts  the maximum number of reconnect attempts
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReconnectAttempts(): number;

  /**
   * Set the value of reconnect attempts
   * @param attempts  the maximum number of reconnect attempts
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReconnectAttempts(reconnectAttempts: number): NetClientOptions;

  /**
   * Set the reconnect interval
   * @param interval  the reconnect interval in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReconnectInterval(): number;

  /**
   * Set the reconnect interval
   * @param interval  the reconnect interval in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReconnectInterval(reconnectInterval: number): NetClientOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): NetClientOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): NetClientOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): NetClientOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): NetClientOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): NetClientOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): NetClientOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): NetClientOptions;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): NetClientOptions;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): NetClientOptions;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): NetClientOptions;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): NetClientOptions;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): NetClientOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): NetClientOptions;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustAll(trustAll: boolean): NetClientOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): NetClientOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): NetClientOptions;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): NetClientOptions;
}

export class NetServerOptions {

  constructor();
  constructor(obj: NetServerOptions);
  /**
   * Set the accept back log
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getAcceptBacklog(): number;

  /**
   * Set the accept back log
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAcceptBacklog(acceptBacklog: number): NetServerOptions;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getClientAuth(): ClientAuth;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setClientAuth(clientAuth: ClientAuth): NetServerOptions;

  /**
   * Set whether client auth is required
   * @param clientAuthRequired  true if client auth is required
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.REQUIRED)} or {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.NONE)} instead
   * 
   */
  isClientAuthRequired(): boolean;

  /**
   * Set whether client auth is required
   * @param clientAuthRequired  true if client auth is required
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.REQUIRED)} or {@link #setClientAuth(ClientAuth) setClientAuth(ClientAuth.NONE)} instead
   * 
   */
  setClientAuthRequired(clientAuthRequired: boolean): NetServerOptions;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): NetServerOptions;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): NetServerOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): NetServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): NetServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): NetServerOptions;

  /**
   * Set the host
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHost(): string;

  /**
   * Set the host
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHost(host: string): NetServerOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): NetServerOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): NetServerOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): NetServerOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): NetServerOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): NetServerOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): NetServerOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): NetServerOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): NetServerOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): NetServerOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): NetServerOptions;

  /**
   * Set the port
   * @param port  the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPort(): number;

  /**
   * Set the port
   * @param port  the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPort(port: number): NetServerOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): NetServerOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): NetServerOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): NetServerOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): NetServerOptions;

  /**
   * Set whether the server supports Server Name Indiciation
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSni(): boolean;

  /**
   * Set whether the server supports Server Name Indiciation
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSni(sni: boolean): NetServerOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): NetServerOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): NetServerOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): NetServerOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): NetServerOptions;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): NetServerOptions;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): NetServerOptions;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): NetServerOptions;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): NetServerOptions;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): NetServerOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): NetServerOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): NetServerOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): NetServerOptions;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): NetServerOptions;
}

export abstract class NetworkOptions {

  constructor();
  constructor(obj: NetworkOptions);
  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): NetworkOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): NetworkOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): NetworkOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): NetworkOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): NetworkOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): NetworkOptions;
}

export class OpenOptions {

  constructor();
  constructor(obj: OpenOptions);
  /**
   * Whether the file should be opened in append mode. Defaults to {@code false}.
   * @param append true to open file in append mode, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isAppend(): boolean;

  /**
   * Whether the file should be opened in append mode. Defaults to {@code false}.
   * @param append true to open file in append mode, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAppend(append: boolean): OpenOptions;

  /**
   * Set whether the file should be created if it does not already exist.
   * @param create  true if the file should be created if it does not already exist
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isCreate(): boolean;

  /**
   * Set whether the file should be created if it does not already exist.
   * @param create  true if the file should be created if it does not already exist
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCreate(create: boolean): OpenOptions;

  /**
   * Set whether the file should be created and fail if it does exist already.
   * @param createNew  true if the file should be created or fail if it exists already
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isCreateNew(): boolean;

  /**
   * Set whether the file should be created and fail if it does exist already.
   * @param createNew  true if the file should be created or fail if it exists already
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCreateNew(createNew: boolean): OpenOptions;

  /**
   * Set whether the file should be deleted when it's closed, or the JVM is shutdown.
   * @param deleteOnClose whether the file should be deleted when it's closed, or the JVM is shutdown.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  isDeleteOnClose(): boolean;

  /**
   * Set whether the file should be deleted when it's closed, or the JVM is shutdown.
   * @param deleteOnClose whether the file should be deleted when it's closed, or the JVM is shutdown.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  setDeleteOnClose(deleteOnClose: boolean): OpenOptions;

  /**
   * Set whether every write to the file's content  ill be written synchronously to the underlying hardware.
   * @param dsync  true if sync
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isDsync(): boolean;

  /**
   * Set whether every write to the file's content  ill be written synchronously to the underlying hardware.
   * @param dsync  true if sync
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDsync(dsync: boolean): OpenOptions;

  /**
   * Set the permissions string
   * @param perms  the permissions string
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPerms(): string;

  /**
   * Set the permissions string
   * @param perms  the permissions string
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPerms(perms: string): OpenOptions;

  /**
   * Set whether the file is to be opened for reading
   * @param read  true if the file is to be opened for reading
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isRead(): boolean;

  /**
   * Set whether the file is to be opened for reading
   * @param read  true if the file is to be opened for reading
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRead(read: boolean): OpenOptions;

  /**
   * Set whether a hint should be provided that the file to created is sparse
   * @param sparse true if a hint should be provided that the file to created is sparse
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSparse(): boolean;

  /**
   * Set whether a hint should be provided that the file to created is sparse
   * @param sparse true if a hint should be provided that the file to created is sparse
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSparse(sparse: boolean): OpenOptions;

  /**
   * Set whether every write to the file's content and meta-data will be written synchronously to the underlying hardware.
   * @param sync  true if sync
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSync(): boolean;

  /**
   * Set whether every write to the file's content and meta-data will be written synchronously to the underlying hardware.
   * @param sync  true if sync
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSync(sync: boolean): OpenOptions;

  /**
   * Set whether the file should be truncated to zero length on opening if it exists and is opened for write
   * @param truncateExisting  true if the file should be truncated to zero length on opening if it exists and is opened for write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTruncateExisting(): boolean;

  /**
   * Set whether the file should be truncated to zero length on opening if it exists and is opened for write
   * @param truncateExisting  true if the file should be truncated to zero length on opening if it exists and is opened for write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTruncateExisting(truncateExisting: boolean): OpenOptions;

  /**
   * Set whether the file is to be opened for writing
   * @param write  true if the file is to be opened for writing
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isWrite(): boolean;

  /**
   * Set whether the file is to be opened for writing
   * @param write  true if the file is to be opened for writing
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWrite(write: boolean): OpenOptions;
}

export class OpenSSLEngineOptions {

  constructor();
  constructor(obj: OpenSSLEngineOptions);
  /**
   * Set whether session cache is enabled in open SSL session server context
   * @param sessionCacheEnabled true if session cache is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSessionCacheEnabled(): boolean;

  /**
   * Set whether session cache is enabled in open SSL session server context
   * @param sessionCacheEnabled true if session cache is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSessionCacheEnabled(sessionCacheEnabled: boolean): OpenSSLEngineOptions;
}

export class Option {

  constructor();
  constructor(obj: Option);
  /**
   * Sets te arg name for this option.
   * @param argName the arg name, must not be {@code null}
   * @return the current {@link Option} instance
   * 
   */
  getArgName(): string;

  /**
   * Sets te arg name for this option.
   * @param argName the arg name, must not be {@code null}
   * @return the current {@link Option} instance
   * 
   */
  setArgName(argName: string): Option;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   *  values, a {@link InvalidValueException} exception is thrown.
   * @param choices the choices
   * @return the current {@link Option}
   * 
   */
  getChoices(): string;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   *  values, a {@link InvalidValueException} exception is thrown.
   * @param choices the choices
   * @return the current {@link Option}
   * 
   */
  setChoices(choices: string): Option;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   *  values, a {@link InvalidValueException} exception is thrown.
   * @param choices the choices
   * @return the current {@link Option}
   * 
   */
  addChoice(choices: string): Option;

  /**
   * Sets the default value of this option
   * @param defaultValue the default value
   * @return the current {@link Option} instance
   * 
   */
  getDefaultValue(): string;

  /**
   * Sets the default value of this option
   * @param defaultValue the default value
   * @return the current {@link Option} instance
   * 
   */
  setDefaultValue(defaultValue: string): Option;

  /**
   * Sets te description of this option.
   * @param description the description
   * @return the current {@link Option} instance
   * 
   */
  getDescription(): string;

  /**
   * Sets te description of this option.
   * @param description the description
   * @return the current {@link Option} instance
   * 
   */
  setDescription(description: string): Option;

  /**
   * Configures the current {@link Option} to be a flag. It will be evaluated to {@code true} if it's found in
   *  the command line. If you need a flag that may receive a value, use, in this order:
   *  <code><pre>
   *    option.setFlag(true).setSingleValued(true)
   *  </pre></code>
   * @param flag whether or not the option is a flag.
   * @return the current {@link Option}
   * 
   */
  isFlag(): boolean;

  /**
   * Configures the current {@link Option} to be a flag. It will be evaluated to {@code true} if it's found in
   *  the command line. If you need a flag that may receive a value, use, in this order:
   *  <code><pre>
   *    option.setFlag(true).setSingleValued(true)
   *  </pre></code>
   * @param flag whether or not the option is a flag.
   * @return the current {@link Option}
   * 
   */
  setFlag(flag: boolean): Option;

  /**
   * Sets whether or not this option is a "help" option
   * @param help {@code true} to set this option as a "Help" option
   * @return the current {@link Option}
   * 
   */
  isHelp(): boolean;

  /**
   * Sets whether or not this option is a "help" option
   * @param help {@code true} to set this option as a "Help" option
   * @return the current {@link Option}
   * 
   */
  setHelp(help: boolean): Option;

  /**
   * Sets whether or not this option should be hidden
   * @param hidden {@code true} to make this option hidden, {@link false} otherwise
   * @return the current {@link Option} instance
   * 
   */
  isHidden(): boolean;

  /**
   * Sets whether or not this option should be hidden
   * @param hidden {@code true} to make this option hidden, {@link false} otherwise
   * @return the current {@link Option} instance
   * 
   */
  setHidden(hidden: boolean): Option;

  /**
   * Sets the long name of this option.
   * @param longName the long name
   * @return the current {@link Option} instance
   * 
   */
  getLongName(): string;

  /**
   * Sets the long name of this option.
   * @param longName the long name
   * @return the current {@link Option} instance
   * 
   */
  setLongName(longName: string): Option;

  /**
   * Sets whether or not this option can receive several values.
   * @param multiValued whether or not this option is multi-valued.
   * @return the current {@link Option} instance
   * 
   */
  isMultiValued(): boolean;

  /**
   * Sets whether or not this option can receive several values.
   * @param multiValued whether or not this option is multi-valued.
   * @return the current {@link Option} instance
   * 
   */
  setMultiValued(multiValued: boolean): Option;

  /**
   *
   * @return the option name. It returns the long name if set, the short name otherwise. It cannot return {@code
   *  null} for valid option
   * @see #ensureValidity()
   * 
   */
  getName(): string;

  /**
   * Sets whether or not this option is mandatory.
   * @param required {@code true} to make this option mandatory, {@link false} otherwise
   * @return the current {@link Option} instance
   * 
   */
  isRequired(): boolean;

  /**
   * Sets whether or not this option is mandatory.
   * @param required {@code true} to make this option mandatory, {@link false} otherwise
   * @return the current {@link Option} instance
   * 
   */
  setRequired(required: boolean): Option;

  /**
   * Sets the short name of this option.
   * @param shortName the short name
   * @return the current {@link Option} instance
   * 
   */
  getShortName(): string;

  /**
   * Sets the short name of this option.
   * @param shortName the short name
   * @return the current {@link Option} instance
   * 
   */
  setShortName(shortName: string): Option;

  /**
   * Sets whether or not this option can receive a value.
   * @param singleValued whether or not this option is single-valued.
   * @return the current {@link Option} instance
   * 
   */
  isSingleValued(): boolean;

  /**
   * Sets whether or not this option can receive a value.
   * @param singleValued whether or not this option is single-valued.
   * @return the current {@link Option} instance
   * 
   */
  setSingleValued(singleValued: boolean): Option;
}

export class PemKeyCertOptions {

  constructor();
  constructor(obj: PemKeyCertOptions);
  /**
   * Set the path of the first certificate, replacing the previous certificates paths
   * @param certPath  the path to the certificate
   * @return a reference to this, so the API can be used fluently
   * 
   */
  certPath(): string;

  /**
   * Set the path of the first certificate, replacing the previous certificates paths
   * @param certPath  the path to the certificate
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCertPath(certPath: string): PemKeyCertOptions;

  /**
   * Set all the paths to the certificates files
   * @param certPaths  the paths to the certificates files
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getCertPaths(): string;

  /**
   * Set all the paths to the certificates files
   * @param certPaths  the paths to the certificates files
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCertPaths(certPaths: string): PemKeyCertOptions;

  /**
   * Set the first certificate as a buffer, replacing the previous certificates buffers
   * @param certValue  the first certificate as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  certValue(): Buffer;

  /**
   * Set the first certificate as a buffer, replacing the previous certificates buffers
   * @param certValue  the first certificate as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCertValue(certValue: Buffer): PemKeyCertOptions;

  /**
   * Set all the certificates as a list of buffer
   * @param certValues  the certificates as a list of buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getCertValues(): Buffer;

  /**
   * Set all the certificates as a list of buffer
   * @param certValues  the certificates as a list of buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCertValues(certValues: Buffer): PemKeyCertOptions;

  /**
   * Set the path of the first key file, replacing the keys paths
   * @param keyPath  the path to the first key file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyPath(): string;

  /**
   * Set the path of the first key file, replacing the keys paths
   * @param keyPath  the path to the first key file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyPath(keyPath: string): PemKeyCertOptions;

  /**
   * Set all the paths to the keys files
   * @param keyPaths  the paths to the keys files
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyPaths(): string;

  /**
   * Set all the paths to the keys files
   * @param keyPaths  the paths to the keys files
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyPaths(keyPaths: string): PemKeyCertOptions;

  /**
   * Set the first key a a buffer, replacing the previous keys buffers
   * @param keyValue  key as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyValue(): Buffer;

  /**
   * Set the first key a a buffer, replacing the previous keys buffers
   * @param keyValue  key as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyValue(keyValue: Buffer): PemKeyCertOptions;

  /**
   * Set all the keys as a list of buffer
   * @param keyValues  the keys as a list of buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyValues(): Buffer;

  /**
   * Set all the keys as a list of buffer
   * @param keyValues  the keys as a list of buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyValues(keyValues: Buffer): PemKeyCertOptions;
}

export class PemTrustOptions {

  constructor();
  constructor(obj: PemTrustOptions);
  /**
   * Add a certificate path
   * @param certPath  the path to add
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCertPaths(): string;

  /**
   * Add a certificate path
   * @param certPath  the path to add
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCertPath(certPaths: string): PemTrustOptions;

  /**
   * Add a certificate value
   * @param certValue  the value to add
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCertValues(): Buffer;

  /**
   * Add a certificate value
   * @param certValue  the value to add
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCertValue(certValues: Buffer): PemTrustOptions;
}

export class PfxOptions {

  constructor();
  constructor(obj: PfxOptions);
  /**
   * Set the password
   * @param password  the password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPassword(): string;

  /**
   * Set the password
   * @param password  the password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPassword(password: string): PfxOptions;

  /**
   * Set the path
   * @param path  the path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPath(): string;

  /**
   * Set the path
   * @param path  the path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPath(path: string): PfxOptions;

  /**
   * Set the store as a buffer
   * @param value  the store as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getValue(): Buffer;

  /**
   * Set the store as a buffer
   * @param value  the store as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setValue(value: Buffer): PfxOptions;
}

import { ProxyType } from './enums';

export class ProxyOptions {

  constructor();
  constructor(obj: ProxyOptions);
  /**
   * Set proxy host.
   * @param host the proxy host to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHost(): string;

  /**
   * Set proxy host.
   * @param host the proxy host to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHost(host: string): ProxyOptions;

  /**
   * Set proxy password.
   * @param password the proxy password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPassword(): string;

  /**
   * Set proxy password.
   * @param password the proxy password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPassword(password: string): ProxyOptions;

  /**
   * Set proxy port.
   * @param port the proxy port to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPort(): number;

  /**
   * Set proxy port.
   * @param port the proxy port to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPort(port: number): ProxyOptions;

  /**
   * Set proxy type.
   * 
   *  <p>ProxyType can be HTTP, SOCKS4 and SOCKS5
   * @param type the proxy type to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getType(): ProxyType;

  /**
   * Set proxy type.
   * 
   *  <p>ProxyType can be HTTP, SOCKS4 and SOCKS5
   * @param type the proxy type to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setType(type: ProxyType): ProxyOptions;

  /**
   * Set proxy username.
   * @param username the proxy username
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getUsername(): string;

  /**
   * Set proxy username.
   * @param username the proxy username
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setUsername(username: string): ProxyOptions;
}

export class RequestOptions {

  constructor();
  constructor(obj: RequestOptions);
  /**
   * Add a request header.
   * @param key  the header key
   * @param value  the header value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headers(): string;

  /**
   * Add a request header.
   * @param key  the header key
   * @param value  the header value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addHeader(headers: string): RequestOptions;

  /**
   * Set the host name to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHost(): string;

  /**
   * Set the host name to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHost(host: string): RequestOptions;

  /**
   * Set the port to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPort(): number;

  /**
   * Set the port to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPort(port: number): RequestOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): RequestOptions;

  /**
   * Set the request relative URI
   * @param uri  the relative uri
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getURI(): string;

  /**
   * Set the request relative URI
   * @param uri  the relative uri
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setURI(uri: string): RequestOptions;
}

export class StreamPriority {

  constructor();
  constructor(obj: StreamPriority);
  /**
   * Set the priority dependency value.
   * @param dependency the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getDependency(): number;

  /**
   * Set the priority dependency value.
   * @param dependency the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDependency(dependency: number): StreamPriority;

  /**
   * Set the priority exclusive value.
   * @param exclusive the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isExclusive(): boolean;

  /**
   * Set the priority exclusive value.
   * @param exclusive the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setExclusive(exclusive: boolean): StreamPriority;

  /**
   * Set the priority weight.
   * @param weight the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWeight(): number;

  /**
   * Set the priority weight.
   * @param weight the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWeight(weight: number): StreamPriority;
}

export abstract class TCPSSLOptions {

  constructor();
  constructor(obj: TCPSSLOptions);
  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlPath(crlPaths: string): TCPSSLOptions;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  addCrlValue(crlValues: Buffer): TCPSSLOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledCipherSuite(enabledCipherSuites: string): TCPSSLOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): TCPSSLOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): TCPSSLOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * 
   *  If you want change default time unit, use {@link #setIdleTimeoutUnit(TimeUnit)}
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeout(idleTimeout: number): TCPSSLOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   * @param idleTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): TCPSSLOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): TCPSSLOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): TCPSSLOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setLogActivity(logActivity: boolean): TCPSSLOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): TCPSSLOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): TCPSSLOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): TCPSSLOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): TCPSSLOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): TCPSSLOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReceiveBufferSize(receiveBufferSize: number): TCPSSLOptions;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReuseAddress(reuseAddress: boolean): TCPSSLOptions;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReusePort(reusePort: boolean): TCPSSLOptions;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendBufferSize(sendBufferSize: number): TCPSSLOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSoLinger(soLinger: number): TCPSSLOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): TCPSSLOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   * @param sslHandshakeTimeout the SSL handshake timeout to set, in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): TCPSSLOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   * @param sslHandshakeTimeoutUnit specify time unit.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): TCPSSLOptions;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  isTcpCork(): boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  setTcpCork(tcpCork: boolean): TCPSSLOptions;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  setTcpFastOpen(tcpFastOpen: boolean): TCPSSLOptions;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): TCPSSLOptions;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTcpNoDelay(tcpNoDelay: boolean): TCPSSLOptions;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  setTcpQuickAck(tcpQuickAck: boolean): TCPSSLOptions;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrafficClass(trafficClass: number): TCPSSLOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): TCPSSLOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  setUseAlpn(useAlpn: boolean): TCPSSLOptions;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  isUsePooledBuffers(): boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * @deprecated this has no effect, just don't use it
   * 
   */
  setUsePooledBuffers(usePooledBuffers: boolean): TCPSSLOptions;
}

export class VertxOptions {

  constructor();
  constructor(obj: VertxOptions);
  /**
   * Sets the address resolver configuration to configure resolving DNS servers, cache TTL, etc...
   * @param addressResolverOptions the address resolver options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getAddressResolverOptions(): AddressResolverOptions;

  /**
   * Sets the address resolver configuration to configure resolving DNS servers, cache TTL, etc...
   * @param addressResolverOptions the address resolver options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAddressResolverOptions(addressResolverOptions: AddressResolverOptions): VertxOptions;

  /**
   * Sets the value of blocked thread check period, in {@link VertxOptions#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit}.
   *  <p>
   *  The default value of {@link VertxOptions#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit} is {@link TimeUnit#MILLISECONDS}
   * @param blockedThreadCheckInterval the value of blocked thread check period, in {@link VertxOptions#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getBlockedThreadCheckInterval(): number;

  /**
   * Sets the value of blocked thread check period, in {@link VertxOptions#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit}.
   *  <p>
   *  The default value of {@link VertxOptions#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit} is {@link TimeUnit#MILLISECONDS}
   * @param blockedThreadCheckInterval the value of blocked thread check period, in {@link VertxOptions#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setBlockedThreadCheckInterval(blockedThreadCheckInterval: number): VertxOptions;

  /**
   * Set the time unit of {@code blockedThreadCheckInterval}.
   * @param blockedThreadCheckIntervalUnit the time unit of {@code warningExceptionTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getBlockedThreadCheckIntervalUnit(): any;

  /**
   * Set the time unit of {@code blockedThreadCheckInterval}.
   * @param blockedThreadCheckIntervalUnit the time unit of {@code warningExceptionTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setBlockedThreadCheckIntervalUnit(blockedThreadCheckIntervalUnit: any): VertxOptions;

  /**
   * Set the hostname to be used for clustering.
   * @param clusterHost the host name to use
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setHost(String)} instead
   * 
   */
  getClusterHost(): string;

  /**
   * Set the hostname to be used for clustering.
   * @param clusterHost the host name to use
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setHost(String)} instead
   * 
   */
  setClusterHost(clusterHost: string): VertxOptions;

  /**
   * Set the value of cluster ping interval, in ms.
   * @param clusterPingInterval The value of cluster ping interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPingInterval(long)} instead
   * 
   */
  getClusterPingInterval(): number;

  /**
   * Set the value of cluster ping interval, in ms.
   * @param clusterPingInterval The value of cluster ping interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPingInterval(long)} instead
   * 
   */
  setClusterPingInterval(clusterPingInterval: number): VertxOptions;

  /**
   * Set the value of cluster ping reply interval, in ms.
   * @param clusterPingReplyInterval The value of cluster ping reply interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPingReplyInterval(long)} instead
   * 
   */
  getClusterPingReplyInterval(): number;

  /**
   * Set the value of cluster ping reply interval, in ms.
   * @param clusterPingReplyInterval The value of cluster ping reply interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPingReplyInterval(long)} instead
   * 
   */
  setClusterPingReplyInterval(clusterPingReplyInterval: number): VertxOptions;

  /**
   * Set the port to be used for clustering.
   * @param clusterPort the port
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setPort(int)} instead
   * 
   */
  getClusterPort(): number;

  /**
   * Set the port to be used for clustering.
   * @param clusterPort the port
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setPort(int)} instead
   * 
   */
  setClusterPort(clusterPort: number): VertxOptions;

  /**
   * Set the public facing hostname to be used for clustering.
   *  Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is not the same
   *  address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of proxying.
   *  If this is the case you can specify a public hostname which is different from the hostname the server listens at.
   *  The default value is null which means use the same as the cluster hostname.
   * @param clusterPublicHost the public host name to use
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPublicHost(String)} instead
   * 
   */
  getClusterPublicHost(): string;

  /**
   * Set the public facing hostname to be used for clustering.
   *  Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is not the same
   *  address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of proxying.
   *  If this is the case you can specify a public hostname which is different from the hostname the server listens at.
   *  The default value is null which means use the same as the cluster hostname.
   * @param clusterPublicHost the public host name to use
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPublicHost(String)} instead
   * 
   */
  setClusterPublicHost(clusterPublicHost: string): VertxOptions;

  /**
   * See {@link #setClusterPublicHost(String)} for an explanation.
   * @param clusterPublicPort the public port to use
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPublicPort(int)} instead
   * 
   */
  getClusterPublicPort(): number;

  /**
   * See {@link #setClusterPublicHost(String)} for an explanation.
   * @param clusterPublicPort the public port to use
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClusterPublicPort(int)} instead
   * 
   */
  setClusterPublicPort(clusterPublicPort: number): VertxOptions;

  /**
   * Set whether or not the Vert.x instance will be clustered.
   * @param clustered if true, the Vert.x instance will be clustered, otherwise not
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClustered(boolean)} instead
   * 
   */
  isClustered(): boolean;

  /**
   * Set whether or not the Vert.x instance will be clustered.
   * @param clustered if true, the Vert.x instance will be clustered, otherwise not
   * @return a reference to this, so the API can be used fluently
   * @deprecated as of 3.7, use {@link #getEventBusOptions()} and then {@link EventBusOptions#setClustered(boolean)} instead
   * 
   */
  setClustered(clustered: boolean): VertxOptions;

  /**
   * Sets the event bus configuration to configure the host, port, ssl...
   * @param options the event bus options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEventBusOptions(): EventBusOptions;

  /**
   * Sets the event bus configuration to configure the host, port, ssl...
   * @param options the event bus options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEventBusOptions(eventBusOptions: EventBusOptions): VertxOptions;

  /**
   * Set the number of event loop threads to be used by the Vert.x instance.
   * @param eventLoopPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getEventLoopPoolSize(): number;

  /**
   * Set the number of event loop threads to be used by the Vert.x instance.
   * @param eventLoopPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEventLoopPoolSize(eventLoopPoolSize: number): VertxOptions;

  /**
   * Set whether the Vert.x file resolver uses caching for classpath resources.
   * @param fileResolverCachingEnabled true when the file resolver caches resources
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link FileSystemOptions#setFileCachingEnabled(boolean) getFileSystemOptions().setFileCachingEnabled(val)} instead
   * 
   */
  isFileResolverCachingEnabled(): boolean;

  /**
   * Set whether the Vert.x file resolver uses caching for classpath resources.
   * @param fileResolverCachingEnabled true when the file resolver caches resources
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link FileSystemOptions#setFileCachingEnabled(boolean) getFileSystemOptions().setFileCachingEnabled(val)} instead
   * 
   */
  setFileResolverCachingEnabled(fileResolverCachingEnabled: boolean): VertxOptions;

  /**
   * Set the file system options
   * @param fileSystemOptions the options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getFileSystemOptions(): FileSystemOptions;

  /**
   * Set the file system options
   * @param fileSystemOptions the options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setFileSystemOptions(fileSystemOptions: FileSystemOptions): VertxOptions;

  /**
   * Set whether HA will be enabled on the Vert.x instance.
   * @param haEnabled true if enabled, false if not.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isHAEnabled(): boolean;

  /**
   * Set whether HA will be enabled on the Vert.x instance.
   * @param haEnabled true if enabled, false if not.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHAEnabled(haEnabled: boolean): VertxOptions;

  /**
   * Set the HA group to be used when HA is enabled.
   * @param haGroup the HA group to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHAGroup(): string;

  /**
   * Set the HA group to be used when HA is enabled.
   * @param haGroup the HA group to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHAGroup(haGroup: string): VertxOptions;

  /**
   * Set the value of internal blocking pool size
   * @param internalBlockingPoolSize the maximumn number of threads in the internal blocking pool
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getInternalBlockingPoolSize(): number;

  /**
   * Set the value of internal blocking pool size
   * @param internalBlockingPoolSize the maximumn number of threads in the internal blocking pool
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setInternalBlockingPoolSize(internalBlockingPoolSize: number): VertxOptions;

  /**
   * Sets the value of max event loop execute time, in {@link VertxOptions#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit}.
   *  <p>
   *  The default value of {@link VertxOptions#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit}is {@link TimeUnit#NANOSECONDS}
   * @param maxEventLoopExecuteTime the value of max event loop execute time, in {@link VertxOptions#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxEventLoopExecuteTime(): number;

  /**
   * Sets the value of max event loop execute time, in {@link VertxOptions#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit}.
   *  <p>
   *  The default value of {@link VertxOptions#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit}is {@link TimeUnit#NANOSECONDS}
   * @param maxEventLoopExecuteTime the value of max event loop execute time, in {@link VertxOptions#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxEventLoopExecuteTime(maxEventLoopExecuteTime: number): VertxOptions;

  /**
   * Set the time unit of {@code maxEventLoopExecuteTime}.
   * @param maxEventLoopExecuteTimeUnit the time unit of {@code maxEventLoopExecuteTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxEventLoopExecuteTimeUnit(): any;

  /**
   * Set the time unit of {@code maxEventLoopExecuteTime}.
   * @param maxEventLoopExecuteTimeUnit the time unit of {@code maxEventLoopExecuteTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxEventLoopExecuteTimeUnit(maxEventLoopExecuteTimeUnit: any): VertxOptions;

  /**
   * Sets the value of max worker execute time, in {@link VertxOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   *  <p>
   *  The default value of {@link VertxOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit} is {@link TimeUnit#NANOSECONDS}
   * @param maxWorkerExecuteTime the value of max worker execute time, in {@link VertxOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWorkerExecuteTime(): number;

  /**
   * Sets the value of max worker execute time, in {@link VertxOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   *  <p>
   *  The default value of {@link VertxOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit} is {@link TimeUnit#NANOSECONDS}
   * @param maxWorkerExecuteTime the value of max worker execute time, in {@link VertxOptions#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWorkerExecuteTime(maxWorkerExecuteTime: number): VertxOptions;

  /**
   * Set the time unit of {@code maxWorkerExecuteTime}.
   * @param maxWorkerExecuteTimeUnit the time unit of {@code maxWorkerExecuteTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMaxWorkerExecuteTimeUnit(): any;

  /**
   * Set the time unit of {@code maxWorkerExecuteTime}.
   * @param maxWorkerExecuteTimeUnit the time unit of {@code maxWorkerExecuteTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxWorkerExecuteTimeUnit(maxWorkerExecuteTimeUnit: any): VertxOptions;

  /**
   * Set the metrics options
   * @param metrics the options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getMetricsOptions(): MetricsOptions;

  /**
   * Set the metrics options
   * @param metrics the options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMetricsOptions(metricsOptions: MetricsOptions): VertxOptions;

  /**
   * Set wether to prefer the native transport to the JDK transport.
   * @param preferNativeTransport {@code true} to prefer the native transport
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPreferNativeTransport(): boolean;

  /**
   * Set wether to prefer the native transport to the JDK transport.
   * @param preferNativeTransport {@code true} to prefer the native transport
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPreferNativeTransport(preferNativeTransport: boolean): VertxOptions;

  /**
   * Set the quorum size to be used when HA is enabled.
   * @param quorumSize the quorum size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getQuorumSize(): number;

  /**
   * Set the quorum size to be used when HA is enabled.
   * @param quorumSize the quorum size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setQuorumSize(quorumSize: number): VertxOptions;

  /**
   * Set the threshold value above this, the blocked warning contains a stack trace. in {@link VertxOptions#setWarningExceptionTimeUnit warningExceptionTimeUnit}.
   *  The default value of {@link VertxOptions#setWarningExceptionTimeUnit warningExceptionTimeUnit} is {@link TimeUnit#NANOSECONDS}
   * @param warningExceptionTime
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWarningExceptionTime(): number;

  /**
   * Set the threshold value above this, the blocked warning contains a stack trace. in {@link VertxOptions#setWarningExceptionTimeUnit warningExceptionTimeUnit}.
   *  The default value of {@link VertxOptions#setWarningExceptionTimeUnit warningExceptionTimeUnit} is {@link TimeUnit#NANOSECONDS}
   * @param warningExceptionTime
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWarningExceptionTime(warningExceptionTime: number): VertxOptions;

  /**
   * Set the time unit of {@code warningExceptionTime}.
   * @param warningExceptionTimeUnit the time unit of {@code warningExceptionTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWarningExceptionTimeUnit(): any;

  /**
   * Set the time unit of {@code warningExceptionTime}.
   * @param warningExceptionTimeUnit the time unit of {@code warningExceptionTime}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWarningExceptionTimeUnit(warningExceptionTimeUnit: any): VertxOptions;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   * @param workerPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getWorkerPoolSize(): number;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   * @param workerPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWorkerPoolSize(workerPoolSize: number): VertxOptions;
}

import { WebsocketVersion } from './enums';

export class WebSocketConnectOptions {

  constructor();
  constructor(obj: WebSocketConnectOptions);
  /**
   * Add a request header.
   * @param key  the header key
   * @param value  the header value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headers(): string;

  /**
   * Add a request header.
   * @param key  the header key
   * @param value  the header value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addHeader(headers: string): WebSocketConnectOptions;

  /**
   * Set the host name to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getHost(): string;

  /**
   * Set the host name to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHost(host: string): WebSocketConnectOptions;

  /**
   * Set the port to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getPort(): number;

  /**
   * Set the port to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPort(port: number): WebSocketConnectOptions;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSsl(ssl: boolean): WebSocketConnectOptions;

  /**
   * Set the WebSocket sub protocols to use.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getSubProtocols(): string;

  /**
   * Set the WebSocket sub protocols to use.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSubProtocols(subProtocols: string): WebSocketConnectOptions;

  /**
   * Set the WebSocket sub protocols to use.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addSubProtocol(subProtocols: string): WebSocketConnectOptions;

  /**
   * Set the request relative URI
   * @param uri  the relative uri
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getURI(): string;

  /**
   * Set the request relative URI
   * @param uri  the relative uri
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setURI(uri: string): WebSocketConnectOptions;

  /**
   * Set the WebSocket version.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getVersion(): WebsocketVersion;

  /**
   * Set the WebSocket version.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setVersion(version: WebsocketVersion): WebSocketConnectOptions;
}
