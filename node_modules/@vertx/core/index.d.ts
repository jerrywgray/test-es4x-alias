/*
 * Copyright 2019 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

export interface Handler<T> {
  handle(arg0: T) : void;
}

export interface AsyncResult<T> {
  succeeded() : boolean;
  failed() : boolean;
  cause() : Error | null;
  result() : T | null;
}

export abstract class AsyncFile implements ReadStream<Buffer>, WriteStream<Buffer> {
  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: Buffer) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : AsyncFile;

  pause() : AsyncFile;

  resume() : AsyncFile;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : AsyncFile;

  write(data: Buffer) : AsyncFile;

  /**
   * Same as {@link #write(Buffer)} but with an {@code handler} called when the operation completes
   * 
   */
  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : AsyncFile;

  setWriteQueueMaxSize(maxSize: number) : AsyncFile;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : AsyncFile;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : AsyncFile;

  fetch(amount: number) : AsyncFile;

  /**
   * Close the file, see {@link #close()}.
   * 
   */
  end() : void;

  /**
   * Close the file, see {@link #close(Handler)}.
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the file. The actual close happens asynchronously.
   * 
   */
  close() : void;

  /**
   * Close the file. The actual close happens asynchronously.
   *  The handler will be called when the close is complete, or an error occurs.
   * @param handler  the handler
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Write a {@link io.vertx.core.buffer.Buffer} to the file at position {@code position} in the file, asynchronously.
   *  <p>
   *  If {@code position} lies outside of the current size
   *  of the file, the file will be enlarged to encompass it.
   *  <p>
   *  When multiple writes are invoked on the same file
   *  there are no guarantees as to order in which those writes actually occur
   *  <p>
   *  The handler will be called when the write is complete, or if an error occurs.
   * @param buffer  the buffer to write
   * @param position  the position in the file to write it at
   * @param handler  the handler to call when the write is complete
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(buffer: Buffer, position: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : AsyncFile;

  /**
   * Reads {@code length} bytes of data from the file at position {@code position} in the file, asynchronously.
   *  <p>
   *  The read data will be written into the specified {@code Buffer buffer} at position {@code offset}.
   *  <p>
   *  If data is read past the end of the file then zero bytes will be read.<p>
   *  When multiple reads are invoked on the same file there are no guarantees as to order in which those reads actually occur.
   *  <p>
   *  The handler will be called when the close is complete, or if an error occurs.
   * @param buffer  the buffer to read into
   * @param offset  the offset into the buffer where the data will be read
   * @param position  the position in the file where to start reading
   * @param length  the number of bytes to read
   * @param handler  the handler to call when the write is complete
   * @return a reference to this, so the API can be used fluently
   * 
   */
  read(buffer: Buffer, offset: number, position: number, length: number, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : AsyncFile;

  /**
   * Flush any writes made to this file to underlying persistent storage.
   *  <p>
   *  If the file was opened with {@code flush} set to {@code true} then calling this method will have no effect.
   *  <p>
   *  The actual flush will happen asynchronously.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  flush() : AsyncFile;

  /**
   * Same as {@link #flush} but the handler will be called when the flush is complete or if an error occurs
   * 
   */
  flush(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : AsyncFile;

  /**
   * Sets the position from which data will be read from when using the file as a {@link io.vertx.core.streams.ReadStream}.
   * @param readPos  the position in the file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReadPos(readPos: number) : AsyncFile;

  /**
   * Sets the position from which data will be written when using the file as a {@link io.vertx.core.streams.WriteStream}.
   * @param writePos  the position in the file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWritePos(writePos: number) : AsyncFile;

  /**
   *
   * @return the current write position the file is at
   * 
   */
  getWritePos() : number;

  /**
   * Sets the buffer size that will be used to read the data from the file. Changing this value will impact how much
   *  the data will be read at a time from the file system.
   * @param readBufferSize the buffer size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReadBufferSize(readBufferSize: number) : AsyncFile;
}

export abstract class AsyncMap<K, V> {
  /**
   * Get a value from the map, asynchronously.
   * @param k  the key
   * @param resultHandler - this will be called some time later with the async result.
   * 
   */
  get(k: K, resultHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Put a value in the map, asynchronously.
   * @param k  the key
   * @param v  the value
   * @param completionHandler - this will be called some time later to signify the value has been put
   * 
   */
  put(k: K, v: V, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Like {@link #put} but specifying a time to live for the entry. Entry will expire and get evicted after the
   *  ttl.
   * @param k  the key
   * @param v  the value
   * @param ttl  The time to live (in ms) for the entry
   * @param completionHandler  the handler
   * 
   */
  put(k: K, v: V, ttl: number, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Put the entry only if there is no entry with the key already present. If key already present then the existing
   *  value will be returned to the handler, otherwise null.
   * @param k  the key
   * @param v  the value
   * @param completionHandler  the handler
   * 
   */
  putIfAbsent(k: K, v: V, completionHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Link {@link #putIfAbsent} but specifying a time to live for the entry. Entry will expire and get evicted
   *  after the ttl.
   * @param k  the key
   * @param v  the value
   * @param ttl  The time to live (in ms) for the entry
   * @param completionHandler  the handler
   * 
   */
  putIfAbsent(k: K, v: V, ttl: number, completionHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Remove a value from the map, asynchronously.
   * @param k  the key
   * @param resultHandler - this will be called some time later to signify the value has been removed
   * 
   */
  remove(k: K, resultHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Remove a value from the map, only if entry already exists with same value.
   * @param k  the key
   * @param v  the value
   * @param resultHandler - this will be called some time later to signify the value has been removed
   * 
   */
  removeIfPresent(k: K, v: V, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : void;

  /**
   * Replace the entry only if it is currently mapped to some value
   * @param k  the key
   * @param v  the new value
   * @param resultHandler  the result handler will be passed the previous value
   * 
   */
  replace(k: K, v: V, resultHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Replace the entry only if it is currently mapped to a specific value
   * @param k  the key
   * @param oldValue  the existing value
   * @param newValue  the new value
   * @param resultHandler the result handler
   * 
   */
  replaceIfPresent(k: K, oldValue: V, newValue: V, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : void;

  /**
   * Clear all entries in the map
   * @param resultHandler  called on completion
   * 
   */
  clear(resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Provide the number of entries in the map
   * @param resultHandler  handler which will receive the number of entries
   * 
   */
  size(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;
}

export abstract class Buffer {
  /**
   * Create a new, empty buffer.
   * @return the buffer
   * 
   */
  static buffer() : Buffer;

  /**
   * Create a new buffer given the initial size hint.
   *  <p>
   *  If you know the buffer will require a certain size, providing the hint can prevent unnecessary re-allocations
   *  as the buffer is written to and resized.
   * @param initialSizeHint the hint, in bytes
   * @return the buffer
   * 
   */
  static buffer(initialSizeHint: number) : Buffer;

  /**
   * Create a new buffer from a string. The string will be UTF-8 encoded into the buffer.
   * @param string the string
   * @return the buffer
   * 
   */
  static buffer(string: string) : Buffer;

  /**
   * Create a new buffer from a string and using the specified encoding.
   *  The string will be encoded into the buffer using the specified encoding.
   * @param string the string
   * @return the buffer
   * 
   */
  static buffer(string: string, enc: string) : Buffer;

  /**
   * Returns a {@code String} representation of the Buffer with the {@code UTF-8 }encoding
   * 
   */
  toString() : string;

  /**
   * Returns a {@code String} representation of the Buffer with the encoding specified by {@code enc}
   * 
   */
  toString(enc: string) : string;

  /**
   * Returns a Json object representation of the Buffer.
   * 
   */
  toJsonObject() : { [key: string]: any };

  /**
   * Returns a Json array representation of the Buffer.
   * 
   */
  toJsonArray() : any[];

  /**
   * Returns a Json representation of the Buffer.
   * @return a JSON element which can be a {@link JsonArray}, {@link JsonObject}, {@link String}, ...etc if the buffer contains an array, object, string, ...etc
   * 
   */
  toJson() : any;

  /**
   * Returns the {@code byte} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 1} is greater than the length of the Buffer.
   * 
   */
  getByte(pos: number) : number;

  /**
   * Returns the unsigned {@code byte} at position {@code pos} in the Buffer, as a {@code short}.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 1} is greater than the length of the Buffer.
   * 
   */
  getUnsignedByte(pos: number) : number;

  /**
   * Returns the {@code int} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getInt(pos: number) : number;

  /**
   * Gets a 32-bit integer at the specified absolute {@code index} in this buffer with Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 4} is greater than {@code this.capacity}
   * 
   */
  getIntLE(pos: number) : number;

  /**
   * Returns the unsigned {@code int} at position {@code pos} in the Buffer, as a {@code long}.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getUnsignedInt(pos: number) : number;

  /**
   * Returns the unsigned {@code int} at position {@code pos} in the Buffer, as a {@code long} in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getUnsignedIntLE(pos: number) : number;

  /**
   * Returns the {@code long} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 8} is greater than the length of the Buffer.
   * 
   */
  getLong(pos: number) : number;

  /**
   * Gets a 64-bit long integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 8} is greater than the length of the Buffer.
   * 
   */
  getLongLE(pos: number) : number;

  /**
   * Returns the {@code double} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 8} is greater than the length of the Buffer.
   * 
   */
  getDouble(pos: number) : number;

  /**
   * Returns the {@code float} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getFloat(pos: number) : number;

  /**
   * Returns the {@code short} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 2} is greater than the length of the Buffer.
   * 
   */
  getShort(pos: number) : number;

  /**
   * Gets a 16-bit short integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 2} is greater than the length of the Buffer.
   * 
   */
  getShortLE(pos: number) : number;

  /**
   * Returns the unsigned {@code short} at position {@code pos} in the Buffer, as an {@code int}.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 2} is greater than the length of the Buffer.
   * 
   */
  getUnsignedShort(pos: number) : number;

  /**
   * Gets an unsigned 16-bit short integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 2} is greater than the length of the Buffer.
   * 
   */
  getUnsignedShortLE(pos: number) : number;

  /**
   * Gets a 24-bit medium integer at the specified absolute {@code index} in this buffer.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getMedium(pos: number) : number;

  /**
   * Gets a 24-bit medium integer at the specified absolute {@code index} in this buffer in the Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getMediumLE(pos: number) : number;

  /**
   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in this buffer.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getUnsignedMedium(pos: number) : number;

  /**
   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getUnsignedMediumLE(pos: number) : number;

  /**
   * Returns a copy of a sub-sequence the Buffer as a {@link io.vertx.core.buffer.Buffer} starting at position {@code start}
   *  and ending at position {@code end - 1}
   * 
   */
  getBuffer(start: number, end: number) : Buffer;

  /**
   * Returns a copy of a sub-sequence the Buffer as a {@code String} starting at position {@code start}
   *  and ending at position {@code end - 1} interpreted as a String in the specified encoding
   * 
   */
  getString(start: number, end: number, enc: string) : string;

  /**
   * Returns a copy of a sub-sequence the Buffer as a {@code String} starting at position {@code start}
   *  and ending at position {@code end - 1} interpreted as a String in UTF-8 encoding
   * 
   */
  getString(start: number, end: number) : string;

  /**
   * Appends the specified {@code Buffer} to the end of this Buffer. The buffer will expand as necessary to accommodate
   *  any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendBuffer(buff: Buffer) : Buffer;

  /**
   * Appends the specified {@code Buffer} starting at the {@code offset} using {@code len} to the end of this Buffer. The buffer will expand as necessary to accommodate
   *  any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendBuffer(buff: Buffer, offset: number, len: number) : Buffer;

  /**
   * Appends the specified {@code byte} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendByte(b: number) : Buffer;

  /**
   * Appends the specified unsigned {@code byte} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedByte(b: number) : Buffer;

  /**
   * Appends the specified {@code int} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendInt(i: number) : Buffer;

  /**
   * Appends the specified {@code int} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendIntLE(i: number) : Buffer;

  /**
   * Appends the specified unsigned {@code int} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedInt(i: number) : Buffer;

  /**
   * Appends the specified unsigned {@code int} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedIntLE(i: number) : Buffer;

  /**
   * Appends the specified 24bit {@code int} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendMedium(i: number) : Buffer;

  /**
   * Appends the specified 24bit {@code int} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendMediumLE(i: number) : Buffer;

  /**
   * Appends the specified {@code long} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendLong(l: number) : Buffer;

  /**
   * Appends the specified {@code long} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendLongLE(l: number) : Buffer;

  /**
   * Appends the specified {@code short} to the end of the Buffer.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendShort(s: number) : Buffer;

  /**
   * Appends the specified {@code short} to the end of the Buffer in the Little Endian Byte Order.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendShortLE(s: number) : Buffer;

  /**
   * Appends the specified unsigned {@code short} to the end of the Buffer.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedShort(s: number) : Buffer;

  /**
   * Appends the specified unsigned {@code short} to the end of the Buffer in the Little Endian Byte Order.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedShortLE(s: number) : Buffer;

  /**
   * Appends the specified {@code float} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendFloat(f: number) : Buffer;

  /**
   * Appends the specified {@code double} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendDouble(d: number) : Buffer;

  /**
   * Appends the specified {@code String} to the end of the Buffer with the encoding as specified by {@code enc}.<p>
   *  The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.<p>
   * 
   */
  appendString(str: string, enc: string) : Buffer;

  /**
   * Appends the specified {@code String str} to the end of the Buffer with UTF-8 encoding.<p>
   *  The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together<p>
   * 
   */
  appendString(str: string) : Buffer;

  /**
   * Sets the {@code byte} at position {@code pos} in the Buffer to the value {@code b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setByte(pos: number, b: number) : Buffer;

  /**
   * Sets the unsigned {@code byte} at position {@code pos} in the Buffer to the value {@code b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedByte(pos: number, b: number) : Buffer;

  /**
   * Sets the {@code int} at position {@code pos} in the Buffer to the value {@code i}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setInt(pos: number, i: number) : Buffer;

  /**
   * Sets the {@code int} at position {@code pos} in the Buffer to the value {@code i} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setIntLE(pos: number, i: number) : Buffer;

  /**
   * Sets the unsigned {@code int} at position {@code pos} in the Buffer to the value {@code i}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedInt(pos: number, i: number) : Buffer;

  /**
   * Sets the unsigned {@code int} at position {@code pos} in the Buffer to the value {@code i} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedIntLE(pos: number, i: number) : Buffer;

  /**
   * Sets the 24bit {@code int} at position {@code pos} in the Buffer to the value {@code i}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setMedium(pos: number, i: number) : Buffer;

  /**
   * Sets the 24bit {@code int} at position {@code pos} in the Buffer to the value {@code i}. in the Little Endian Byte Order<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setMediumLE(pos: number, i: number) : Buffer;

  /**
   * Sets the {@code long} at position {@code pos} in the Buffer to the value {@code l}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setLong(pos: number, l: number) : Buffer;

  /**
   * Sets the {@code long} at position {@code pos} in the Buffer to the value {@code l} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setLongLE(pos: number, l: number) : Buffer;

  /**
   * Sets the {@code double} at position {@code pos} in the Buffer to the value {@code d}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setDouble(pos: number, d: number) : Buffer;

  /**
   * Sets the {@code float} at position {@code pos} in the Buffer to the value {@code f}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setFloat(pos: number, f: number) : Buffer;

  /**
   * Sets the {@code short} at position {@code pos} in the Buffer to the value {@code s}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setShort(pos: number, s: number) : Buffer;

  /**
   * Sets the {@code short} at position {@code pos} in the Buffer to the value {@code s} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setShortLE(pos: number, s: number) : Buffer;

  /**
   * Sets the unsigned {@code short} at position {@code pos} in the Buffer to the value {@code s}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedShort(pos: number, s: number) : Buffer;

  /**
   * Sets the unsigned {@code short} at position {@code pos} in the Buffer to the value {@code s} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedShortLE(pos: number, s: number) : Buffer;

  /**
   * Sets the bytes at position {@code pos} in the Buffer to the bytes represented by the {@code Buffer b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBuffer(pos: number, b: Buffer) : Buffer;

  /**
   * Sets the bytes at position {@code pos} in the Buffer to the bytes represented by the {@code Buffer b} on the given {@code offset} and {@code len}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBuffer(pos: number, b: Buffer, offset: number, len: number) : Buffer;

  /**
   * Sets the bytes at position {@code pos} in the Buffer to the value of {@code str} encoded in UTF-8.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setString(pos: number, str: string) : Buffer;

  /**
   * Sets the bytes at position {@code pos} in the Buffer to the value of {@code str} encoded in encoding {@code enc}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setString(pos: number, str: string, enc: string) : Buffer;

  /**
   * Returns the length of the buffer, measured in bytes.
   *  All positions are indexed from zero.
   * 
   */
  length() : number;

  /**
   * Returns a copy of the entire Buffer.
   * 
   */
  copy() : Buffer;

  /**
   * Returns a slice of this buffer. Modifying the content
   *  of the returned buffer or this buffer affects each other's content
   *  while they maintain separate indexes and marks.
   * 
   */
  slice() : Buffer;

  /**
   * Returns a slice of this buffer. Modifying the content
   *  of the returned buffer or this buffer affects each other's content
   *  while they maintain separate indexes and marks.
   * 
   */
  slice(start: number, end: number) : Buffer;

  /**
   * Create a new buffer from a byte[]. The byte[] will be copied to form the buffer.
   * @param bytes the byte array
   * @return the buffer
   * 
   */
  static buffer(bytes: any /* byte[] */) : Buffer;

  /**
   * <p>
   *  Create a new buffer from a Netty {@code ByteBuf}.
   *  <i>Note that</i> the returned buffer is backed by given Netty ByteBuf,
   *  so changes in the returned buffer are reflected in given Netty ByteBuf, and vice-versa.
   *  </p>
   *  <p>
   *  For example, both buffers in the code below share their data:
   *  </p>
   *  <pre>
   *    Buffer src = Buffer.buffer();
   *    Buffer clone = Buffer.buffer(src.getByteBuf());
   *  </pre>
   * @param byteBuf the Netty ByteBuf
   * @return the buffer
   * 
   */
  static buffer(byteBuf: any /* io.netty.buffer.ByteBuf */) : Buffer;

  /**
   * Returns a {@code String} representation of the Buffer with the encoding specified by {@code enc}
   * 
   */
  toString(enc: any /* java.nio.charset.Charset */) : string;

  /**
   * Returns a copy of the entire Buffer as a {@code byte[]}
   * 
   */
  getBytes() : any /* byte[] */;

  /**
   * Returns a copy of a sub-sequence the Buffer as a {@code byte[]} starting at position {@code start}
   *  and ending at position {@code end - 1}
   * 
   */
  getBytes(start: number, end: number) : any /* byte[] */;

  /**
   * Transfers the content of the Buffer into a {@code byte[]}.
   * @param dst the destination byte array
   * @throws IndexOutOfBoundsException if the content of the Buffer cannot fit into the destination byte array
   * 
   */
  getBytes(dst: any /* byte[] */) : Buffer;

  /**
   * Transfers the content of the Buffer into a {@code byte[]} at the specific destination.
   * @param dst the destination byte array
   * @throws IndexOutOfBoundsException if the content of the Buffer cannot fit into the destination byte array
   * 
   */
  getBytes(dst: any /* byte[] */, dstIndex: number) : Buffer;

  /**
   * Transfers the content of the Buffer starting at position {@code start} and ending at position {@code end - 1}
   *  into a {@code byte[]}.
   * @param dst the destination byte array
   * @throws IndexOutOfBoundsException if the content of the Buffer cannot fit into the destination byte array
   * 
   */
  getBytes(start: number, end: number, dst: any /* byte[] */) : Buffer;

  /**
   * Transfers the content of the Buffer starting at position {@code start} and ending at position {@code end - 1}
   *  into a {@code byte[]} at the specific destination.
   * @param dst the destination byte array
   * @throws IndexOutOfBoundsException if the content of the Buffer cannot fit into the destination byte array
   * 
   */
  getBytes(start: number, end: number, dst: any /* byte[] */, dstIndex: number) : Buffer;

  /**
   * Appends the specified {@code byte[]} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendBytes(bytes: any /* byte[] */) : Buffer;

  /**
   * Appends the specified number of bytes from {@code byte[]} to the end of the Buffer, starting at the given offset.
   *  The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendBytes(bytes: any /* byte[] */, offset: number, len: number) : Buffer;

  /**
   * Sets the bytes at position {@code pos} in the Buffer to the bytes represented by the {@code ByteBuffer b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBytes(pos: number, b: any /* java.nio.ByteBuffer */) : Buffer;

  /**
   * Sets the bytes at position {@code pos} in the Buffer to the bytes represented by the {@code byte[] b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBytes(pos: number, b: any /* byte[] */) : Buffer;

  /**
   * Sets the given number of bytes at position {@code pos} in the Buffer to the bytes represented by the {@code byte[] b}.<p></p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBytes(pos: number, b: any /* byte[] */, offset: number, len: number) : Buffer;

  /**
   * Returns the Buffer as a Netty {@code ByteBuf}.<p>
   *  The returned buffer is a duplicate.<p>
   *  The returned {@code ByteBuf} might have its {@code readerIndex > 0}
   *  This method is meant for internal use only.<p>
   * 
   */
  getByteBuf() : any /* io.netty.buffer.ByteBuf */;
}

import { Option } from './options';
import { Argument } from './options';

export abstract class CLI {
  /**
   * Creates an instance of {@link CLI} using the default implementation.
   * @param name the name of the CLI (must not be {@code null})
   * @return the created instance of {@link CLI}
   * 
   */
  static create(name: string) : CLI;

  /**
   * Parses the user command line interface and create a new {@link CommandLine} containing extracting values.
   * @param arguments the arguments
   * @return the creates command line
   * 
   */
  parse(arguments: string[]) : CommandLine;

  /**
   * Parses the user command line interface and create a new {@link CommandLine} containing extracting values.
   * @param arguments the arguments
   * @param validate  enable / disable parsing validation
   * @return the creates command line
   * 
   */
  parse(arguments: string[], validate: boolean) : CommandLine;

  /**
   *
   * @return the CLI name.
   * 
   */
  getName() : string;

  /**
   * Sets the name of the CLI.
   * @param name the name
   * @return the current {@link CLI} instance
   * 
   */
  setName(name: string) : CLI;

  /**
   *
   * @return the CLI description.
   * 
   */
  getDescription() : string | null;

  setDescription(desc: string) : CLI;

  /**
   *
   * @return the CLI summary.
   * 
   */
  getSummary() : string | null;

  /**
   * Sets the summary of the CLI.
   * @param summary the summary
   * @return the current {@link CLI} instance
   * 
   */
  setSummary(summary: string) : CLI;

  /**
   * Checks whether or not the current {@link CLI} instance is hidden.
   * @return {@code true} if the current {@link CLI} is hidden, {@link false} otherwise
   * 
   */
  isHidden() : boolean;

  /**
   * Sets whether or not the current instance of {@link CLI} must be hidden. Hidden CLI are not listed when
   *  displaying usages / help messages. In other words, hidden commands are for power user.
   * @param hidden enables or disables the hidden aspect of the CI
   * @return the current {@link CLI} instance
   * 
   */
  setHidden(hidden: boolean) : CLI;

  /**
   * Gets the list of options.
   * @return the list of options, empty if none.
   * 
   */
  getOptions() : Option[];

  /**
   * Adds an option.
   * @param option the option, must not be {@code null}.
   * @return the current {@link CLI} instance
   * 
   */
  addOption(option: Option) : CLI;

  /**
   * Adds a set of options. Unlike {@link #setOptions(List)}}, this method does not remove the existing options.
   *  The given list is appended to the existing list.
   * @param options the options, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  addOptions(options: Option[]) : CLI;

  /**
   * Sets the list of arguments.
   * @param options the list of options, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  setOptions(options: Option[]) : CLI;

  /**
   * Gets the list of defined arguments.
   * @return the list of argument, empty if none.
   * 
   */
  getArguments() : Argument[];

  /**
   * Adds an argument.
   * @param arg the argument, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  addArgument(arg: Argument) : CLI;

  /**
   * Adds a set of arguments. Unlike {@link #setArguments(List)}, this method does not remove the existing arguments.
   *  The given list is appended to the existing list.
   * @param args the arguments, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  addArguments(args: Argument[]) : CLI;

  /**
   * Sets the list of arguments.
   * @param args the list of arguments, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  setArguments(args: Argument[]) : CLI;

  /**
   * Gets an {@link Option} based on its name (short name, long name or argument name).
   * @param name the name, must not be {@code null}
   * @return the {@link Option}, {@code null} if not found
   * 
   */
  getOption(name: string) : Option | null;

  /**
   * Gets an {@link Argument} based on its name (argument name).
   * @param name the name of the argument, must not be {@code null}
   * @return the {@link Argument}, {@code null} if not found.
   * 
   */
  getArgument(name: string) : Argument | null;

  /**
   * Gets an {@link Argument} based on its index.
   * @param index the index, must be positive or zero.
   * @return the {@link Argument}, {@code null} if not found.
   * 
   */
  getArgument(index: number) : Argument | null;

  /**
   * Removes an option identified by its name. This method does nothing if the option cannot be found.
   * @param name the option name
   * @return the current {@link CLI} instance
   * 
   */
  removeOption(name: string) : CLI;

  /**
   * Removes an argument identified by its index. This method does nothing if the argument cannot be found.
   * @param index the argument index
   * @return the current {@link CLI} instance
   * 
   */
  removeArgument(index: number) : CLI;
}

export abstract class CommandLine {
  /**
   * Creates a command line object from the {@link CLI}. This object is intended to be used by
   *  the parser to set the argument and option values.
   * @param cli the CLI definition
   * @return the command line object
   * 
   */
  static create(cli: CLI) : CommandLine;

  /**
   *
   * @return the model of this command line object.
   * 
   */
  cli() : CLI;

  /**
   *
   * @return the ordered list of arguments. Arguments are command line arguments not matching an option.
   * 
   */
  allArguments() : string[];

  /**
   * Gets the value of an option with the matching name (can be the long name, short name or arg name).
   * @param name the name
   * @param <T>  the expected type
   * @return the value, {@code null} if not set
   * 
   */
  getOptionValue<T>(name: string) : T | null;

  /**
   * Gets the value of an argument with the matching name (arg name).
   * @param name the name
   * @param <T>  the expected type
   * @return the value, {@code null} if not set
   * 
   */
  getArgumentValue<T>(name: string) : T | null;

  /**
   * Gets the value of an argument with the given index.
   * @param index the index
   * @param <T>   the expected type
   * @return the value, {@code null} if not set
   * 
   */
  getArgumentValue<T>(index: number) : T | null;

  /**
   * Gets the value of an option marked as a flag.
   *  <p/>
   *  Calling this method an a non-flag option throws an {@link IllegalStateException}.
   * @param name the option name
   * @return {@code true} if the flag has been set in the command line, {@code false} otherwise.
   * 
   */
  isFlagEnabled(name: string) : boolean;

  /**
   * Checks whether or not the given option has been assigned in the command line.
   * @param option the option
   * @return {@code true} if the option has received a value, {@link false} otherwise.
   * 
   */
  isOptionAssigned(option: Option) : boolean;

  /**
   * Gets the raw values of the given option. Raw values are simple "String", not converted to the option type.
   * @param option the option
   * @return the list of values, empty if none
   * @deprecated use {@link #getRawValuesForOption(Option)}
   * 
   */
  getRawValues(option: Option) : string[];

  /**
   * Gets the raw values of the given option. Raw values are simple "String", not converted to the option type.
   * @param option the option
   * @return the list of values, empty if none
   * 
   */
  getRawValuesForOption(option: Option) : string[];

  /**
   * Gets the raw values of the given argument. Raw values are simple "String", not converted to the argument type.
   * @param argument the argument
   * @return the list of values, empty if none
   * 
   */
  getRawValuesForArgument(argument: Argument) : string[];

  /**
   * Gets the raw value of the given option. Raw values are the values as given in the user command line.
   * @param option the option
   * @return the value, {@code null} if none.
   * 
   */
  getRawValueForOption(option: Option) : string | null;

  /**
   * Checks whether or not the given option accept more values.
   * @param option the option
   * @return {@link true} if the option accepts more values, {@link false} otherwise.
   * 
   */
  acceptMoreValues(option: Option) : boolean;

  /**
   * Gets the raw value of the given argument. Raw values are the values as given in the user command line.
   * @param arg the argument
   * @return the value, {@code null} if none.
   * 
   */
  getRawValueForArgument(arg: Argument) : string | null;

  /**
   * Checks whether or not the given argument has been assigned in the command line.
   * @param arg the argument
   * @return {@code true} if the argument has received a value, {@link false} otherwise.
   * 
   */
  isArgumentAssigned(arg: Argument) : boolean;

  /**
   * Checks whether or not the given option has been seen in the user command line.
   * @param option the option
   * @return {@code true} if the user command line has used the option
   * 
   */
  isSeenInCommandLine(option: Option) : boolean;

  /**
   * Checks whether or not the command line is valid, i.e. all constraints from arguments and options have been
   *  satisfied. This method is used when the parser validation is disabled.
   * @return {@code true} if the current {@link CommandLine} object is valid. {@link false} otherwise.
   * 
   */
  isValid() : boolean;

  /**
   * Checks whether or not the user has passed a "help" option and is asking for help.
   * @return {@code true} if the user command line has enabled a "Help" option, {@link false} otherwise.
   * 
   */
  isAskingForHelp() : boolean;
}

export abstract class CompositeFuture extends Future<CompositeFuture> {
  /**
   * Set the result. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * 
   */
  complete(result: CompositeFuture) : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * @return false when the future is already completed
   * 
   */
  tryComplete(result: CompositeFuture) : boolean;

  /**
   * The result of the operation. This will be null if the operation failed.
   * @return the result or null if the operation failed.
   * 
   */
  result() : CompositeFuture;

  /**
   * Compose this future with a provided {@code next} future.<p>
   * 
   *  When this (the one on which {@code compose} is called) future succeeds, the {@code handler} will be called with
   *  the completed value, this handler should complete the next future.<p>
   * 
   *  If the {@code handler} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the {@code next} future and the {@code handler}
   *  will not be called.
   * @param handler the handler
   * @param next the next future
   * @return the next future, used for chaining
   * 
   */
  compose<U>(handler: ((res: CompositeFuture) => void) | Handler<CompositeFuture>, next: Future<U>) : Future<U>;

  /**
   * Compose this future with a {@code mapper} function.<p>
   * 
   *  When this future (the one on which {@code compose} is called) succeeds, the {@code mapper} will be called with
   *  the completed value and this mapper returns another future object. This returned future completion will complete
   *  the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the composed future
   * 
   */
  compose<U>(mapper: (arg: CompositeFuture) => Future<U>) : Future<U>;

  /**
   * Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future succeeds, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  map<U>(mapper: (arg: CompositeFuture) => U) : Future<U>;

  /**
   *
   * @return an handler completing this future
   * @deprecated use this object instead since it extends {@code Handler<AsyncResult<T>>}
   * 
   */
  completer() : ((res: AsyncResult<CompositeFuture>) => void) | Handler<AsyncResult<CompositeFuture>>;

  /**
   * Handles a failure of this Future by returning the result of another Future.
   *  If the mapper fails, then the returned future will be failed with this failure.
   * @param mapper A function which takes the exception of a failure and returns a new future.
   * @return A recovered future
   * 
   */
  recover(mapper: (arg: Error) => Future<CompositeFuture>) : Future<CompositeFuture>;

  /**
   * Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future fails, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  otherwise(mapper: (arg: Error) => CompositeFuture) : Future<CompositeFuture>;

  /**
   * Map the failure of a future to a specific {@code value}.<p>
   * 
   *  When this future fails, this {@code value} will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @param value the value that eventually completes the mapped future
   * @return the mapped future
   * 
   */
  otherwise(value: CompositeFuture) : Future<CompositeFuture>;

  /**
   * Map the failure of a future to {@code null}.<p>
   * 
   *  This is a convenience for {@code future.otherwise((T) null)}.<p>
   * 
   *  When this future fails, the {@code null} value will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @return the mapped future
   * 
   */
  otherwiseEmpty() : Future<CompositeFuture>;

  /**
   * Return a composite future, succeeded when all futures are succeeded, failed when any future is failed.
   *  <p/>
   *  The returned future fails as soon as one of {@code f1} or {@code f2} fails.
   * @param f1 future
   * @param f2 future
   * @return the composite future
   * 
   */
  static all<T1, T2>(f1: Future<T1>, f2: Future<T2>) : CompositeFuture;

  /**
   * Like {@link #all(Future, Future)} but with 3 futures.
   * 
   */
  static all<T1, T2, T3>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>) : CompositeFuture;

  /**
   * Like {@link #all(Future, Future)} but with 4 futures.
   * 
   */
  static all<T1, T2, T3, T4>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>) : CompositeFuture;

  /**
   * Like {@link #all(Future, Future)} but with 5 futures.
   * 
   */
  static all<T1, T2, T3, T4, T5>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>) : CompositeFuture;

  /**
   * Like {@link #all(Future, Future)} but with 6 futures.
   * 
   */
  static all<T1, T2, T3, T4, T5, T6>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>, f6: Future<T6>) : CompositeFuture;

  /**
   * Like {@link #all(Future, Future)} but with a list of futures.<p>
   * 
   *  When the list is empty, the returned future will be already completed.
   * 
   */
  static all(futures: Future<any>[]) : CompositeFuture;

  /**
   * Return a composite future, succeeded when any futures is succeeded, failed when all futures are failed.
   *  <p/>
   *  The returned future succeeds as soon as one of {@code f1} or {@code f2} succeeds.
   * @param f1 future
   * @param f2 future
   * @return the composite future
   * 
   */
  static any<T1, T2>(f1: Future<T1>, f2: Future<T2>) : CompositeFuture;

  /**
   * Like {@link #any(Future, Future)} but with 3 futures.
   * 
   */
  static any<T1, T2, T3>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>) : CompositeFuture;

  /**
   * Like {@link #any(Future, Future)} but with 4 futures.
   * 
   */
  static any<T1, T2, T3, T4>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>) : CompositeFuture;

  /**
   * Like {@link #any(Future, Future)} but with 5 futures.
   * 
   */
  static any<T1, T2, T3, T4, T5>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>) : CompositeFuture;

  /**
   * Like {@link #any(Future, Future)} but with 6 futures.
   * 
   */
  static any<T1, T2, T3, T4, T5, T6>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>, f6: Future<T6>) : CompositeFuture;

  /**
   * Like {@link #any(Future, Future)} but with a list of futures.<p>
   * 
   *  When the list is empty, the returned future will be already completed.
   * 
   */
  static any(futures: Future<any>[]) : CompositeFuture;

  /**
   * Return a composite future, succeeded when all futures are succeeded, failed when any future is failed.
   *  <p/>
   *  It always wait until all its futures are completed and will not fail as soon as one of {@code f1} or {@code f2} fails.
   * @param f1 future
   * @param f2 future
   * @return the composite future
   * 
   */
  static join<T1, T2>(f1: Future<T1>, f2: Future<T2>) : CompositeFuture;

  /**
   * Like {@link #join(Future, Future)} but with 3 futures.
   * 
   */
  static join<T1, T2, T3>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>) : CompositeFuture;

  /**
   * Like {@link #join(Future, Future)} but with 4 futures.
   * 
   */
  static join<T1, T2, T3, T4>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>) : CompositeFuture;

  /**
   * Like {@link #join(Future, Future)} but with 5 futures.
   * 
   */
  static join<T1, T2, T3, T4, T5>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>) : CompositeFuture;

  /**
   * Like {@link #join(Future, Future)} but with 6 futures.
   * 
   */
  static join<T1, T2, T3, T4, T5, T6>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>, f6: Future<T6>) : CompositeFuture;

  /**
   * Like {@link #join(Future, Future)} but with a list of futures.<p>
   * 
   *  When the list is empty, the returned future will be already completed.
   * 
   */
  static join(futures: Future<any>[]) : CompositeFuture;

  setHandler(handler: ((res: AsyncResult<CompositeFuture>) => void) | Handler<AsyncResult<CompositeFuture>>) : Future<CompositeFuture>;

  /**
   * Set this instance as result. Any handler will be called, if there is one, and the future will be marked as completed.
   * 
   */
  complete() : void;

  /**
   * Try to set this instance as result. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @return false when the future is already completed
   * 
   */
  tryComplete() : boolean;

  /**
   * Returns a cause of a wrapped future
   * @param index the wrapped future index
   * 
   */
  cause(index?: number) : Error;

  /**
   * Returns true if a wrapped future is succeeded
   * @param index the wrapped future index
   * 
   */
  succeeded(index?: number) : boolean;

  /**
   * Returns true if a wrapped future is failed
   * @param index the wrapped future index
   * 
   */
  failed(index?: number) : boolean;

  /**
   * Returns true if a wrapped future is completed
   * @param index the wrapped future index
   * 
   */
  isComplete(index?: number) : boolean;

  /**
   * Returns the result of a wrapped future
   * @param index the wrapped future index
   * 
   */
  resultAt<T>(index: number) : T;

  /**
   *
   * @return the number of wrapped future
   * 
   */
  size() : number;
}

export abstract class Context {
  /**
   * Is the current thread a worker thread?
   *  <p>
   *  NOTE! This is not always the same as calling {@link Context#isWorkerContext}. If you are running blocking code
   *  from an event loop context, then this will return true but {@link Context#isWorkerContext} will return false.
   * @return true if current thread is a worker thread, false otherwise
   * 
   */
  static isOnWorkerThread() : boolean;

  /**
   * Is the current thread an event thread?
   *  <p>
   *  NOTE! This is not always the same as calling {@link Context#isEventLoopContext}. If you are running blocking code
   *  from an event loop context, then this will return false but {@link Context#isEventLoopContext} will return true.
   * @return true if current thread is a worker thread, false otherwise
   * 
   */
  static isOnEventLoopThread() : boolean;

  /**
   * Is the current thread a Vert.x thread? That's either a worker thread or an event loop thread
   * @return true if current thread is a Vert.x thread, false otherwise
   * 
   */
  static isOnVertxThread() : boolean;

  /**
   * Run the specified action asynchronously on the same context, some time after the current execution has completed.
   * @param action  the action to run
   * 
   */
  runOnContext(action: ((res: void) => void) | Handler<void>) : void;

  /**
   * Safely execute some blocking code.
   *  <p>
   *  Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
   *  <p>
   *  When the code is complete the handler {@code resultHandler} will be called with the result on the original context
   *  (e.g. on the original event loop of the caller).
   *  <p>
   *  A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
   *  the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
   *  method if it failed.
   *  <p>
   *  The blocking code should block for a reasonable amount of time (i.e no more than a few seconds). Long blocking operations
   *  or polling operations (i.e a thread that spin in a loop polling events in a blocking fashion) are precluded.
   *  <p>
   *  When the blocking operation lasts more than the 10 seconds, a message will be printed on the console by the
   *  blocked thread checker.
   *  <p>
   *  Long blocking operations should use a dedicated thread managed by the application, which can interact with
   *  verticles using the event-bus or {@link Context#runOnContext(Handler)}
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param ordered  if true then if executeBlocking is called several times on the same context, the executions
   *                  for that context will be executed serially, not in parallel. if false then they will be no ordering
   *                  guarantees
   * @param <T> the type of the result
   * 
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Future<T>) => void) | Handler<Future<T>>, ordered: boolean, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Invoke {@link #executeBlocking(Handler, boolean, Handler)} with order = true.
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param <T> the type of the result
   * 
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Future<T>) => void) | Handler<Future<T>>, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * If the context is associated with a Verticle deployment, this returns the deployment ID of that deployment.
   * @return the deployment ID of the deployment or null if not a Verticle deployment
   * 
   */
  deploymentID() : string;

  /**
   * If the context is associated with a Verticle deployment, this returns the configuration that was specified when
   *  the verticle was deployed.
   * @return the configuration of the deployment or null if not a Verticle deployment
   * 
   */
  config() : { [key: string]: any } | null;

  /**
   * The process args
   * 
   */
  processArgs() : string[];

  /**
   * Is the current context an event loop context?
   *  <p>
   *  NOTE! when running blocking code using {@link io.vertx.core.Vertx#executeBlocking(Handler, Handler)} from a
   *  standard (not worker) verticle, the context will still an event loop context and this {@link this#isEventLoopContext()}
   *  will return true.
   * @return true if  false otherwise
   * 
   */
  isEventLoopContext() : boolean;

  /**
   * Is the current context a worker context?
   *  <p>
   *  NOTE! when running blocking code using {@link io.vertx.core.Vertx#executeBlocking(Handler, Handler)} from a
   *  standard (not worker) verticle, the context will still an event loop context and this {@link this#isWorkerContext()}
   *  will return false.
   * @return true if the current context is a worker context, false otherwise
   * 
   */
  isWorkerContext() : boolean;

  /**
   * Is the current context a multi-threaded worker context?
   * @return true if the current context is a multi-threaded worker context, false otherwise
   * 
   */
  isMultiThreadedWorkerContext() : boolean;

  /**
   * Get some data from the context.
   * @param key  the key of the data
   * @param <T>  the type of the data
   * @return the data
   * 
   */
  get<T>(key: string) : T;

  /**
   * Put some data in the context.
   *  <p>
   *  This can be used to share data between different handlers that share a context
   * @param key  the key of the data
   * @param value  the data
   * 
   */
  put(key: string, value: any) : void;

  /**
   * Remove some data from the context.
   * @param key  the key to remove
   * @return true if removed successfully, false otherwise
   * 
   */
  remove(key: string) : boolean;

  /**
   *
   * @return The Vertx instance that created the context
   * 
   */
  owner() : Vertx;

  /**
   *
   * @return  the number of instances of the verticle that were deployed in the deployment (if any) related
   *  to this context
   * 
   */
  getInstanceCount() : number;

  /**
   * Set an exception handler called when the context runs an action throwing an uncaught throwable.<p/>
   * 
   *  When this handler is called, {@link Vertx#currentContext()} will return this context.
   * @param handler the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : Context;

  addCloseHook(hook: (completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) => void) : void;

  removeCloseHook(hook: (completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) => void) : boolean;
}

export abstract class Counter {
  /**
   * Get the current value of the counter
   * @param resultHandler handler which will be passed the value
   * 
   */
  get(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Increment the counter atomically and return the new count
   * @param resultHandler handler which will be passed the value
   * 
   */
  incrementAndGet(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Increment the counter atomically and return the value before the increment.
   * @param resultHandler handler which will be passed the value
   * 
   */
  getAndIncrement(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Decrement the counter atomically and return the new count
   * @param resultHandler handler which will be passed the value
   * 
   */
  decrementAndGet(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Add the value to the counter atomically and return the new count
   * @param value  the value to add
   * @param resultHandler handler which will be passed the value
   * 
   */
  addAndGet(value: number, resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Add the value to the counter atomically and return the value before the add
   * @param value  the value to add
   * @param resultHandler handler which will be passed the value
   * 
   */
  getAndAdd(value: number, resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Set the counter to the specified value only if the current value is the expectec value. This happens
   *  atomically.
   * @param expected  the expected value
   * @param value  the new value
   * @param resultHandler  the handler will be passed true on success
   * 
   */
  compareAndSet(expected: number, value: number, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : void;
}

export abstract class DatagramPacket {
  /**
   * Returns the {@link io.vertx.core.net.SocketAddress} of the sender that sent
   *  this {@link io.vertx.core.datagram.DatagramPacket}.
   * @return the address of the sender
   * 
   */
  sender() : SocketAddress;

  /**
   * Returns the data of the {@link io.vertx.core.datagram.DatagramPacket}
   * @return the data
   * 
   */
  data() : Buffer;
}

export abstract class DatagramSocket implements Measured, ReadStream<DatagramPacket> {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<DatagramPacket>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<DatagramPacket>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<DatagramPacket>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Write the given {@link io.vertx.core.buffer.Buffer} to the {@link io.vertx.core.net.SocketAddress}.
   *  The {@link io.vertx.core.Handler} will be notified once the write completes.
   * @param packet  the {@link io.vertx.core.buffer.Buffer} to write
   * @param port  the host port of the remote peer
   * @param host  the host address of the remote peer
   * @param handler  the {@link io.vertx.core.Handler} to notify once the write completes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(packet: Buffer, port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Returns a {@code WriteStream<Buffer>} able to send {@link Buffer} to the
   *  {@link io.vertx.core.net.SocketAddress}.
   * @param port the port of the remote peer
   * @param host the host address of the remote peer
   * @return the write stream for sending packets
   * 
   */
  sender(port: number, host: string) : WriteStream<Buffer>;

  /**
   * Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using UTF8 encoding.
   *  The {@link Handler} will be notified once the write completes.
   * @param str   the {@link String} to write
   * @param port  the host port of the remote peer
   * @param host  the host address of the remote peer
   * @param handler  the {@link io.vertx.core.Handler} to notify once the write completes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(str: string, port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using the given encoding.
   *  The {@link Handler} will be notified once the write completes.
   * @param str  the {@link String} to write
   * @param enc  the charset used for encoding
   * @param port  the host port of the remote peer
   * @param host  the host address of the remote peer
   * @param handler  the {@link io.vertx.core.Handler} to notify once the write completes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(str: string, enc: string, port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Closes the {@link io.vertx.core.datagram.DatagramSocket} implementation asynchronous
   *  and notifies the handler once done.
   * @param handler  the handler to notify once complete
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Closes the {@link io.vertx.core.datagram.DatagramSocket}. The close itself is asynchronous.
   * 
   */
  close() : void;

  /**
   * Return the {@link io.vertx.core.net.SocketAddress} to which
   *  this {@link io.vertx.core.datagram.DatagramSocket} is bound.
   * @return the socket address
   * 
   */
  localAddress() : SocketAddress;

  /**
   * Joins a multicast group and listens for packets send to it.
   *  The {@link Handler} is notified once the operation completes.
   * @param multicastAddress  the address of the multicast group to join
   * @param  handler  then handler to notify once the operation completes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listenMulticastGroup(multicastAddress: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Joins a multicast group and listens for packets send to it on the given network interface.
   *  The {@link Handler} is notified once the operation completes.
   * @param  multicastAddress  the address of the multicast group to join
   * @param  networkInterface  the network interface on which to listen for packets.
   * @param  source  the address of the source for which we will listen for multicast packets
   * @param  handler  then handler to notify once the operation completes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listenMulticastGroup(multicastAddress: string, networkInterface: string, source: string | null | undefined, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Leaves a multicast group and stops listening for packets send to it.
   *  The {@link Handler} is notified once the operation completes.
   * @param multicastAddress  the address of the multicast group to leave
   * @param handler  then handler to notify once the operation completes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  unlistenMulticastGroup(multicastAddress: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Leaves a multicast group and stops listening for packets send to it on the given network interface.
   *  The {@link Handler} is notified once the operation completes.
   * @param  multicastAddress  the address of the multicast group to join
   * @param  networkInterface  the network interface on which to listen for packets.
   * @param  source  the address of the source for which we will listen for multicast packets
   * @param  handler the handler to notify once the operation completes
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  unlistenMulticastGroup(multicastAddress: string, networkInterface: string, source: string | null | undefined, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Block the given address for the given multicast address and notifies the {@link Handler} once
   *  the operation completes.
   * @param multicastAddress  the address for which you want to block the source address
   * @param sourceToBlock  the source address which should be blocked. You will not receive an multicast packets
   *                        for it anymore.
   * @param handler  the handler to notify once the operation completes
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  blockMulticastGroup(multicastAddress: string, sourceToBlock: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Block the given address for the given multicast address on the given network interface and notifies
   *  the {@link Handler} once the operation completes.
   * @param  multicastAddress  the address for which you want to block the source address
   * @param  networkInterface  the network interface on which the blocking should occur.
   * @param  sourceToBlock  the source address which should be blocked. You will not receive an multicast packets
   *                         for it anymore.
   * @param  handler  the handler to notify once the operation completes
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  blockMulticastGroup(multicastAddress: string, networkInterface: string, sourceToBlock: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Start listening on the given port and host. The handler will be called when the socket is listening.
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @param handler  the handler will be called when listening
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  pause() : DatagramSocket;

  resume() : DatagramSocket;

  fetch(amount: number) : DatagramSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : DatagramSocket;

  handler(handler: ((res: DatagramPacket) => void) | Handler<DatagramPacket> | null | undefined) : DatagramSocket;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : DatagramSocket;
}

export abstract class DeliveryContext<T> {
  /**
   *
   * @return  The message being delivered
   * 
   */
  message() : Message<T>;

  /**
   * Call the next interceptor
   * 
   */
  next() : void;

  /**
   *
   * @return true if the message is being sent (point to point) or False if the message is being published
   * 
   */
  send() : boolean;

  /**
   *
   * @return the value delivered by the message (before or after being processed by the codec)
   * 
   */
  body() : any;
}

export abstract class DnsClient {
  /**
   * Try to lookup the A (ipv4) or AAAA (ipv6) record for the given name. The first found will be used.
   * @param name  the name to resolve
   * @param handler  the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with the resolved address if a record was found. If non was found it
   *                  will get notifed with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lookup(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to lookup the A (ipv4) record for the given name. The first found will be used.
   * @param name  the name to resolve
   * @param handler  the {@link Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with the resolved {@link java.net.Inet4Address} if a record was found.
   *                  If non was found it will get notifed with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lookup4(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to lookup the AAAA (ipv6) record for the given name. The first found will be used.
   * @param name  the name to resolve
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link java.net.Inet6Address} if a record was found. If non was found
   *                  it will get notifed with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lookup6(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to resolve all A (ipv4) records for the given name.
   * @param name  the name to resolve
   * @param handler  the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with a {@link java.util.List} that contains all the resolved
   *                  {@link java.net.Inet4Address}es. If none was found an empty {@link java.util.List} will be used.
   *                  If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  resolveA(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve all AAAA (ipv6) records for the given name.
   * @param name  the name to resolve
   * @param handler the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                 The handler will get notified with a {@link java.util.List} that contains all the resolved
   *                 {@link java.net.Inet6Address}es. If none was found an empty {@link java.util.List} will be used.
   *                 If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  resolveAAAA(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the CNAME record for the given name.
   * @param name  the name to resolve the CNAME for
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link String} if a record was found. If none was found it will
   *                  get notified with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveCNAME(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the MX records for the given name.
   * @param name  the name for which the MX records should be resolved
   * @param handler  the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with a List that contains all resolved {@link MxRecord}s, sorted by
   *                  their {@link MxRecord#priority()}. If non was found it will get notified with an empty
   *                  {@link java.util.List}.  If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveMX(name: string, handler: ((res: AsyncResult<MxRecord[]>) => void) | Handler<AsyncResult<MxRecord[]>>) : DnsClient;

  /**
   * Try to resolve the TXT records for the given name.
   * @param name  the name for which the TXT records should be resolved
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with a List that contains all resolved {@link String}s. If none was found it will
   *                  get notified with an empty {@link java.util.List}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveTXT(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the PTR record for the given name.
   * @param name  the name to resolve the PTR for
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link String} if a record was found. If none was found it will
   *                  get notified with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolvePTR(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to resolve the NS records for the given name.
   * @param name  the name for which the NS records should be resolved
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with a List that contains all resolved {@link String}s. If none was found it will
   *                  get notified with an empty {@link java.util.List}.  If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveNS(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the SRV records for the given name.
   * @param name  the name for which the SRV records should be resolved
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with a List that contains all resolved {@link SrvRecord}s. If none was found it will
   *                  get notified with an empty {@link java.util.List}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveSRV(name: string, handler: ((res: AsyncResult<SrvRecord[]>) => void) | Handler<AsyncResult<SrvRecord[]>>) : DnsClient;

  /**
   * Try to do a reverse lookup of an IP address. This is basically the same as doing trying to resolve a PTR record
   *  but allows you to just pass in the IP address and not a valid ptr query string.
   * @param ipaddress  the IP address to resolve the PTR for
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link String} if a record was found. If none was found it will
   *                  get notified with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  reverseLookup(ipaddress: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;
}

import { DeliveryOptions } from './options';

export abstract class EventBus implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Sends a message.
   *  <p>
   *  The message will be delivered to at most one of the handlers registered to the address.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(address: string, message: any) : EventBus;

  /**
   * Like {@link #send(String, Object)} but specifying a {@code replyHandler} that will be called if the recipient
   *  subsequently replies to the message.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @param replyHandler  reply handler will be called when any reply from the recipient is received, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send<T>(address: string, message: any, replyHandler: ((res: AsyncResult<Message<T>>) => void) | Handler<AsyncResult<Message<T>>>) : EventBus;

  /**
   * Like {@link #send(String, Object)} but specifying {@code options} that can be used to configure the delivery.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @param options  delivery options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(address: string, message: any, options: DeliveryOptions) : EventBus;

  /**
   * Like {@link #send(String, Object, DeliveryOptions)} but specifying a {@code replyHandler} that will be called if the recipient
   *  subsequently replies to the message.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @param options  delivery options
   * @param replyHandler  reply handler will be called when any reply from the recipient is received, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send<T>(address: string, message: any, options: DeliveryOptions, replyHandler: ((res: AsyncResult<Message<T>>) => void) | Handler<AsyncResult<Message<T>>>) : EventBus;

  /**
   * Publish a message.<p>
   *  The message will be delivered to all handlers registered to the address.
   * @param address  the address to publish it to
   * @param message  the message, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   * 
   */
  publish(address: string, message: any) : EventBus;

  /**
   * Like {@link #publish(String, Object)} but specifying {@code options} that can be used to configure the delivery.
   * @param address  the address to publish it to
   * @param message  the message, may be {@code null}
   * @param options  the delivery options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  publish(address: string, message: any, options: DeliveryOptions) : EventBus;

  /**
   * Create a message consumer against the specified address.
   *  <p>
   *  The returned consumer is not yet registered
   *  at the address, registration will be effective when {@link MessageConsumer#handler(io.vertx.core.Handler)}
   *  is called.
   * @param address  the address that it will register it at
   * @return the event bus message consumer
   * 
   */
  consumer<T>(address: string) : MessageConsumer<T>;

  /**
   * Create a consumer and register it against the specified address.
   * @param address  the address that will register it at
   * @param handler  the handler that will process the received messages
   * @return the event bus message consumer
   * 
   */
  consumer<T>(address: string, handler: ((res: Message<T>) => void) | Handler<Message<T>>) : MessageConsumer<T>;

  /**
   * Like {@link #consumer(String)} but the address won't be propagated across the cluster.
   * @param address  the address to register it at
   * @return the event bus message consumer
   * 
   */
  localConsumer<T>(address: string) : MessageConsumer<T>;

  /**
   * Like {@link #consumer(String, Handler)} but the address won't be propagated across the cluster.
   * @param address  the address that will register it at
   * @param handler  the handler that will process the received messages
   * @return the event bus message consumer
   * 
   */
  localConsumer<T>(address: string, handler: ((res: Message<T>) => void) | Handler<Message<T>>) : MessageConsumer<T>;

  /**
   * Create a message sender against the specified address.
   *  <p>
   *  The returned sender will invoke the {@link #send(String, Object)}
   *  method when the stream {@link io.vertx.core.streams.WriteStream#write(Object)} method is called with the sender
   *  address and the provided data.
   * @param address  the address to send it to
   * @return The sender
   * 
   */
  sender<T>(address: string) : MessageProducer<T>;

  /**
   * Like {@link #sender(String)} but specifying delivery options that will be used for configuring the delivery of
   *  the message.
   * @param address  the address to send it to
   * @param options  the delivery options
   * @return The sender
   * 
   */
  sender<T>(address: string, options: DeliveryOptions) : MessageProducer<T>;

  /**
   * Create a message publisher against the specified address.
   *  <p>
   *  The returned publisher will invoke the {@link #publish(String, Object)}
   *  method when the stream {@link io.vertx.core.streams.WriteStream#write(Object)} method is called with the publisher
   *  address and the provided data.
   * @param address The address to publish it to
   * @return The publisher
   * 
   */
  publisher<T>(address: string) : MessageProducer<T>;

  /**
   * Like {@link #publisher(String)} but specifying delivery options that will be used for configuring the delivery of
   *  the message.
   * @param address  the address to publish it to
   * @param options  the delivery options
   * @return The publisher
   * 
   */
  publisher<T>(address: string, options: DeliveryOptions) : MessageProducer<T>;

  /**
   * Add an interceptor that will be called whenever a message is sent from Vert.x
   * @param interceptor  the interceptor
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addOutboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Remove an interceptor that was added by {@link #addOutboundInterceptor(Handler)}
   * @param interceptor  the interceptor
   * @return a reference to this, so the API can be used fluently
   * 
   */
  removeOutboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Add an interceptor that will be called whenever a message is received by Vert.x
   * @param interceptor  the interceptor
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addInboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Remove an interceptor that was added by {@link #addInboundInterceptor(Handler)}
   * @param interceptor  the interceptor
   * @return a reference to this, so the API can be used fluently
   * 
   */
  removeInboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Register a message codec.
   *  <p>
   *  You can register a message codec if you want to send any non standard message across the event bus.
   *  E.g. you might want to send POJOs directly across the event bus.
   *  <p>
   *  To use a message codec for a send, you should specify it in the delivery options.
   * @param codec  the message codec to register
   * @return a reference to this, so the API can be used fluently
   * 
   */
  registerCodec(codec: any /* io.vertx.core.eventbus.MessageCodec */) : EventBus;

  /**
   * Unregister a message codec.
   *  <p>
   * @param name  the name of the codec
   * @return a reference to this, so the API can be used fluently
   * 
   */
  unregisterCodec(name: string) : EventBus;
}

export abstract class FileProps {
  /**
   * The date the file was created
   * 
   */
  creationTime() : number;

  /**
   * The date the file was last accessed
   * 
   */
  lastAccessTime() : number;

  /**
   * The date the file was last modified
   * 
   */
  lastModifiedTime() : number;

  /**
   * Is the file a directory?
   * 
   */
  isDirectory() : boolean;

  /**
   * Is the file some other type? (I.e. not a directory, regular file or symbolic link)
   * 
   */
  isOther() : boolean;

  /**
   * Is the file a regular file?
   * 
   */
  isRegularFile() : boolean;

  /**
   * Is the file a symbolic link?
   * 
   */
  isSymbolicLink() : boolean;

  /**
   * The size of the file, in bytes
   * 
   */
  size() : number;
}

import { OpenOptions } from './options';
import { CopyOptions } from './options';

export abstract class FileSystem {
  /**
   * Copy a file from the path {@code from} to path {@code to}, asynchronously.
   *  <p>
   *  The copy will fail if the destination already exists.
   * @param from  the path to copy from
   * @param to  the path to copy to
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copy(from: string, to: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Copy a file from the path {@code from} to path {@code to}, asynchronously.
   * @param from    the path to copy from
   * @param to      the path to copy to
   * @param options options describing how the file should be copied
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copy(from: string, to: string, options: CopyOptions, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #copy(String, String, Handler)}
   * 
   */
  copyBlocking(from: string, to: string) : FileSystem;

  /**
   * Copy a file from the path {@code from} to path {@code to}, asynchronously.
   *  <p>
   *  If {@code recursive} is {@code true} and {@code from} represents a directory, then the directory and its contents
   *  will be copied recursively to the destination {@code to}.
   *  <p>
   *  The copy will fail if the destination if the destination already exists.
   * @param from  the path to copy from
   * @param to  the path to copy to
   * @param recursive
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copyRecursive(from: string, to: string, recursive: boolean, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #copyRecursive(String, String, boolean, Handler)}
   * 
   */
  copyRecursiveBlocking(from: string, to: string, recursive: boolean) : FileSystem;

  /**
   * Move a file from the path {@code from} to path {@code to}, asynchronously.
   *  <p>
   *  The move will fail if the destination already exists.
   * @param from  the path to copy from
   * @param to  the path to copy to
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  move(from: string, to: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Move a file from the path {@code from} to path {@code to}, asynchronously.
   * @param from    the path to copy from
   * @param to      the path to copy to
   * @param options options describing how the file should be copied
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  move(from: string, to: string, options: CopyOptions, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #move(String, String, Handler)}
   * 
   */
  moveBlocking(from: string, to: string) : FileSystem;

  /**
   * Truncate the file represented by {@code path} to length {@code len} in bytes, asynchronously.
   *  <p>
   *  The operation will fail if the file does not exist or {@code len} is less than {@code zero}.
   * @param path  the path to the file
   * @param len  the length to truncate it to
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  truncate(path: string, len: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #truncate(String, long, Handler)}
   * 
   */
  truncateBlocking(path: string, len: number) : FileSystem;

  /**
   * Change the permissions on the file represented by {@code path} to {@code perms}, asynchronously.
   *  <p>
   *  The permission String takes the form rwxr-x--- as
   *  specified <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * @param path  the path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  chmod(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #chmod(String, String, Handler) }
   * 
   */
  chmodBlocking(path: string, perms: string) : FileSystem;

  /**
   * Change the permissions on the file represented by {@code path} to {@code perms}, asynchronously.<p>
   *  The permission String takes the form rwxr-x--- as
   *  specified in {<a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>}.
   *  <p>
   *  If the file is directory then all contents will also have their permissions changed recursively. Any directory permissions will
   *  be set to {@code dirPerms}, whilst any normal file permissions will be set to {@code perms}.
   * @param path  the path to the file
   * @param perms  the permissions string
   * @param dirPerms  the directory permissions
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  chmodRecursive(path: string, perms: string, dirPerms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #chmodRecursive(String, String, String, Handler)}
   * 
   */
  chmodRecursiveBlocking(path: string, perms: string, dirPerms: string) : FileSystem;

  /**
   * Change the ownership on the file represented by {@code path} to {@code user} and {code group}, asynchronously.
   * @param path  the path to the file
   * @param user  the user name, {@code null} will not change the user name
   * @param group  the user group, {@code null} will not change the user group name
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  chown(path: string, user: string | null | undefined, group: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #chown(String, String, String, Handler)}
   * 
   * 
   */
  chownBlocking(path: string, user: string | null | undefined, group: string | null | undefined) : FileSystem;

  /**
   * Obtain properties for the file represented by {@code path}, asynchronously.
   *  <p>
   *  If the file is a link, the link will be followed.
   * @param path  the path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  props(path: string, handler: ((res: AsyncResult<FileProps>) => void) | Handler<AsyncResult<FileProps>>) : FileSystem;

  /**
   * Blocking version of {@link #props(String, Handler)}
   * 
   */
  propsBlocking(path: string) : FileProps;

  /**
   * Obtain properties for the link represented by {@code path}, asynchronously.
   *  <p>
   *  The link will not be followed.
   * @param path  the path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lprops(path: string, handler: ((res: AsyncResult<FileProps>) => void) | Handler<AsyncResult<FileProps>>) : FileSystem;

  /**
   * Blocking version of {@link #lprops(String, Handler)}
   * 
   */
  lpropsBlocking(path: string) : FileProps;

  /**
   * Create a hard link on the file system from {@code link} to {@code existing}, asynchronously.
   * @param link  the link
   * @param existing  the link destination
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  link(link: string, existing: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #link(String, String, Handler)}
   * 
   */
  linkBlocking(link: string, existing: string) : FileSystem;

  /**
   * Create a symbolic link on the file system from {@code link} to {@code existing}, asynchronously.
   * @param link  the link
   * @param existing  the link destination
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  symlink(link: string, existing: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #link(String, String, Handler)}
   * 
   */
  symlinkBlocking(link: string, existing: string) : FileSystem;

  /**
   * Unlinks the link on the file system represented by the path {@code link}, asynchronously.
   * @param link  the link
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  unlink(link: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #unlink(String, Handler)}
   * 
   */
  unlinkBlocking(link: string) : FileSystem;

  /**
   * Returns the path representing the file that the symbolic link specified by {@code link} points to, asynchronously.
   * @param link  the link
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readSymlink(link: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #readSymlink(String, Handler)}
   * 
   */
  readSymlinkBlocking(link: string) : string;

  /**
   * Deletes the file represented by the specified {@code path}, asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  delete(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #delete(String, Handler)}
   * 
   */
  deleteBlocking(path: string) : FileSystem;

  /**
   * Deletes the file represented by the specified {@code path}, asynchronously.
   *  <p>
   *  If the path represents a directory and {@code recursive = true} then the directory and its contents will be
   *  deleted recursively.
   * @param path  path to the file
   * @param recursive  delete recursively?
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  deleteRecursive(path: string, recursive: boolean, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #deleteRecursive(String, boolean, Handler)}
   * 
   */
  deleteRecursiveBlocking(path: string, recursive: boolean) : FileSystem;

  /**
   * Create the directory represented by {@code path}, asynchronously.
   *  <p>
   *  The operation will fail if the directory already exists.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdir(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #mkdir(String, Handler)}
   * 
   */
  mkdirBlocking(path: string) : FileSystem;

  /**
   * Create the directory represented by {@code path}, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  <p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *  <p>
   *  The operation will fail if the directory already exists.
   * @param path  path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdir(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #mkdir(String, String, Handler)}
   * 
   */
  mkdirBlocking(path: string, perms: string) : FileSystem;

  /**
   * Create the directory represented by {@code path} and any non existent parents, asynchronously.
   *  <p>
   *  The operation will fail if the directory already exists.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdirs(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #mkdirs(String, Handler)}
   * 
   */
  mkdirsBlocking(path: string) : FileSystem;

  /**
   * Create the directory represented by {@code path} and any non existent parents, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  <p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *  <p>
   *  The operation will fail if the directory already exists.<p>
   * @param path  path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdirs(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #mkdirs(String, String, Handler)}
   * 
   */
  mkdirsBlocking(path: string, perms: string) : FileSystem;

  /**
   * Read the contents of the directory specified by {@code path}, asynchronously.
   *  <p>
   *  The result is an array of String representing the paths of the files inside the directory.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readDir(path: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : FileSystem;

  /**
   * Blocking version of {@link #readDir(String, Handler)}
   * 
   */
  readDirBlocking(path: string) : string[];

  /**
   * Read the contents of the directory specified by {@code path}, asynchronously.
   *  <p>
   *  The parameter {@code filter} is a regular expression. If {@code filter} is specified then only the paths that
   *  match  @{filter}will be returned.
   *  <p>
   *  The result is an array of String representing the paths of the files inside the directory.
   * @param path  path to the directory
   * @param filter  the filter expression
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readDir(path: string, filter: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : FileSystem;

  /**
   * Blocking version of {@link #readDir(String, String, Handler)}
   * 
   */
  readDirBlocking(path: string, filter: string) : string[];

  /**
   * Reads the entire file as represented by the path {@code path} as a {@link Buffer}, asynchronously.
   *  <p>
   *  Do not use this method to read very large files or you risk running out of available RAM.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readFile(path: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : FileSystem;

  /**
   * Blocking version of {@link #readFile(String, Handler)}
   * 
   */
  readFileBlocking(path: string) : Buffer;

  /**
   * Creates the file, and writes the specified {@code Buffer data} to the file represented by the path {@code path},
   *  asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFile(path: string, data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #writeFile(String, Buffer, Handler)}
   * 
   */
  writeFileBlocking(path: string, data: Buffer) : FileSystem;

  /**
   * Open the file represented by {@code path}, asynchronously.
   *  <p>
   *  The file is opened for both reading and writing. If the file does not already exist it will be created.
   * @param path  path to the file
   * @param options options describing how the file should be opened
   * @return a reference to this, so the API can be used fluently
   * 
   * 
   */
  open(path: string, options: OpenOptions, handler: ((res: AsyncResult<AsyncFile>) => void) | Handler<AsyncResult<AsyncFile>>) : FileSystem;

  /**
   * Blocking version of {@link #open(String, io.vertx.core.file.OpenOptions, Handler)}
   * 
   */
  openBlocking(path: string, options: OpenOptions) : AsyncFile;

  /**
   * Creates an empty file with the specified {@code path}, asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createFile(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #createFile(String, Handler)}
   * 
   */
  createFileBlocking(path: string) : FileSystem;

  /**
   * Creates an empty file with the specified {@code path} and permissions {@code perms}, asynchronously.
   * @param path  path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createFile(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link #createFile(String, String, Handler)}
   * 
   */
  createFileBlocking(path: string, perms: string) : FileSystem;

  /**
   * Determines whether the file as specified by the path {@code path} exists, asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exists(path: string, handler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : FileSystem;

  /**
   * Blocking version of {@link #exists(String, Handler)}
   * 
   */
  existsBlocking(path: string) : boolean;

  /**
   * Returns properties of the file-system being used by the specified {@code path}, asynchronously.
   * @param path  path to anywhere on the filesystem
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  fsProps(path: string, handler: ((res: AsyncResult<FileSystemProps>) => void) | Handler<AsyncResult<FileSystemProps>>) : FileSystem;

  /**
   * Blocking version of {@link #fsProps(String, Handler)}
   * 
   */
  fsPropsBlocking(path: string) : FileSystemProps;

  /**
   * Creates a new directory in the default temporary-file directory, using the given
   *  prefix to generate its name, asynchronously.
   * 
   *  <p>
   *  As with the {@code File.createTempFile} methods, this method is only
   *  part of a temporary-file facility.A {@link Runtime#addShutdownHook shutdown-hook},
   *  or the {@link java.io.File#deleteOnExit} mechanism may be used to delete the directory automatically.
   *  </p>
   * @param prefix  the prefix string to be used in generating the directory's name;
   *                 may be {@code null}
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createTempDirectory(prefix: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #createTempDirectory(String, Handler)}
   * 
   */
  createTempDirectoryBlocking(prefix: string) : string;

  /**
   * Creates a new directory in the default temporary-file directory, using the given
   *  prefix to generate its name, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  </p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * 
   *  <p>
   *  As with the {@code File.createTempFile} methods, this method is only
   *  part of a temporary-file facility.A {@link Runtime#addShutdownHook shutdown-hook},
   *  or the {@link java.io.File#deleteOnExit} mechanism may be used to delete the directory automatically.
   *  </p>
   * @param prefix  the prefix string to be used in generating the directory's name;
   *                 may be {@code null}
   * @param perms   the permissions string
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createTempDirectory(prefix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #createTempDirectory(String, String, Handler)}
   * 
   */
  createTempDirectoryBlocking(prefix: string, perms: string) : string;

  /**
   * Creates a new directory in the directory provided by the path {@code path}, using the given
   *  prefix to generate its name, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  </p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * 
   *  <p>
   *  As with the {@code File.createTempFile} methods, this method is only
   *  part of a temporary-file facility.A {@link Runtime#addShutdownHook shutdown-hook},
   *  or the {@link java.io.File#deleteOnExit} mechanism may be used to delete the directory automatically.
   *  </p>
   * @param dir     the path to directory in which to create the directory
   * @param prefix  the prefix string to be used in generating the directory's name;
   *                 may be {@code null}
   * @param perms   the permissions string
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createTempDirectory(dir: string, prefix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #createTempDirectory(String, String, String, Handler)}
   * 
   */
  createTempDirectoryBlocking(dir: string, prefix: string, perms: string) : string;

  /**
   * Creates a new file in the default temporary-file directory, using the given
   *  prefix and suffix to generate its name, asynchronously.
   * 
   *  <p>
   *  As with the {@code File.createTempFile} methods, this method is only
   *  part of a temporary-file facility.A {@link Runtime#addShutdownHook shutdown-hook},
   *  or the {@link java.io.File#deleteOnExit} mechanism may be used to delete the directory automatically.
   *  </p>
   * @param prefix  the prefix string to be used in generating the directory's name;
   *                 may be {@code null}
   * @param suffix  the suffix string to be used in generating the file's name;
   *                 may be {@code null}, in which case "{@code .tmp}" is used
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createTempFile(prefix: string, suffix: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #createTempFile(String, String, Handler)}
   * 
   */
  createTempFileBlocking(prefix: string, suffix: string) : string;

  /**
   * Creates a new file in the directory provided by the path {@code dir}, using the given
   *  prefix and suffix to generate its name, asynchronously.
   * 
   *  <p>
   *  As with the {@code File.createTempFile} methods, this method is only
   *  part of a temporary-file facility.A {@link Runtime#addShutdownHook shutdown-hook},
   *  or the {@link java.io.File#deleteOnExit} mechanism may be used to delete the directory automatically.
   *  </p>
   * @param prefix  the prefix string to be used in generating the directory's name;
   *                 may be {@code null}
   * @param suffix  the suffix string to be used in generating the file's name;
   *                 may be {@code null}, in which case "{@code .tmp}" is used
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createTempFile(prefix: string, suffix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #createTempFile(String, String, String, Handler)}
   * 
   */
  createTempFileBlocking(prefix: string, suffix: string, perms: string) : string;

  /**
   * Creates a new file in the directory provided by the path {@code dir}, using the given
   *  prefix and suffix to generate its name, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  </p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * 
   *  <p>
   *  As with the {@code File.createTempFile} methods, this method is only
   *  part of a temporary-file facility.A {@link Runtime#addShutdownHook shutdown-hook},
   *  or the {@link java.io.File#deleteOnExit} mechanism may be used to delete the directory automatically.
   *  </p>
   * @param dir     the path to directory in which to create the directory
   * @param prefix  the prefix string to be used in generating the directory's name;
   *                 may be {@code null}
   * @param suffix  the suffix string to be used in generating the file's name;
   *                 may be {@code null}, in which case "{@code .tmp}" is used
   * @param perms   the permissions string
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createTempFile(dir: string, prefix: string, suffix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link #createTempFile(String, String, String, String, Handler)}
   * 
   */
  createTempFileBlocking(dir: string, prefix: string, suffix: string, perms: string) : string;
}

export abstract class FileSystemProps {
  /**
   *
   * @return The total space on the file system, in bytes
   * 
   */
  totalSpace() : number;

  /**
   *
   * @return The total un-allocated space on the file system, in bytes
   * 
   */
  unallocatedSpace() : number;

  /**
   *
   * @return The total usable space on the file system, in bytes
   * 
   */
  usableSpace() : number;
}

export abstract class Future<T> {
  /**
   * Create a future that hasn't completed yet and that is passed to the {@code handler} before it is returned.
   * @param handler the handler
   * @param <T> the result type
   * @return the future.
   * 
   */
  static future<T>(handler: ((res: Future<T>) => void) | Handler<Future<T>>) : Future<T>;

  /**
   * Create a future that hasn't completed yet
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static future<T>() : Future<T>;

  /**
   * Create a succeeded future with a null result
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static succeededFuture<T>() : Future<T>;

  /**
   * Created a succeeded future with the specified result.
   * @param result  the result
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static succeededFuture<T>(result: T) : Future<T>;

  /**
   * Create a failed future with the specified failure cause.
   * @param t  the failure cause as a Throwable
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static failedFuture<T>(t: Error) : Future<T>;

  /**
   * Create a failed future with the specified failure message.
   * @param failureMessage  the failure message
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static failedFuture<T>(failureMessage: string) : Future<T>;

  /**
   * Has the future completed?
   *  <p>
   *  It's completed if it's either succeeded or failed.
   * @return true if completed, false if not
   * 
   */
  isComplete() : boolean;

  /**
   * Set a handler for the result.
   *  <p>
   *  If the future has already been completed it will be called immediately. Otherwise it will be called when the
   *  future is completed.
   * @param handler  the Handler that will be called with the result
   * @return a reference to this, so it can be used fluently
   * 
   * 
   */
  setHandler(handler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : Future<T>;

  /**
   * Set the result. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * 
   */
  complete(result: T) : void;

  /**
   *  Set a null result. Any handler will be called, if there is one, and the future will be marked as completed.
   * 
   */
  complete() : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param cause  the failure cause
   * 
   */
  fail(cause: Error) : void;

  /**
   * Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @param failureMessage  the failure message
   * 
   */
  fail(failureMessage: string) : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * @return false when the future is already completed
   * 
   */
  tryComplete(result: T) : boolean;

  /**
   * Try to set the result. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @return false when the future is already completed
   * 
   */
  tryComplete() : boolean;

  /**
   * Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @param cause  the failure cause
   * @return false when the future is already completed
   * 
   */
  tryFail(cause: Error) : boolean;

  /**
   * Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @param failureMessage  the failure message
   * @return false when the future is already completed
   * 
   */
  tryFail(failureMessage: string) : boolean;

  /**
   * The result of the operation. This will be null if the operation failed.
   * @return the result or null if the operation failed.
   * 
   */
  result() : T;

  /**
   * A Throwable describing failure. This will be null if the operation succeeded.
   * @return the cause or null if the operation succeeded.
   * 
   */
  cause() : Error;

  /**
   * Did it succeed?
   * @return true if it succeded or false otherwise
   * 
   */
  succeeded() : boolean;

  /**
   * Did it fail?
   * @return true if it failed or false otherwise
   * 
   */
  failed() : boolean;

  /**
   * Compose this future with a provided {@code next} future.<p>
   * 
   *  When this (the one on which {@code compose} is called) future succeeds, the {@code handler} will be called with
   *  the completed value, this handler should complete the next future.<p>
   * 
   *  If the {@code handler} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the {@code next} future and the {@code handler}
   *  will not be called.
   * @param handler the handler
   * @param next the next future
   * @return the next future, used for chaining
   * 
   */
  compose<U>(handler: ((res: T) => void) | Handler<T>, next: Future<U>) : Future<U>;

  /**
   * Compose this future with a {@code mapper} function.<p>
   * 
   *  When this future (the one on which {@code compose} is called) succeeds, the {@code mapper} will be called with
   *  the completed value and this mapper returns another future object. This returned future completion will complete
   *  the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the composed future
   * 
   */
  compose<U>(mapper: (arg: T) => Future<U>) : Future<U>;

  /**
   * Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future succeeds, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  map<U>(mapper: (arg: T) => U) : Future<U>;

  /**
   * Map the result of a future to a specific {@code value}.<p>
   * 
   *  When this future succeeds, this {@code value} will complete the future returned by this method call.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future.
   * @param value the value that eventually completes the mapped future
   * @return the mapped future
   * 
   */
  map<V>(value: V) : Future<V>;

  /**
   * Map the result of a future to {@code null}.<p>
   * 
   *  This is a conveniency for {@code future.map((T) null)} or {@code future.map((Void) null)}.<p>
   * 
   *  When this future succeeds, {@code null} will complete the future returned by this method call.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future.
   * @return the mapped future
   * 
   */
  mapEmpty<V>() : Future<V>;

  /**
   *
   * @return an handler completing this future
   * @deprecated use this object instead since it extends {@code Handler<AsyncResult<T>>}
   * 
   */
  completer() : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Handles a failure of this Future by returning the result of another Future.
   *  If the mapper fails, then the returned future will be failed with this failure.
   * @param mapper A function which takes the exception of a failure and returns a new future.
   * @return A recovered future
   * 
   */
  recover(mapper: (arg: Error) => Future<T>) : Future<T>;

  /**
   * Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future fails, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  otherwise(mapper: (arg: Error) => T) : Future<T>;

  /**
   * Map the failure of a future to a specific {@code value}.<p>
   * 
   *  When this future fails, this {@code value} will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @param value the value that eventually completes the mapped future
   * @return the mapped future
   * 
   */
  otherwise(value: T) : Future<T>;

  /**
   * Map the failure of a future to {@code null}.<p>
   * 
   *  This is a convenience for {@code future.otherwise((T) null)}.<p>
   * 
   *  When this future fails, the {@code null} value will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @return the mapped future
   * 
   */
  otherwiseEmpty() : Future<T>;
}

import { WebSocketConnectOptions } from './options';
import { RequestOptions } from './options';
import { HttpMethod } from './enums';
import { WebsocketVersion } from './enums';

export abstract class HttpClient implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Like {@link #request(HttpMethod, RequestOptions)} using the {@code serverAddress} parameter to connect to the
   *  server instead of the {@code absoluteURI} parameter.
   *  <p>
   *  The request host header will still be created from the {@code options} parameter.
   *  <p>
   *  Use {@link SocketAddress#domainSocketAddress(String)} to connect to a unix domain socket server.
   * 
   */
  request(method: HttpMethod, serverAddress: SocketAddress, options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server with the specified options.
   * @param method  the HTTP method
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and port.
   * @param method  the HTTP method
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Like {@link #request(HttpMethod, int, String, String)} using the {@code serverAddress} parameter to connect to the
   *  server instead of the {@code absoluteURI} parameter.
   *  <p>
   *  The request host header will still be created from the {@code host} and {@code port} parameters.
   *  <p>
   *  Use {@link SocketAddress#domainSocketAddress(String)} to connect to a unix domain socket server.
   * 
   */
  request(method: HttpMethod, serverAddress: SocketAddress, port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and default port.
   * @param method  the HTTP method
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server with the specified options, specifying a response handler to receive
   * @param method  the HTTP method
   * @param options  the request options
   * @return  an HTTP client request object
   * @deprecated this method will break in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>}
   * 
   */
  request(method: HttpMethod, options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Like {@link #request(HttpMethod, RequestOptions, Handler)} using the {@code serverAddress} parameter to connect to the
   *  server instead of the {@code absoluteURI} parameter.
   *  <p>
   *  The request host header will still be created from the {@code options} parameter.
   *  <p>
   *  Use {@link SocketAddress#domainSocketAddress(String)} to connect to a unix domain socket server.
   * 
   */
  request(method: HttpMethod, serverAddress: SocketAddress, options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  request(method: HttpMethod, port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Like {@link #request(HttpMethod, int, String, String, Handler)} using the {@code serverAddress} parameter to connect to the
   *  server instead of the {@code absoluteURI} parameter.
   *  <p>
   *  The request host header will still be created from the {@code host} and {@code port} parameters.
   *  <p>
   *  Use {@link SocketAddress#domainSocketAddress(String)} to connect to a unix domain socket server.
   * 
   */
  request(method: HttpMethod, serverAddress: SocketAddress, port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  request(method: HttpMethod, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the default host and port.
   * @param method  the HTTP method
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  request(method: HttpMethod, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server using an absolute URI
   * @param method  the HTTP method
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  requestAbs(method: HttpMethod, absoluteURI: string) : HttpClientRequest;

  /**
   * Like {@link #requestAbs(HttpMethod, String)} using the {@code serverAddress} parameter to connect to the
   *  server instead of the {@code absoluteURI} parameter.
   *  <p>
   *  The request host header will still be created from the {@code absoluteURI} parameter.
   *  <p>
   *  Use {@link SocketAddress#domainSocketAddress(String)} to connect to a unix domain socket server.
   * 
   */
  requestAbs(method: HttpMethod, serverAddress: SocketAddress, absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  requestAbs(method: HttpMethod, absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Like {@link #requestAbs(HttpMethod, String, Handler)} using the {@code serverAddress} parameter to connect to the
   *  server instead of the {@code absoluteURI} parameter.
   *  <p>
   *  The request host header will still be created from the {@code absoluteURI} parameter.
   *  <p>
   *  Use {@link SocketAddress#domainSocketAddress(String)} to connect to a unix domain socket server.
   * 
   */
  requestAbs(method: HttpMethod, serverAddress: SocketAddress, absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  get(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  get(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  get(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  get(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  get(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  get(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  get(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  get(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  getAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  getAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Sends an HTTP GET request to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  getNow(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP GET request to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  getNow(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP GET request to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  getNow(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP GET request  to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  getNow(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Create an HTTP POST request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  post(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  post(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  post(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  post(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  post(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  post(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  post(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  post(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  postAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  postAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  head(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  head(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  head(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  head(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  head(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  head(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  head(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  head(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  headAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  headAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Sends an HTTP HEAD request to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  headNow(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP HEAD request to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  headNow(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP HEAD request to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  headNow(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP HEAD request  to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  headNow(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Create an HTTP OPTIONS request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  options(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  options(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  options(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  options(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  options(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  options(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  options(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  options(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  optionsAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  optionsAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Sends an HTTP OPTIONS request to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  optionsNow(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP OPTIONS request to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  optionsNow(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP OPTIONS request to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  optionsNow(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP OPTIONS request  to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  optionsNow(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Create an HTTP PUT request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  put(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  put(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  put(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  put(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  put(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  put(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  put(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  put(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  putAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  putAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  delete(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  delete(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  delete(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  delete(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  delete(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  delete(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  delete(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  delete(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  deleteAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * @deprecated this method signature will change in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>},
   *              you can use instead the WebClient
   * 
   */
  deleteAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Connect a WebSocket with the specified options
   * @param options  the request options
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(int, String, String, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options
   * @param options  the request options
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(int, String, String, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the host and relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(String, String, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the host and relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(String, String, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, and with the specified headers
   * @param options  the request options
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, and with the specified headers
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, and with the specified headers
   * @param options  the request options
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, and with the specified headers
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host,relative request UR, and default port and with the specified headers
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host,relative request UR, and default port and with the specified headers
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket with the specified optionsI, with the specified headers and using
   *  the specified version of WebSockets
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers and using
   *  the specified version of WebSockets
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, with the specified headers and using
   *  the specified version of WebSockets
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers and using
   *  the specified version of WebSockets
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port with the specified headers and using
   *  the specified version of WebSockets
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port with the specified headers and using
   *  the specified version of WebSockets
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified absolute url, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols.
   * @param url            the absolute url
   * @param headers        the headers
   * @param version        the websocket version
   * @param subProtocols   the subprotocols to use
   * @param wsConnect      handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(String, Handler)} instead
   * 
   */
  websocket(requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(String, Handler)} instead
   * 
   */
  websocket(requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers and the
   *  specified version of WebSockets
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers and the
   *  specified version of WebSockets
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers, the
   *  specified version of WebSockets and the specified sub protocols
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers, the
   *  specified version of WebSockets and the specified sub protocols
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Error) => void) | Handler<Error>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param handler  handler that will be called with the websocket when connected
   * 
   */
  webSocket(port: number, host: string, requestURI: string, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket to the host and relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param handler  handler that will be called with the websocket when connected
   * 
   */
  webSocket(host: string, requestURI: string, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port
   * @param requestURI  the relative URI
   * @param handler  handler that will be called with the websocket when connected
   * 
   */
  webSocket(requestURI: string, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket with the specified options.
   * @param options  the request options
   * 
   */
  webSocket(options: WebSocketConnectOptions, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket with the specified absolute url, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols.
   * @param url            the absolute url
   * @param headers        the headers
   * @param version        the websocket version
   * @param subProtocols   the subprotocols to use
   * @param handler handler that will be called if websocket connection fails
   * 
   */
  webSocketAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string[], handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Create a WebSocket stream with the specified options
   * @param options  the request options
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(options: RequestOptions) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(int, String, String, Handler)} instead
   * 
   */
  websocketStream(port: number, host: string, requestURI: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified host, relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(String, String, Handler)} instead
   * 
   */
  websocketStream(host: string, requestURI: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified options, and with the specified headers
   * @param options  the request options
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(options: RequestOptions, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, and with the specified headers
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified host, relative request URI and default port and with the specified headers
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified options, with the specified headers and using
   *  the specified version of WebSockets
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(options: RequestOptions, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers and using
   *  the specified version of WebSockets
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified options and with the specified headers and using
   *  the specified version of WebSockets
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified absolute url, the specified headers, using the specified version of WebSockets,
   *  and the specified websocket sub protocols.
   * @param url          the absolute url
   * @param headers      the headers
   * @param version      the websocket version
   * @param subProtocols the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStreamAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified host, relative request URI and default port, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(String, Handler)} instead
   * 
   */
  websocketStream(requestURI: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(requestURI: string, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port, the specified headers and the
   *  specified version of WebSockets
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port, the specified headers, the
   *  specified version of WebSockets and the specified sub protocols
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * @deprecated use {@link #webSocket(WebSocketConnectOptions, Handler)} instead
   * 
   */
  websocketStream(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Set a connection handler for the client. This handler is called when a new connection is established.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectionHandler(handler: ((res: HttpConnection) => void) | Handler<HttpConnection>) : HttpClient;

  /**
   * Set a redirect handler for the http client.
   *  <p>
   *  The redirect handler is called when a {@code 3xx} response is received and the request is configured to
   *  follow redirects with {@link HttpClientRequest#setFollowRedirects(boolean)}.
   *  <p>
   *  The redirect handler is passed the {@link HttpClientResponse}, it can return an {@link HttpClientRequest} or {@code null}.
   *  <ul>
   *    <li>when null is returned, the original response is processed by the original request response handler</li>
   *    <li>when a new {@code Future<HttpClientRequest>} is returned, the client will send this new request</li>
   *  </ul>
   *  The new request will get a copy of the previous request headers unless headers are set. In this case,
   *  the client assumes that the redirect handler exclusively managers the headers of the new request.
   *  <p>
   *  The handler must return a {@code Future<HttpClientRequest>} unsent so the client can further configure it and send it.
   * @param handler the new redirect handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  redirectHandler(handler: (arg: HttpClientResponse) => Future<HttpClientRequest>) : HttpClient;

  /**
   * Close the client. Closing will close down any pooled connections.
   *  Clients should always be closed after use.
   * 
   */
  close() : void;
}

import { StreamPriority } from './options';
import { HttpVersion } from './enums';

export abstract class HttpClientRequest implements ReadStream<HttpClientResponse>, WriteStream<Buffer> {
  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<HttpClientResponse>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<HttpClientResponse>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<HttpClientResponse>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : HttpClientRequest;

  /**
   *
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  write(data: Buffer) : HttpClientRequest;

  /**
   * Same as {@link #write(Buffer)} but with an {@code handler} called when the operation completes
   * 
   */
  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpClientRequest;

  setWriteQueueMaxSize(maxSize: number) : HttpClientRequest;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientRequest;

  /**
   *
   * @deprecated this method will break in Vert.x 4, the handler will use an {@code Handler<AsyncResult<HttpClientResponse>>}
   * 
   */
  handler(handler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse> | null | undefined) : HttpClientRequest;

  /**
   *
   * @deprecated this method will be removed in Vert.x 4
   * 
   */
  pause() : HttpClientRequest;

  /**
   *
   * @deprecated this method will be removed in Vert.x 4
   * 
   */
  resume() : HttpClientRequest;

  /**
   *
   * @deprecated this method will be removed in Vert.x 4
   * 
   */
  fetch(amount: number) : HttpClientRequest;

  /**
   *
   * @deprecated this method will be removed in Vert.x 4
   * 
   */
  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientRequest;

  setFollowRedirects(followRedirects: boolean) : HttpClientRequest;

  /**
   * If chunked is true then the request will be set into HTTP chunked mode
   * @param chunked true if chunked encoding
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setChunked(chunked: boolean) : HttpClientRequest;

  /**
   *
   * @return Is the request chunked?
   * 
   */
  isChunked() : boolean;

  /**
   * The HTTP method for the request.
   * 
   */
  method() : HttpMethod;

  /**
   *
   * @return the raw value of the method this request sends
   * 
   */
  getRawMethod() : string;

  /**
   * Set the value the method to send when the method {@link HttpMethod#OTHER} is used.
   * @param method the raw method
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRawMethod(method: string) : HttpClientRequest;

  /**
   *
   * @return the absolute URI corresponding to the the HTTP request
   * 
   */
  absoluteURI() : string;

  /**
   *
   * @return The URI of the request.
   * 
   */
  uri() : string;

  /**
   *
   * @return The path part of the uri. For example /somepath/somemorepath/someresource.foo
   * 
   */
  path() : string;

  /**
   *
   * @return the query part of the uri. For example someparam=32&amp;someotherparam=x
   * 
   */
  query() : string;

  /**
   * Set the request host.<p/>
   * 
   *  For HTTP/2 it sets the {@literal :authority} pseudo header otherwise it sets the {@literal Host} header
   * 
   */
  setHost(host: string) : HttpClientRequest;

  /**
   *
   * @return the request host. For HTTP/2 it returns the {@literal :authority} pseudo header otherwise it returns the {@literal Host} header
   * 
   */
  getHost() : string;

  /**
   *
   * @return The HTTP headers
   * 
   */
  headers() : MultiMap;

  /**
   * Put an HTTP header
   * @param name  The header name
   * @param value The header value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  putHeader(name: string, value: string) : HttpClientRequest;

  /**
   * Write a {@link String} to the request body, encoded as UTF-8.
   * @return @return a reference to this, so the API can be used fluently
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  write(chunk: string) : HttpClientRequest;

  /**
   * Same as {@link #write(String)} but with an {@code handler} called when the operation completes
   * 
   */
  write(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpClientRequest;

  /**
   * Write a {@link String} to the request body, encoded using the encoding {@code enc}.
   * @return @return a reference to this, so the API can be used fluently
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  write(chunk: string, enc: string) : HttpClientRequest;

  /**
   * Same as {@link #write(String,String)} but with an {@code handler} called when the operation completes
   * 
   */
  write(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpClientRequest;

  /**
   * If you send an HTTP request with the header {@code Expect} set to the value {@code 100-continue}
   *  and the server responds with an interim HTTP response with a status code of {@code 100} and a continue handler
   *  has been set using this method, then the {@code handler} will be called.
   *  <p>
   *  You can then continue to write data to the request body and later end it. This is normally used in conjunction with
   *  the {@link #sendHead()} method to force the request header to be written before the request has ended.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  continueHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientRequest;

  /**
   * Forces the head of the request to be written before {@link #end()} is called on the request or any data is
   *  written to it.
   *  <p>
   *  This is normally used to implement HTTP 100-continue handling, see {@link #continueHandler(io.vertx.core.Handler)} for
   *  more information.
   * @return a reference to this, so the API can be used fluently
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  sendHead() : HttpClientRequest;

  /**
   * Like {@link #sendHead()} but with an handler after headers have been sent. The handler will be called with
   *  the {@link HttpVersion} if it can be determined or null otherwise.<p>
   * 
   */
  sendHead(completionHandler: ((res: HttpVersion) => void) | Handler<HttpVersion>) : HttpClientRequest;

  /**
   * Same as {@link #end(Buffer)} but writes a String in UTF-8 encoding
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end(chunk: string) : void;

  /**
   * Same as {@link #end(String)} but with an {@code handler} called when the operation completes
   * 
   */
  end(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link #end(Buffer)} but writes a String with the specified encoding
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end(chunk: string, enc: string) : void;

  /**
   * Same as {@link #end(String,String)} but with an {@code handler} called when the operation completes
   * 
   */
  end(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link #end()} but writes some data to the request body before ending. If the request is not chunked and
   *  no other data has been written then the {@code Content-Length} header will be automatically set
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end(chunk: Buffer) : void;

  /**
   * Same as {@link #end(String)} but with an {@code handler} called when the operation completes
   * 
   */
  end(chunk: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Ends the request. If no data has been written to the request body, and {@link #sendHead()} has not been called then
   *  the actual request won't get written until this method gets called.
   *  <p>
   *  Once the request has ended, it cannot be used any more,
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end() : void;

  /**
   * Same as {@link #end()} but with an {@code handler} called when the operation completes
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Set's the amount of time after which if the request does not return any data within the timeout period an
   *  {@link java.util.concurrent.TimeoutException} will be passed to the exception handler (if provided) and
   *  the request will be closed.
   *  <p>
   *  Calling this method more than once has the effect of canceling any existing timeout and starting
   *  the timeout from scratch.
   * @param timeoutMs The quantity of time in milliseconds.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTimeout(timeoutMs: number) : HttpClientRequest;

  /**
   * Set a push handler for this request.<p/>
   * 
   *  The handler is called when the client receives a <i>push promise</i> from the server. The handler can be called
   *  multiple times, for each push promise.<p/>
   * 
   *  The handler is called with a <i>read-only</i> {@link HttpClientRequest}, the following methods can be called:<p/>
   * 
   *  <ul>
   *    <li>{@link HttpClientRequest#method()}</li>
   *    <li>{@link HttpClientRequest#uri()}</li>
   *    <li>{@link HttpClientRequest#headers()}</li>
   *    <li>{@link HttpClientRequest#getHost()}</li>
   *  </ul>
   * 
   *  In addition the handler should call the {@link HttpClientRequest#handler} method to set an handler to
   *  process the response.<p/>
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pushHandler(handler: ((res: HttpClientRequest) => void) | Handler<HttpClientRequest>) : HttpClientRequest;

  /**
   * Reset this stream with the error code {@code 0}.
   * @see #reset(long)
   * 
   */
  reset() : boolean;

  /**
   * Reset this request:
   *  <p/>
   *  <ul>
   *    <li>for HTTP/2, this performs send an HTTP/2 reset frame with the specified error {@code code}</li>
   *    <li>for HTTP/1.x, this closes the connection when the current request is inflight</li>
   *  </ul>
   *  <p/>
   *  When the request has not yet been sent, the request will be aborted and false is returned as indicator.
   *  <p/>
   * @param code the error code
   * @return true when reset has been performed
   * 
   */
  reset(code: number) : boolean;

  /**
   *
   * @return the {@link HttpConnection} associated with this request
   * 
   */
  connection() : HttpConnection;

  /**
   * Set a connection handler called when an HTTP connection has been established.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectionHandler(handler: ((res: HttpConnection) => void) | Handler<HttpConnection> | null | undefined) : HttpClientRequest;

  /**
   * Write an HTTP/2 frame to the request, allowing to extend the HTTP/2 protocol.<p>
   * 
   *  The frame is sent immediatly and is not subject to flow control.<p>
   * 
   *  This method must be called after the request headers have been sent and only for the protocol HTTP/2.
   *  The {@link #sendHead(Handler)} should be used for this purpose.
   * @param type the 8-bit frame type
   * @param flags the 8-bit frame flags
   * @param payload the frame payload
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeCustomFrame(type: number, flags: number, payload: Buffer) : HttpClientRequest;

  /**
   *
   * @return the id of the stream of this response, {@literal -1} when it is not yet determined, i.e
   *          the request has not been yet sent or it is not supported HTTP/1.x
   * 
   */
  streamId() : number;

  /**
   * Like {@link #writeCustomFrame(int, int, Buffer)} but with an {@link HttpFrame}.
   * @param frame the frame to write
   * 
   */
  writeCustomFrame(frame: HttpFrame) : HttpClientRequest;

  /**
   * Sets the priority of the associated stream.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param streamPriority the priority of this request's stream
   * 
   */
  setStreamPriority(streamPriority: StreamPriority) : HttpClientRequest;

  /**
   *
   * @return the priority of the associated HTTP/2 stream for HTTP/2 otherwise {@code null}
   * 
   */
  getStreamPriority() : StreamPriority;

  /**
   * Like {@link #putHeader(String, String)} but using CharSequence
   * 
   */
  putHeader(name: string, value: string) : HttpClientRequest;

  /**
   * Put an HTTP header with multiple values
   * @param name   The header name
   * @param values The header values
   * @return @return a reference to this, so the API can be used fluently
   * 
   */
  putHeader(name: string, values: string[]) : HttpClientRequest;

  /**
   * Like {@link #putHeader(String, Iterable)} but using CharSequence
   * 
   */
  putHeader(name: string, values: string[]) : HttpClientRequest;
}

export abstract class HttpClientResponse implements ReadStream<Buffer> {
  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  fetch(amount: number) : HttpClientResponse;

  resume() : HttpClientResponse;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : HttpClientResponse;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpClientResponse;

  pause() : HttpClientResponse;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientResponse;

  /**
   *
   * @return the version of the response
   * 
   */
  version() : HttpVersion;

  /**
   *
   * @return the status code of the response
   * 
   */
  statusCode() : number;

  /**
   *
   * @return the status message of the response
   * 
   */
  statusMessage() : string;

  /**
   *
   * @return the headers
   * 
   */
  headers() : MultiMap;

  /**
   * Return the first header value with the specified name
   * @param headerName  the header name
   * @return the header value
   * 
   */
  getHeader(headerName: string) : string | null;

  /**
   * Return the first trailer value with the specified name
   * @param trailerName  the trailer name
   * @return the trailer value
   * 
   */
  getTrailer(trailerName: string) : string | null;

  /**
   *
   * @return the trailers
   * 
   */
  trailers() : MultiMap;

  /**
   *
   * @return the Set-Cookie headers (including trailers)
   * 
   */
  cookies() : string[];

  /**
   * Convenience method for receiving the entire request body in one piece.
   *  <p>
   *  This saves you having to manually set a dataHandler and an endHandler and append the chunks of the body until
   *  the whole body received. Don't use this if your request body is large - you could potentially run out of RAM.
   * @param bodyHandler This handler will be called after all the body has been received
   * 
   */
  bodyHandler(bodyHandler: ((res: Buffer) => void) | Handler<Buffer>) : HttpClientResponse;

  /**
   * Set an custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
   *  frame. HTTP/2 permits extension of the protocol.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  customFrameHandler(handler: ((res: HttpFrame) => void) | Handler<HttpFrame>) : HttpClientResponse;

  /**
   * Get a net socket for the underlying connection of this request.
   *  <p>
   *  USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're doing can easily break the HTTP protocol.
   *  <p>
   *  HTTP/1.1 pipe-lined requests cannot support net socket upgrade.
   *  <p>
   *  One valid use-case for calling this is to receive the {@link io.vertx.core.net.NetSocket} after a HTTP CONNECT was issued to the
   *  remote peer and it responded with a status code of 200.
   * @return the net socket
   * 
   */
  netSocket() : NetSocket;

  /**
   *
   * @return the corresponding request
   * 
   */
  request() : HttpClientRequest;

  /**
   * Set an handler for stream priority changes.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler to be called when the stream priority changes
   * 
   */
  streamPriorityHandler(handler: ((res: StreamPriority) => void) | Handler<StreamPriority>) : HttpClientResponse;

  /**
   * Return the first header value with the specified name
   * @param headerName  the header name
   * @return the header value
   * 
   */
  getHeader(headerName: string) : string;
}

import { GoAway } from './options';
import { Http2Settings } from './options';

export abstract class HttpConnection {
  /**
   *
   * @return the current connection window size or {@code -1} for HTTP/1.x
   * 
   */
  getWindowSize() : number;

  /**
   * Update the current connection wide window size to a new size.
   *  <p/>
   *  Increasing this value, gives better performance when several data streams are multiplexed
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param windowSize the new window size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWindowSize(windowSize: number) : HttpConnection;

  /**
   * Like {@link #goAway(long, int)} with a last stream id {@code -1} which means to disallow any new stream creation.
   * 
   */
  goAway(errorCode: number) : HttpConnection;

  /**
   * Like {@link #goAway(long, int, Buffer)} with no buffer.
   * 
   */
  goAway(errorCode: number, lastStreamId: number) : HttpConnection;

  /**
   * Send a go away frame to the remote endpoint of the connection.
   *  <p/>
   *  <ul>
   *    <li>a {@literal GOAWAY} frame is sent to the to the remote endpoint with the {@code errorCode} and {@code debugData}</li>
   *    <li>any stream created after the stream identified by {@code lastStreamId} will be closed</li>
   *    <li>for an {@literal errorCode} is different than {@code 0} when all the remaining streams are closed this connection will be closed automatically</li>
   *  </ul>
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param errorCode the {@literal GOAWAY} error code
   * @param lastStreamId the last stream id
   * @param debugData additional debug data sent to the remote endpoint
   * @return a reference to this, so the API can be used fluently
   * 
   */
  goAway(errorCode: number, lastStreamId: number, debugData: Buffer) : HttpConnection;

  /**
   * Set an handler called when a {@literal GOAWAY} frame is received.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  goAwayHandler(handler: ((res: GoAway) => void) | Handler<GoAway> | null | undefined) : HttpConnection;

  /**
   * Set an handler called when a {@literal GOAWAY} frame has been sent or received and all connections are closed.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  shutdownHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpConnection;

  /**
   * Initiate a connection shutdown, a go away frame is sent and the connection is closed when all current active streams
   *  are closed or after a time out of 30 seconds.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  shutdown() : HttpConnection;

  /**
   * Initiate a connection shutdown, a go away frame is sent and the connection is closed when all current streams
   *  will be closed or the {@code timeout} is fired.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param timeoutMs the timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  shutdown(timeoutMs: number) : HttpConnection;

  /**
   * Set a close handler. The handler will get notified when the connection is closed.
   * @param handler the handler to be notified
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: ((res: void) => void) | Handler<void>) : HttpConnection;

  /**
   * Close the connection and all the currently active streams.
   *  <p/>
   *  An HTTP/2 connection will send a {@literal GOAWAY} frame before.
   * 
   */
  close() : void;

  /**
   *
   * @return the latest server settings acknowledged by the remote endpoint - this is not implemented for HTTP/1.x
   * 
   */
  settings() : Http2Settings;

  /**
   * Send to the remote endpoint an update of the server settings.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param settings the new settings
   * @return a reference to this, so the API can be used fluently
   * 
   */
  updateSettings(settings: Http2Settings) : HttpConnection;

  /**
   * Send to the remote endpoint an update of this endpoint settings
   *  <p/>
   *  The {@code completionHandler} will be notified when the remote endpoint has acknowledged the settings.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param settings the new settings
   * @param completionHandler the handler notified when the settings have been acknowledged by the remote endpoint
   * @return a reference to this, so the API can be used fluently
   * 
   */
  updateSettings(settings: Http2Settings, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpConnection;

  /**
   *
   * @return the current remote endpoint settings for this connection - this is not implemented for HTTP/1.x
   * 
   */
  remoteSettings() : Http2Settings;

  /**
   * Set an handler that is called when remote endpoint {@link Http2Settings} are updated.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler for remote endpoint settings
   * @return a reference to this, so the API can be used fluently
   * 
   */
  remoteSettingsHandler(handler: ((res: Http2Settings) => void) | Handler<Http2Settings>) : HttpConnection;

  /**
   * Send a {@literal PING} frame to the remote endpoint.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param data the 8 bytes data of the frame
   * @param pongHandler an async result handler notified with pong reply or the failure
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ping(data: Buffer, pongHandler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : HttpConnection;

  /**
   * Set an handler notified when a {@literal PING} frame is received from the remote endpoint.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler to be called when a {@literal PING} is received
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pingHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpConnection;

  /**
   * Set an handler called when a connection error happens
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error>) : HttpConnection;

  /**
   *
   * @return the remote address for this connection
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *
   * @return the remote address for this connection
   * 
   */
  localAddress() : SocketAddress;

  /**
   *
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  /**
   * Returns the SNI server name presented during the SSL handshake by the client.
   * @return the indicated server name
   * 
   */
  indicatedServerName() : string;

  /**
   *
   * @return SSLSession associated with the underlying socket. Returns null if connection is
   *          not SSL.
   * @see javax.net.ssl.SSLSession
   * 
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

export abstract class HttpFrame {
  /**
   *
   * @return the 8-bit type of the frame
   * 
   */
  type() : number;

  /**
   *
   * @return the 8-bit flags specific to the frame
   * 
   */
  flags() : number;

  /**
   *
   * @return the frame payload
   * 
   */
  payload() : Buffer;
}

export abstract class HttpServer implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Return the request stream for the server. As HTTP requests are received by the server,
   *  instances of {@link HttpServerRequest} will be created and passed to the stream {@link io.vertx.core.streams.ReadStream#handler(io.vertx.core.Handler)}.
   * @return the request stream
   * 
   */
  requestStream() : ReadStream<HttpServerRequest>;

  /**
   * Set the request handler for the server to {@code requestHandler}. As HTTP requests are received by the server,
   *  instances of {@link HttpServerRequest} will be created and passed to this handler.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  requestHandler(handler: ((res: HttpServerRequest) => void) | Handler<HttpServerRequest>) : HttpServer;

  /**
   * Set a connection handler for the server.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectionHandler(handler: ((res: HttpConnection) => void) | Handler<HttpConnection>) : HttpServer;

  /**
   * Set an exception handler called for socket errors happening before the HTTP connection
   *  is established, e.g during the TLS handshake.
   * @param handler the handler to set
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error>) : HttpServer;

  /**
   * Return the websocket stream for the server. If a websocket connect handshake is successful a
   *  new {@link ServerWebSocket} instance will be created and passed to the stream {@link io.vertx.core.streams.ReadStream#handler(io.vertx.core.Handler)}.
   * @return the websocket stream
   * 
   */
  websocketStream() : ReadStream<ServerWebSocket>;

  /**
   * Set the websocket handler for the server to {@code wsHandler}. If a websocket connect handshake is successful a
   *  new {@link ServerWebSocket} instance will be created and passed to the handler.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocketHandler(handler: ((res: ServerWebSocket) => void) | Handler<ServerWebSocket>) : HttpServer;

  /**
   * Tell the server to start listening. The server will listen on the port and host specified in the
   *  {@link io.vertx.core.http.HttpServerOptions} that was used when creating the server.
   *  <p>
   *  The listen happens asynchronously and the server may not be listening until some time after the call has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen() : HttpServer;

  /**
   * Tell the server to start listening. The server will listen on the port and host specified here,
   *  ignoring any value set in the {@link io.vertx.core.http.HttpServerOptions} that was used when creating the server.
   *  <p>
   *  The listen happens asynchronously and the server may not be listening until some time after the call has returned.
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string) : HttpServer;

  /**
   * Like {@link #listen(int, String)} but supplying a handler that will be called when the server is actually
   *  listening (or has failed).
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @param listenHandler  the listen handler
   * 
   */
  listen(port: number, host: string, listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Tell the server to start listening on the given address supplying
   *  a handler that will be called when the server is actually
   *  listening (or has failed).
   * @param address the address to listen on
   * @param listenHandler  the listen handler
   * 
   */
  listen(address: SocketAddress, listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Like {@link #listen(int, String)} but the server will listen on host "0.0.0.0" and port specified here ignoring
   *  any value in the {@link io.vertx.core.http.HttpServerOptions} that was used when creating the server.
   * @param port  the port to listen on
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number) : HttpServer;

  /**
   * Like {@link #listen(int)} but supplying a handler that will be called when the server is actually listening (or has failed).
   * @param port  the port to listen on
   * @param listenHandler  the listen handler
   * 
   */
  listen(port: number, listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Like {@link #listen} but supplying a handler that will be called when the server is actually listening (or has failed).
   * @param listenHandler  the listen handler
   * 
   */
  listen(listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Close the server. Any open HTTP connections will be closed.
   *  <p>
   *  The close happens asynchronously and the server may not be closed until some time after the call has returned.
   * 
   */
  close() : void;

  /**
   * Like {@link #close} but supplying a handler that will be called when the server is actually closed (or has failed).
   * @param completionHandler  the handler
   * 
   */
  close(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * The actual port the server is listening on. This is useful if you bound the server specifying 0 as port number
   *  signifying an ephemeral port
   * @return the actual port the server is listening on.
   * 
   */
  actualPort() : number;
}

export abstract class HttpServerFileUpload implements ReadStream<Buffer> {
  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : HttpServerFileUpload;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpServerFileUpload;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerFileUpload;

  pause() : HttpServerFileUpload;

  resume() : HttpServerFileUpload;

  fetch(amount: number) : HttpServerFileUpload;

  /**
   * Stream the content of this upload to the given file on storage.
   * @param filename  the name of the file
   * 
   */
  streamToFileSystem(filename: string) : HttpServerFileUpload;

  /**
   *
   * @return the filename which was used when upload the file.
   * 
   */
  filename() : string;

  /**
   *
   * @return the name of the attribute
   * 
   */
  name() : string;

  /**
   *
   * @return  the content type for the upload
   * 
   */
  contentType() : string;

  /**
   *
   * @return the contentTransferEncoding for the upload
   * 
   */
  contentTransferEncoding() : string;

  /**
   *
   * @return the charset for the upload
   * 
   */
  charset() : string;

  /**
   * The size of the upload may not be available until it is all read.
   *  Check {@link #isSizeAvailable} to determine this
   * @return the size of the upload (in bytes)
   * 
   */
  size() : number;

  /**
   *
   * @return {@code true} if the size of the upload can be retrieved via {@link #size()}.
   * 
   */
  isSizeAvailable() : boolean;

  /**
   *
   * @return the async uploaded file when {@link #streamToFileSystem} has been used
   * 
   */
  file() : AsyncFile;
}

export abstract class HttpServerRequest implements ReadStream<Buffer> {
  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : HttpServerRequest;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpServerRequest;

  pause() : HttpServerRequest;

  resume() : HttpServerRequest;

  fetch(amount: number) : HttpServerRequest;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerRequest;

  /**
   *
   * @return the HTTP version of the request
   * 
   */
  version() : HttpVersion;

  /**
   *
   * @return the HTTP method for the request.
   * 
   */
  method() : HttpMethod;

  /**
   *
   * @return the HTTP method as sent by the client
   * 
   */
  rawMethod() : string;

  /**
   *
   * @return true if this {@link io.vertx.core.net.NetSocket} is encrypted via SSL/TLS
   * 
   */
  isSSL() : boolean;

  /**
   *
   * @return the scheme of the request
   * 
   */
  scheme() : string | null;

  /**
   *
   * @return the URI of the request. This is usually a relative URI
   * 
   */
  uri() : string;

  /**
   *
   * @return The path part of the uri. For example /somepath/somemorepath/someresource.foo
   * 
   */
  path() : string | null;

  /**
   *
   * @return the query part of the uri. For example someparam=32&amp;someotherparam=x
   * 
   */
  query() : string | null;

  /**
   *
   * @return the request host. For HTTP2 it returns the {@literal :authority} pseudo header otherwise it returns the {@literal Host} header
   * 
   */
  host() : string | null;

  /**
   *
   * @return the total number of bytes read for the body of the request.
   * 
   */
  bytesRead() : number;

  /**
   *
   * @return the response. Each instance of this class has an {@link HttpServerResponse} instance attached to it. This is used
   *  to send the response back to the client.
   * 
   */
  response() : HttpServerResponse;

  /**
   *
   * @return the headers in the request.
   * 
   */
  headers() : MultiMap;

  /**
   * Return the first header value with the specified name
   * @param headerName  the header name
   * @return the header value
   * 
   */
  getHeader(headerName: string) : string | null;

  /**
   *
   * @return the query parameters in the request
   * 
   */
  params() : MultiMap;

  /**
   * Return the first param value with the specified name
   * @param paramName  the param name
   * @return the param value
   * 
   */
  getParam(paramName: string) : string | null;

  /**
   *
   * @return the remote (client side) address of the request
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *
   * @return the local (server side) address of the server that handles the request
   * 
   */
  localAddress() : SocketAddress;

  /**
   *
   * @return the absolute URI corresponding to the the HTTP request
   * 
   */
  absoluteURI() : string;

  /**
   * Convenience method for receiving the entire request body in one piece.
   *  <p>
   *  This saves the user having to manually setting a data and end handler and append the chunks of the body until
   *  the whole body received. Don't use this if your request body is large - you could potentially run out of RAM.
   * @param bodyHandler This handler will be called after all the body has been received
   * 
   */
  bodyHandler(bodyHandler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpServerRequest;

  /**
   * Get a net socket for the underlying connection of this request.
   *  <p/>
   *  This method must be called before the server response is ended.
   *  <p/>
   *  With {@code CONNECT} requests, a {@code 200} response is sent with no {@code content-length} header set
   *  before returning the socket.
   *  <p/>
   *  <pre>
   *  server.requestHandler(req -> {
   *    if (req.method() == HttpMethod.CONNECT) {
   *      // Send a 200 response to accept the connect
   *      NetSocket socket = req.netSocket();
   *      socket.handler(buff -> {
   *        socket.write(buff);
   *      });
   *    }
   *    ...
   *  });
   *  </pre>
   *  <p/>
   *  For other HTTP/1 requests once you have called this method, you must handle writing to the connection yourself using
   *  the net socket, the server request instance will no longer be usable as normal. USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're
   *  doing can easily break the HTTP protocol.
   *  <p/>
   *  With HTTP/2, a {@code 200} response is always sent with no {@code content-length} header set before returning the socket
   *  like in the {@code CONNECT} case above.
   *  <p/>
   * @return the net socket
   * @throws IllegalStateException when the socket can't be created
   * 
   */
  netSocket() : NetSocket;

  /**
   * Call this with true if you are expecting a multi-part body to be submitted in the request.
   *  This must be called before the body of the request has been received
   * @param expect  true - if you are expecting a multi-part body
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setExpectMultipart(expect: boolean) : HttpServerRequest;

  /**
   *
   * @return  true if we are expecting a multi-part body for this request. See {@link #setExpectMultipart}.
   * 
   */
  isExpectMultipart() : boolean;

  /**
   * Set an upload handler. The handler will get notified once a new file upload was received to allow you to deal
   *  with the file upload.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  uploadHandler(uploadHandler: ((res: HttpServerFileUpload) => void) | Handler<HttpServerFileUpload> | null | undefined) : HttpServerRequest;

  /**
   * Returns a map of all form attributes in the request.
   *  <p>
   *  Be aware that the attributes will only be available after the whole body has been received, i.e. after
   *  the request end handler has been called.
   *  <p>
   *  {@link #setExpectMultipart(boolean)} must be called first before trying to get the form attributes.
   * @return the form attributes
   * 
   */
  formAttributes() : MultiMap;

  /**
   * Return the first form attribute value with the specified name
   * @param attributeName  the attribute name
   * @return the attribute value
   * 
   */
  getFormAttribute(attributeName: string) : string | null;

  /**
   * Upgrade the connection to a WebSocket connection.
   *  <p>
   *  This is an alternative way of handling WebSockets and can only be used if no WebSocket handler is set on the
   *  {@code HttpServer}, and can only be used during the upgrade request during the WebSocket handshake.
   * @return the WebSocket
   * @throws IllegalStateException if the current request cannot be upgraded, when it happens an appropriate response
   *                                is sent
   * 
   */
  upgrade() : ServerWebSocket;

  /**
   * Has the request ended? I.e. has the entire request, including the body been read?
   * @return true if ended
   * 
   */
  isEnded() : boolean;

  /**
   * Set a custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
   *  frame. HTTP/2 permits extension of the protocol.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  customFrameHandler(handler: ((res: HttpFrame) => void) | Handler<HttpFrame>) : HttpServerRequest;

  /**
   *
   * @return the {@link HttpConnection} associated with this request
   * 
   */
  connection() : HttpConnection;

  /**
   *
   * @return the priority of the associated HTTP/2 stream for HTTP/2 otherwise {@code null}
   * 
   */
  streamPriority() : StreamPriority;

  /**
   * Set an handler for stream priority changes
   *  <p>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler to be called when stream priority changes
   * 
   */
  streamPriorityHandler(handler: ((res: StreamPriority) => void) | Handler<StreamPriority>) : HttpServerRequest;

  /**
   * Return the first header value with the specified name
   * @param headerName  the header name
   * @return the header value
   * 
   */
  getHeader(headerName: string) : string;

  /**
   *
   * @return SSLSession associated with the underlying socket. Returns null if connection is
   *          not SSL.
   * @see javax.net.ssl.SSLSession
   * 
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

export abstract class HttpServerResponse implements WriteStream<Buffer> {
  /**
   * Same as {@link #end()} but with an {@code handler} called when the operation completes
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : HttpServerResponse;

  write(data: Buffer) : HttpServerResponse;

  /**
   * Same as {@link #write(Buffer)} but with an {@code handler} called when the operation completes
   * 
   */
  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  setWriteQueueMaxSize(maxSize: number) : HttpServerResponse;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   *
   * @return the HTTP status code of the response. The default is {@code 200} representing {@code OK}.
   * 
   */
  getStatusCode() : number;

  /**
   * Set the status code. If the status message hasn't been explicitly set, a default status message corresponding
   *  to the code will be looked-up and used.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setStatusCode(statusCode: number) : HttpServerResponse;

  /**
   *
   * @return the HTTP status message of the response. If this is not specified a default value will be used depending on what
   *  {@link #setStatusCode} has been set to.
   * 
   */
  getStatusMessage() : string;

  /**
   * Set the status message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setStatusMessage(statusMessage: string) : HttpServerResponse;

  /**
   * If {@code chunked} is {@code true}, this response will use HTTP chunked encoding, and each call to write to the body
   *  will correspond to a new HTTP chunk sent on the wire.
   *  <p>
   *  If chunked encoding is used the HTTP header {@code Transfer-Encoding} with a value of {@code Chunked} will be
   *  automatically inserted in the response.
   *  <p>
   *  If {@code chunked} is {@code false}, this response will not use HTTP chunked encoding, and therefore the total size
   *  of any data that is written in the respone body must be set in the {@code Content-Length} header <b>before</b> any
   *  data is written out.
   *  <p>
   *  An HTTP chunked response is typically used when you do not know the total size of the request body up front.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setChunked(chunked: boolean) : HttpServerResponse;

  /**
   *
   * @return is the response chunked?
   * 
   */
  isChunked() : boolean;

  /**
   *
   * @return The HTTP headers
   * 
   */
  headers() : MultiMap;

  /**
   * Put an HTTP header
   * @param name  the header name
   * @param value  the header value.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  putHeader(name: string, value: string) : HttpServerResponse;

  /**
   *
   * @return The HTTP trailers
   * 
   */
  trailers() : MultiMap;

  /**
   * Put an HTTP trailer
   * @param name  the trailer name
   * @param value  the trailer value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  putTrailer(name: string, value: string) : HttpServerResponse;

  /**
   * Set a close handler for the response, this is called when the underlying connection is closed and the response
   *  was still using the connection.
   *  <p>
   *  For HTTP/1.x it is called when the connection is closed before {@code end()} is called, therefore it is not
   *  guaranteed to be called.
   *  <p>
   *  For HTTP/2 it is called when the related stream is closed, and therefore it will be always be called.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   * Set an end handler for the response. This will be called when the response is disposed to allow consistent cleanup
   *  of the response.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   * Write a {@link String} to the response body, encoded using the encoding {@code enc}.
   * @param chunk  the string to write
   * @param enc  the encoding to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(chunk: string, enc: string) : HttpServerResponse;

  /**
   * Same as {@link #write(String, String)} but with an {@code handler} called when the operation completes
   * 
   */
  write(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Write a {@link String} to the response body, encoded in UTF-8.
   * @param chunk  the string to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(chunk: string) : HttpServerResponse;

  /**
   * Same as {@link #write(String)} but with an {@code handler} called when the operation completes
   * 
   */
  write(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Used to write an interim 100 Continue response to signify that the client should send the rest of the request.
   *  Must only be used if the request contains an "Expect:100-Continue" header
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeContinue() : HttpServerResponse;

  /**
   * Same as {@link #end(Buffer)} but writes a String in UTF-8 encoding before ending the response.
   * @param chunk  the string to write before ending the response
   * 
   */
  end(chunk: string) : void;

  /**
   * Same as {@link #end(String)} but with an {@code handler} called when the operation completes
   * 
   */
  end(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link #end(Buffer)} but writes a String with the specified encoding before ending the response.
   * @param chunk  the string to write before ending the response
   * @param enc  the encoding to use
   * 
   */
  end(chunk: string, enc: string) : void;

  /**
   * Same as {@link #end(String, String)} but with an {@code handler} called when the operation completes
   * 
   */
  end(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link #end()} but writes some data to the response body before ending. If the response is not chunked and
   *  no other data has been written then the @code{Content-Length} header will be automatically set.
   * @param chunk  the buffer to write before ending the response
   * 
   */
  end(chunk: Buffer) : void;

  /**
   * Same as {@link #end(Buffer)} but with an {@code handler} called when the operation completes
   * 
   */
  end(chunk: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Ends the response. If no data has been written to the response body,
   *  the actual response won't get written until this method gets called.
   *  <p>
   *  Once the response has ended, it cannot be used any more.
   * 
   */
  end() : void;

  /**
   * Same as {@link #sendFile(String, long)} using offset @code{0} which means starting from the beginning of the file.
   * @param filename  path to the file to serve
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string) : HttpServerResponse;

  /**
   * Same as {@link #sendFile(String, long, long)} using length @code{Long.MAX_VALUE} which means until the end of the
   *  file.
   * @param filename  path to the file to serve
   * @param offset offset to start serving from
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number) : HttpServerResponse;

  /**
   * Ask the OS to stream a file as specified by {@code filename} directly
   *  from disk to the outgoing connection, bypassing userspace altogether
   *  (where supported by the underlying operating system.
   *  This is a very efficient way to serve files.<p>
   *  The actual serve is asynchronous and may not complete until some time after this method has returned.
   * @param filename  path to the file to serve
   * @param offset offset to start serving from
   * @param length the number of bytes to send
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number) : HttpServerResponse;

  /**
   * Like {@link #sendFile(String)} but providing a handler which will be notified once the file has been completely
   *  written to the wire.
   * @param filename path to the file to serve
   * @param resultHandler  handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Like {@link #sendFile(String, long)} but providing a handler which will be notified once the file has been completely
   *  written to the wire.
   * @param filename path to the file to serve
   * @param offset the offset to serve from
   * @param resultHandler  handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Like {@link #sendFile(String, long, long)} but providing a handler which will be notified once the file has been
   *  completely written to the wire.
   * @param filename path to the file to serve
   * @param offset the offset to serve from
   * @param length the length to serve to
   * @param resultHandler  handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Close the underlying TCP connection corresponding to the request.
   * 
   */
  close() : void;

  /**
   *
   * @return has the response already ended?
   * 
   */
  ended() : boolean;

  /**
   *
   * @return has the underlying TCP connection corresponding to the request already been closed?
   * 
   */
  closed() : boolean;

  /**
   *
   * @return have the headers for the response already been written?
   * 
   */
  headWritten() : boolean;

  /**
   * Provide a handler that will be called just before the headers are written to the wire.<p>
   *  This provides a hook allowing you to add any more headers or do any more operations before this occurs.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headersEndHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   * Provides a handler that will be called after the last part of the body is written to the wire.
   *  The handler is called asynchronously of when the response has been received by the client.
   *  This provides a hook allowing you to do more operations once the request has been sent over the wire
   *  such as resource cleanup.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  bodyEndHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   *
   * @return the total number of bytes written for the body of the response.
   * 
   */
  bytesWritten() : number;

  /**
   *
   * @return the id of the stream of this response, {@literal -1} for HTTP/1.x
   * 
   */
  streamId() : number;

  /**
   * Like {@link #push(HttpMethod, String, String, MultiMap, Handler)} with no headers.
   * 
   */
  push(method: HttpMethod, host: string, path: string, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Like {@link #push(HttpMethod, String, String, MultiMap, Handler)} with the host copied from the current request.
   * 
   */
  push(method: HttpMethod, path: string, headers: MultiMap, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Like {@link #push(HttpMethod, String, String, MultiMap, Handler)} with the host copied from the current request.
   * 
   */
  push(method: HttpMethod, path: string, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Push a response to the client.<p/>
   * 
   *  The {@code handler} will be notified with a <i>success</i> when the push can be sent and with
   *  a <i>failure</i> when the client has disabled push or reset the push before it has been sent.<p/>
   * 
   *  The {@code handler} may be queued if the client has reduced the maximum number of streams the server can push
   *  concurrently.<p/>
   * 
   *  Push can be sent only for peer initiated streams and if the response is not ended.
   * @param method the method of the promised request
   * @param host the host of the promised request
   * @param path the path of the promised request
   * @param headers the headers of the promised request
   * @param handler the handler notified when the response can be written
   * @return a reference to this, so the API can be used fluently
   * 
   */
  push(method: HttpMethod, host: string, path: string, headers: MultiMap, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Reset this HTTP/2 stream with the error code {@code 0}.
   * 
   */
  reset() : void;

  /**
   * Reset this HTTP/2 stream with the error {@code code}.
   * @param code the error code
   * 
   */
  reset(code: number) : void;

  /**
   * Write an HTTP/2 frame to the response, allowing to extend the HTTP/2 protocol.<p>
   * 
   *  The frame is sent immediatly and is not subject to flow control.
   * @param type the 8-bit frame type
   * @param flags the 8-bit frame flags
   * @param payload the frame payload
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeCustomFrame(type: number, flags: number, payload: Buffer) : HttpServerResponse;

  /**
   * Like {@link #writeCustomFrame(int, int, Buffer)} but with an {@link HttpFrame}.
   * @param frame the frame to write
   * 
   */
  writeCustomFrame(frame: HttpFrame) : HttpServerResponse;

  /**
   * Sets the priority of the associated stream
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param streamPriority the priority for this request's stream
   * 
   */
  setStreamPriority(streamPriority: StreamPriority) : HttpServerResponse;

  /**
   * Like {@link #putHeader(String, String)} but using CharSequence
   * 
   */
  putHeader(name: string, value: string) : HttpServerResponse;

  /**
   * Like {@link #putHeader(String, String)} but providing multiple values via a String Iterable
   * 
   */
  putHeader(name: string, values: string[]) : HttpServerResponse;

  /**
   * Like {@link #putHeader(String, Iterable)} but with CharSequence Iterable
   * 
   */
  putHeader(name: string, values: string[]) : HttpServerResponse;

  /**
   * Like {@link #putTrailer(String, String)} but using CharSequence
   * 
   */
  putTrailer(name: string, value: string) : HttpServerResponse;

  /**
   * Like {@link #putTrailer(String, String)} but providing multiple values via a String Iterable
   * 
   */
  putTrailer(name: string, values: string[]) : HttpServerResponse;

  /**
   * Like {@link #putTrailer(String, Iterable)} but with CharSequence Iterable
   * 
   */
  putTrailer(name: string, value: string[]) : HttpServerResponse;
}

import { JsonEventType } from './enums';

export abstract class JsonEvent {
  /**
   *
   * @return the type of the event
   * 
   */
  type() : JsonEventType;

  /**
   *
   * @return the name of the field when the event is emitted as a JSON object member
   * 
   */
  fieldName() : string;

  /**
   *
   * @return the json value for {@link JsonEventType#VALUE} events
   * 
   */
  value() : any;

  /**
   *
   * @return true when the JSON value is a number
   * 
   */
  isNumber() : boolean;

  /**
   *
   * @return the {@code Integer} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not an {@code Integer}
   * 
   */
  integerValue() : number;

  /**
   *
   * @return the {@code Long} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Long}
   * 
   */
  longValue() : number;

  /**
   *
   * @return the {@code Float} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Float}
   * 
   */
  floatValue() : number;

  /**
   *
   * @return the {@code Double} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Double}
   * 
   */
  doubleValue() : number;

  /**
   *
   * @return true when the JSON value is a boolean
   * 
   */
  isBoolean() : boolean;

  /**
   *
   * @return the {@code Boolean} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Boolean}
   * 
   */
  booleanValue() : boolean;

  /**
   *
   * @return true when the JSON value is a string
   * 
   */
  isString() : boolean;

  /**
   *
   * @return the string value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a string
   * 
   */
  stringValue() : string;

  /**
   * Return the binary value.
   *  <p>
   *  JSON itself has no notion of a binary, this extension complies to the RFC-7493, so this method assumes there is a
   *  String value with the key and it contains a Base64 encoded binary, which it decodes if found and returns.
   * @return the binary value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a String
   * @throws java.lang.IllegalArgumentException if the String value is not a legal Base64 encoded value
   * 
   */
  binaryValue() : Buffer;

  /**
   *
   * @return true when the JSON value is null
   * 
   */
  isNull() : boolean;

  /**
   *
   * @return true when the JSON value is a JSON object
   * 
   */
  isObject() : boolean;

  /**
   *
   * @return the JSON object value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a JSON object
   * 
   */
  objectValue() : { [key: string]: any };

  /**
   *
   * @return true when the JSON value is a JSON array
   * 
   */
  isArray() : boolean;

  /**
   *
   * @return the JSON array value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a JSON array
   * 
   */
  arrayValue() : any[];

  /**
   * Decodes and returns the current value as the specified {@code type}.
   * @param type the type to decode the value to
   * @return the decoded value
   * 
   */
  mapTo<T>(type: any /* TODO: class */) : T;

  /**
   * Return the {@code Instant} value.
   *  <p>
   *  JSON itself has no notion of a temporal types, this extension complies to the RFC-7493, so this method assumes
   *  there is a String value with the key and it contains an ISO 8601 encoded date and time format
   *  such as "2017-04-03T10:25:41Z", which it decodes if found and returns.
   * @return the {@code Instant} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a String
   * @throws java.time.format.DateTimeParseException if the String value is not a legal ISO 8601 encoded value
   * 
   */
  instantValue() : any /* java.time.Instant */;

  /**
   * Decodes and returns the current value as the specified {@code type}.
   * @param type the type to decode the value to
   * @return the decoded value
   * 
   */
  mapTo<T>(type: any /* com.fasterxml.jackson.core.type.TypeReference<T> */) : T;
}

export abstract class JsonParser implements Handler<Buffer>, ReadStream<JsonEvent> {
  /**
   * Something has happened, so handle it.
   * @param event  the event to handle
   * 
   */
  handle(event: Buffer) : void;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<JsonEvent>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<JsonEvent>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<JsonEvent>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a new {@code JsonParser} instance.
   * 
   */
  static newParser() : JsonParser;

  /**
   * Create a new {@code JsonParser} instance.
   * 
   */
  static newParser(stream: ReadStream<Buffer>) : JsonParser;

  /**
   * Handle a {@code Buffer}, pretty much like calling {@link #handle(Object)}.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  write(buffer: Buffer) : JsonParser;

  /**
   * End the stream, this must be called after all the json stream has been processed.
   * 
   */
  end() : void;

  /**
   * Flip the parser to emit a stream of events for each new json object.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  objectEventMode() : JsonParser;

  /**
   * Flip the parser to emit a single value event for each new json object.
   *  </p>
   *  Json object currently streamed won't be affected.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  objectValueMode() : JsonParser;

  /**
   * Flip the parser to emit a stream of events for each new json array.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  arrayEventMode() : JsonParser;

  /**
   * Flip the parser to emit a single value event for each new json array.
   *  </p>
   *  Json array currently streamed won't be affected.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  arrayValueMode() : JsonParser;

  pause() : JsonParser;

  resume() : JsonParser;

  fetch(amount: number) : JsonParser;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : JsonParser;

  handler(handler: ((res: JsonEvent) => void) | Handler<JsonEvent> | null | undefined) : JsonParser;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : JsonParser;
}

export abstract class LocalMap<K, V> {
  /**
   * Get a value from the map
   * @param key the key
   * @return the value, or null if none
   * 
   */
  get(key: any) : V;

  /**
   * Put an entry in the map
   * @param key   the key
   * @param value the value
   * @return return the old value, or null if none
   * 
   */
  put(key: K, value: V) : V;

  /**
   * Remove an entry from the map
   * @param key the key
   * @return the old value
   * 
   */
  remove(key: any) : V;

  /**
   * Clear all entries in the map
   * 
   */
  clear() : void;

  /**
   * Get the size of the map
   * @return the number of entries in the map
   * 
   */
  size() : number;

  /**
   *
   * @return true if there are zero entries in the map
   * 
   */
  isEmpty() : boolean;

  /**
   * Put the entry only if there is no existing entry for that key
   * @param key   the key
   * @param value the value
   * @return the old value or null, if none
   * 
   */
  putIfAbsent(key: K, value: V) : V;

  /**
   * Remove the entry only if there is an entry with the specified key and value.
   *  <p>
   *  This method is the poyglot version of {@link #remove(Object, Object)}.
   * @param key   the key
   * @param value the value
   * @return true if removed
   * 
   */
  removeIfPresent(key: K, value: V) : boolean;

  /**
   * Replace the entry only if there is an existing entry with the specified key and value.
   *  <p>
   *  This method is the polyglot version of {@link #replace(Object, Object, Object)}.
   * @param key      the key
   * @param oldValue the old value
   * @param newValue the new value
   * @return true if removed
   * 
   */
  replaceIfPresent(key: K, oldValue: V, newValue: V) : boolean;

  /**
   * Replace the entry only if there is an existing entry with the key
   * @param key   the key
   * @param value the new value
   * @return the old value
   * 
   */
  replace(key: K, value: V) : V;

  /**
   * Close and release the map
   * 
   */
  close() : void;

  /**
   * Returns {@code true} if this map contains a mapping for the specified
   *  key.
   * @param key key whose presence in this map is to be tested
   * @return {@code true} if this map contains a mapping for the specified key
   * 
   */
  containsKey(key: any) : boolean;

  /**
   * Returns @{code true} if this map maps one or more keys to the
   *  specified value.
   * @param value value whose presence in this map is to be tested
   * @return @{code true} if this map maps one or more keys to the specified value
   * 
   */
  containsValue(value: any) : boolean;

  /**
   * Returns the value to which the specified key is mapped, or
   *  {@code defaultValue} if this map contains no mapping for the key.
   * @param key          the key whose associated value is to be returned
   * @param defaultValue the default mapping of the key
   * @return the value to which the specified key is mapped, or {@code defaultValue} if this map contains no mapping
   *  for the key
   * 
   */
  getOrDefault(key: any, defaultValue: V) : V;
}

export abstract class Lock {
  /**
   * Release the lock. Once the lock is released another will be able to obtain the lock.
   * 
   */
  release() : void;
}

export interface Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;
}

export abstract class Message<T> {
  /**
   * The address the message was sent to
   * 
   */
  address() : string;

  /**
   * Multi-map of message headers. Can be empty
   * @return  the headers
   * 
   */
  headers() : MultiMap;

  /**
   * The body of the message. Can be null.
   * @return  the body, or null.
   * 
   */
  body() : T;

  /**
   * The reply address. Can be null.
   * @return the reply address, or null, if message was sent without a reply handler.
   * 
   */
  replyAddress() : string | null;

  /**
   * Signals if this message represents a send or publish event.
   * @return true if this is a send.
   * 
   */
  isSend() : boolean;

  /**
   * Reply to this message.
   *  <p>
   *  If the message was sent specifying a reply handler, that handler will be
   *  called when it has received a reply. If the message wasn't sent specifying a receipt handler
   *  this method does nothing.
   * @param message  the message to reply with.
   * 
   */
  reply(message: any) : void;

  /**
   * The same as {@code reply(R message)} but you can specify handler for the reply - i.e.
   *  to receive the reply to the reply.
   * @param message  the message to reply with.
   * @param replyHandler  the reply handler for the reply.
   * 
   */
  reply<R>(message: any, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : void;

  /**
   * Link {@link #reply(Object)} but allows you to specify delivery options for the reply.
   * @param message  the reply message
   * @param options  the delivery options
   * 
   */
  reply(message: any, options: DeliveryOptions) : void;

  /**
   * The same as {@code reply(R message, DeliveryOptions)} but you can specify handler for the reply - i.e.
   *  to receive the reply to the reply.
   * @param message  the reply message
   * @param options  the delivery options
   * @param replyHandler  the reply handler for the reply.
   * 
   */
  reply<R>(message: any, options: DeliveryOptions, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : void;

  /**
   * Signal to the sender that processing of this message failed.
   *  <p>
   *  If the message was sent specifying a result handler
   *  the handler will be called with a failure corresponding to the failure code and message specified here.
   * @param failureCode A failure code to pass back to the sender
   * @param message A message to pass back to the sender
   * 
   */
  fail(failureCode: number, message: string) : void;
}

export abstract class MessageConsumer<T> implements ReadStream<Message<T>> {
  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Message<T>>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Message<T>>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Message<T>>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : MessageConsumer<T>;

  handler(handler: ((res: Message<T>) => void) | Handler<Message<T>> | null | undefined) : MessageConsumer<T>;

  pause() : MessageConsumer<T>;

  resume() : MessageConsumer<T>;

  fetch(amount: number) : MessageConsumer<T>;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : MessageConsumer<T>;

  /**
   *
   * @return a read stream for the body of the message stream.
   * 
   */
  bodyStream() : ReadStream<T>;

  /**
   *
   * @return true if the current consumer is registered
   * 
   */
  isRegistered() : boolean;

  /**
   *
   * @return The address the handler was registered with.
   * 
   */
  address() : string;

  /**
   * Set the number of messages this registration will buffer when this stream is paused. The default
   *  value is <code>1000</code>.
   *  <p>
   *  When a new value is set, buffered messages may be discarded to reach the new value. The most recent
   *  messages will be kept.
   * @param maxBufferedMessages the maximum number of messages that can be buffered
   * @return this registration
   * 
   */
  setMaxBufferedMessages(maxBufferedMessages: number) : MessageConsumer<T>;

  /**
   *
   * @return the maximum number of messages that can be buffered when this stream is paused
   * 
   */
  getMaxBufferedMessages() : number;

  /**
   * Optional method which can be called to indicate when the registration has been propagated across the cluster.
   * @param completionHandler the completion handler
   * 
   */
  completionHandler(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Unregisters the handler which created this registration
   * 
   */
  unregister() : void;

  /**
   * Unregisters the handler which created this registration
   * @param completionHandler the handler called when the unregister is done. For example in a cluster when all nodes of the
   *  event bus have been unregistered.
   * 
   */
  unregister(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

export abstract class MessageProducer<T> implements WriteStream<T> {
  static readonly DEFAULT_WRITE_QUEUE_MAX_SIZE : number;

  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: T) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * This method actually sends a message using the send semantic regardless this producer
   *  is a sender or a publisher.
   * @param message the message to send
   * @return  reference to this for fluency
   * 
   */
  send(message: T) : MessageProducer<T>;

  /**
   * Like {@link #send(Object)} but specifying a {@code replyHandler} that will be called if the recipient
   *  subsequently replies to the message.
   * @param message the message to send
   * @param replyHandler reply handler will be called when any reply from the recipient is received, may be {@code null}
   * @return  reference to this for fluency
   * 
   */
  send<R>(message: T, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : MessageProducer<T>;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : MessageProducer<T>;

  write(data: T) : MessageProducer<T>;

  write(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : MessageProducer<T>;

  setWriteQueueMaxSize(maxSize: number) : MessageProducer<T>;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : MessageProducer<T>;

  /**
   * Update the delivery options of this producer.
   * @param options the new options
   * @return this producer object
   * 
   */
  deliveryOptions(options: DeliveryOptions) : MessageProducer<T>;

  /**
   *
   * @return The address to which the producer produces messages.
   * 
   */
  address() : string;

  /**
   * Closes the producer, calls {@link #close()}
   * 
   */
  end() : void;

  /**
   * Closes the producer, calls {@link #close(Handler)}
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Closes the producer, this method should be called when the message producer is not used anymore.
   * 
   */
  close() : void;

  /**
   * Same as {@link #close()} but with an {@code handler} called when the operation completes
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

export abstract class MultiMap {
  /**
   * Create a multi-map implementation with case insensitive keys, for instance it can be used to hold some HTTP headers.
   * @return the multi-map
   * 
   */
  static caseInsensitiveMultiMap() : MultiMap;

  /**
   * Returns the value of with the specified name.  If there are
   *  more than one values for the specified name, the first value is returned.
   * @param name The name of the header to search
   * @return The first header value or {@code null} if there is no such entry
   * 
   */
  get(name: string) : string | null;

  /**
   * Returns the values with the specified name
   * @param name The name to search
   * @return A immutable {@link java.util.List} of values which will be empty if no values
   *          are found
   * 
   */
  getAll(name: string) : string[];

  /**
   * Checks to see if there is a value with the specified name
   * @param name The name to search for
   * @return true if at least one entry is found
   * 
   */
  contains(name: string) : boolean;

  /**
   * Check if there is a header with the specified {@code name} and {@code value}.
   * 
   *  If {@code caseInsensitive} is {@code true}, {@code value} is compared in a case-insensitive way.
   * @param name the name to search for
   * @param value the value to search for
   * @return {@code true} if at least one entry is found
   * 
   */
  contains(name: string, value: string, caseInsensitive: boolean) : boolean;

  /**
   * Return true if empty
   * 
   */
  isEmpty() : boolean;

  /**
   * Gets a immutable {@link java.util.Set} of all names
   * @return A {@link java.util.Set} of all names
   * 
   */
  names() : string[];

  /**
   * Adds a new value with the specified name and value.
   * @param name The name
   * @param value The value being added
   * @return a reference to this, so the API can be used fluently
   * 
   */
  add(name: string, value: string) : MultiMap;

  /**
   * Adds all the entries from another MultiMap to this one
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAll(map: MultiMap) : MultiMap;

  /**
   * Sets a value under the specified name.
   *  <p>
   *  If there is an existing header with the same name, it is removed.
   * @param name The name
   * @param value The value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  set(name: string, value: string) : MultiMap;

  /**
   * Cleans this instance.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAll(map: MultiMap) : MultiMap;

  /**
   * Removes the value with the given name
   * @param name The name  of the value to remove
   * @return a reference to this, so the API can be used fluently
   * 
   */
  remove(name: string) : MultiMap;

  /**
   * Removes all
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clear() : MultiMap;

  /**
   * Return the number of keys.
   * 
   */
  size() : number;

  get(name: string) : string;

  /**
   * Like {@link #getAll(String)} but accepting a {@code CharSequence} as a parameter
   * 
   */
  getAll(name: string) : string[];

  /**
   * Returns all entries in the multi-map.
   * @return A immutable {@link java.util.List} of the name-value entries, which will be
   *          empty if no pairs are found
   * 
   */
  entries() : any /* java.util.Map.Entry<java.lang.String,java.lang.String> */[];

  /**
   * Like {@link #contains(String)} but accepting a {@code CharSequence} as a parameter
   * 
   */
  contains(name: string) : boolean;

  /**
   * Like {@link #contains(String, String, boolean)} but accepting {@code CharSequence} parameters.
   * 
   */
  contains(name: string, value: string, caseInsensitive: boolean) : boolean;

  /**
   * Like {@link #add(String, String)} but accepting {@code CharSequence} as parameters
   * 
   */
  add(name: string, value: string) : MultiMap;

  /**
   * Adds a new values under the specified name
   * @param name The name being set
   * @param values The values
   * @return a reference to this, so the API can be used fluently
   * 
   */
  add(name: string, values: string[]) : MultiMap;

  /**
   * Like {@link #add(String, Iterable)} but accepting {@code CharSequence} as parameters
   * 
   */
  add(name: string, values: string[]) : MultiMap;

  /**
   * Adds all the entries from a Map to this
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAll(headers: { [key: string]: string; }) : MultiMap;

  /**
   * Like {@link #set(String, String)} but accepting {@code CharSequence} as parameters
   * 
   */
  set(name: string, value: string) : MultiMap;

  /**
   * Sets values for the specified name.
   * @param name The name of the headers being set
   * @param values The values of the headers being set
   * @return a reference to this, so the API can be used fluently
   * 
   */
  set(name: string, values: string[]) : MultiMap;

  /**
   * Like {@link #set(String, Iterable)} but accepting {@code CharSequence} as parameters
   * 
   */
  set(name: string, values: string[]) : MultiMap;

  /**
   * Cleans and set all values of the given instance
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAll(headers: { [key: string]: string; }) : MultiMap;

  /**
   * Like {@link #remove(String)} but accepting {@code CharSequence} as parameters
   * 
   */
  remove(name: string) : MultiMap;
}

export abstract class MxRecord {
  /**
   * The priority of the MX record.
   * 
   */
  priority() : number;

  /**
   * The name of the MX record
   * 
   */
  name() : string;
}

export abstract class NetClient implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Open a connection to a server at the specific {@code port} and {@code host}.
   *  <p>
   *  {@code host} can be a valid host name or IP address. The connect is done asynchronously and on success, a
   *  {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param port  the port
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(port: number, host: string, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Open a connection to a server at the specific {@code port} and {@code host}.
   *  <p>
   *  {@code host} can be a valid host name or IP address. The connect is done asynchronously and on success, a
   *  {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param port the port
   * @param host the host
   * @param serverName the SNI server name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(port: number, host: string, serverName: string, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Open a connection to a server at the specific {@code remoteAddress}.
   *  <p>
   *  The connect is done asynchronously and on success, a {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param remoteAddress the remote address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(remoteAddress: SocketAddress, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Open a connection to a server at the specific {@code remoteAddress}.
   *  <p>
   *  The connect is done asynchronously and on success, a {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param remoteAddress the remote address
   * @param serverName the SNI server name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(remoteAddress: SocketAddress, serverName: string, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Close the client.
   *  <p>
   *  Any sockets which have not been closed manually will be closed here. The close is asynchronous and may not
   *  complete until some time after the method has returned.
   * 
   */
  close() : void;
}

export abstract class NetServer implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Return the connect stream for this server. The server can only have at most one handler at any one time.
   *  As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
   *  connect stream {@link ReadStream#handler(io.vertx.core.Handler)}.
   * @return the connect stream
   * 
   */
  connectStream() : ReadStream<NetSocket>;

  /**
   * Supply a connect handler for this server. The server can only have at most one connect handler at any one time.
   *  As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
   *  connect handler.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectHandler(handler: ((res: NetSocket) => void) | Handler<NetSocket> | null | undefined) : NetServer;

  /**
   * Start listening on the port and host as configured in the {@link io.vertx.core.net.NetServerOptions} used when
   *  creating the server.
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen() : NetServer;

  /**
   * Like {@link #listen} but providing a handler that will be notified when the server is listening, or fails.
   * @param listenHandler  handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Start listening on the specified port and host, ignoring port and host configured in the {@link io.vertx.core.net.NetServerOptions} used when
   *  creating the server.
   *  <p>
   *  Port {@code 0} can be specified meaning "choose an random port".
   *  <p>
   *  Host {@code 0.0.0.0} can be specified meaning "listen on all available interfaces".
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string) : NetServer;

  /**
   * Like {@link #listen(int, String)} but providing a handler that will be notified when the server is listening, or fails.
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @param listenHandler handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string, listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Start listening on the specified port and host "0.0.0.0", ignoring port and host configured in the
   *  {@link io.vertx.core.net.NetServerOptions} used when creating the server.
   *  <p>
   *  Port {@code 0} can be specified meaning "choose an random port".
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number) : NetServer;

  /**
   * Like {@link #listen(int)} but providing a handler that will be notified when the server is listening, or fails.
   * @param port  the port to listen on
   * @param listenHandler handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Start listening on the specified local address, ignoring port and host configured in the {@link io.vertx.core.net.NetServerOptions} used when
   *  creating the server.
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @param localAddress the local address to listen on
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(localAddress: SocketAddress) : NetServer;

  /**
   * Like {@link #listen(SocketAddress)} but providing a handler that will be notified when the server is listening, or fails.
   * @param localAddress the local address to listen on
   * @param listenHandler handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(localAddress: SocketAddress, listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Close the server. This will close any currently open connections. The close may not complete until after this
   *  method has returned.
   * 
   */
  close() : void;

  /**
   * Like {@link #close} but supplying a handler that will be notified when close is complete.
   * @param completionHandler  the handler
   * 
   */
  close(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * The actual port the server is listening on. This is useful if you bound the server specifying 0 as port number
   *  signifying an ephemeral port
   * @return the actual port the server is listening on.
   * 
   */
  actualPort() : number;
}

export abstract class NetSocket implements ReadStream<Buffer>, WriteStream<Buffer> {
  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: Buffer) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : NetSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : NetSocket;

  pause() : NetSocket;

  resume() : NetSocket;

  fetch(amount: number) : NetSocket;

  /**
   * {@inheritDoc}
   *  <p>
   *  This handler might be called after the close handler when the socket is paused and there are still
   *  buffers to deliver.
   * 
   */
  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : NetSocket;

  write(data: Buffer) : NetSocket;

  setWriteQueueMaxSize(maxSize: number) : NetSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : NetSocket;

  /**
   * When a {@code NetSocket} is created it automatically registers an event handler with the event bus, the ID of that
   *  handler is given by {@code writeHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a buffer to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other connections which are owned by different event loops.
   * @return the write handler ID
   * 
   */
  writeHandlerID() : string;

  /**
   * Same as {@link #write(String)} but with an {@code handler} called when the operation completes
   * 
   */
  write(str: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Write a {@link String} to the connection, encoded in UTF-8.
   * @param str  the string to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(str: string) : NetSocket;

  /**
   * Same as {@link #write(String, String)} but with an {@code handler} called when the operation completes
   * 
   */
  write(str: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Write a {@link String} to the connection, encoded using the encoding {@code enc}.
   * @param str  the string to write
   * @param enc  the encoding to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(str: string, enc: string) : NetSocket;

  /**
   * Like {@link #write(Object)} but with an {@code handler} called when the message has been written
   *  or failed to be written.
   * 
   */
  write(message: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Tell the operating system to stream a file as specified by {@code filename} directly from disk to the outgoing connection,
   *  bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   * @param filename  file name of the file to send
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string) : NetSocket;

  /**
   * Tell the operating system to stream a file as specified by {@code filename} directly from disk to the outgoing connection,
   *  bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   * @param filename  file name of the file to send
   * @param offset offset
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number) : NetSocket;

  /**
   * Tell the operating system to stream a file as specified by {@code filename} directly from disk to the outgoing connection,
   *  bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   * @param filename  file name of the file to send
   * @param offset offset
   * @param length length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number) : NetSocket;

  /**
   * Same as {@link #sendFile(String)} but also takes a handler that will be called when the send has completed or
   *  a failure has occurred
   * @param filename  file name of the file to send
   * @param resultHandler  handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Same as {@link #sendFile(String, long)} but also takes a handler that will be called when the send has completed or
   *  a failure has occurred
   * @param filename  file name of the file to send
   * @param offset offset
   * @param resultHandler  handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Same as {@link #sendFile(String, long, long)} but also takes a handler that will be called when the send has completed or
   *  a failure has occurred
   * @param filename  file name of the file to send
   * @param offset offset
   * @param length length
   * @param resultHandler  handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   *
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   * Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   * Calls {@link #end(Handler)}
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the NetSocket
   * 
   */
  close() : void;

  /**
   * Close the NetSocket and notify the {@code handler} when the operation completes.
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Set a handler that will be called when the NetSocket is closed
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : NetSocket;

  /**
   * Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
   * @param handler  the handler will be notified when it's upgraded
   * @return a reference to this, so the API can be used fluently
   * 
   */
  upgradeToSsl(handler: ((res: void) => void) | Handler<void>) : NetSocket;

  /**
   * Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
   * @param serverName the server name
   * @param handler  the handler will be notified when it's upgraded
   * @return a reference to this, so the API can be used fluently
   * 
   */
  upgradeToSsl(serverName: string, handler: ((res: void) => void) | Handler<void>) : NetSocket;

  /**
   *
   * @return true if this {@link io.vertx.core.net.NetSocket} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  /**
   * Returns the SNI server name presented during the SSL handshake by the client.
   * @return the indicated server name
   * 
   */
  indicatedServerName() : string;

  /**
   *
   * @return SSLSession associated with the underlying socket. Returns null if connection is
   *          not SSL.
   * @see javax.net.ssl.SSLSession
   * 
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

export abstract class Pipe<T> {
  /**
   * Set to {@code true} to call {@link WriteStream#end()} when the source {@code ReadStream} fails, {@code false} otherwise.
   * @param end {@code true} to end the stream on a source {@code ReadStream} failure
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endOnFailure(end: boolean) : Pipe<T>;

  /**
   * Set to {@code true} to call {@link WriteStream#end()} when the source {@code ReadStream} succeeds, {@code false} otherwise.
   * @param end {@code true} to end the stream on a source {@code ReadStream} success
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endOnSuccess(end: boolean) : Pipe<T>;

  /**
   * Set to {@code true} to call {@link WriteStream#end()} when the source {@code ReadStream} completes, {@code false} otherwise.
   *  <p>
   *  Calling this overwrites {@link #endOnFailure} and {@link #endOnSuccess}.
   * @param end {@code true} to end the stream on a source {@code ReadStream} completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endOnComplete(end: boolean) : Pipe<T>;

  /**
   * Like {@link #to(WriteStream, Handler)} but without a completion handler
   * 
   */
  to(dst: WriteStream<T>) : void;

  /**
   * Start to pipe the elements to the destination {@code WriteStream}.
   *  <p>
   *  When the operation fails with a write error, the source stream is resumed.
   * @param dst the destination write stream
   * @param completionHandler the handler called when the pipe operation completes
   * 
   */
  to(dst: WriteStream<T>, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the pipe.
   *  <p>
   *  The streams handlers will be unset and the read stream resumed unless it is already ended.
   * 
   */
  close() : void;
}

export abstract class Pump {
  /**
   * Create a new {@code Pump} with the given {@code ReadStream} and {@code WriteStream}
   * @param rs  the read stream
   * @param ws  the write stream
   * @return the pump
   * 
   */
  static pump<T>(rs: ReadStream<T>, ws: WriteStream<T>) : Pump;

  /**
   * Create a new {@code Pump} with the given {@code ReadStream} and {@code WriteStream} and
   *  {@code writeQueueMaxSize}
   * @param rs  the read stream
   * @param ws  the write stream
   * @param writeQueueMaxSize  the max size of the write queue
   * @return the pump
   * 
   */
  static pump<T>(rs: ReadStream<T>, ws: WriteStream<T>, writeQueueMaxSize: number) : Pump;

  /**
   * Set the write queue max size to {@code maxSize}
   * @param maxSize  the max size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWriteQueueMaxSize(maxSize: number) : Pump;

  /**
   * Start the Pump. The Pump can be started and stopped multiple times.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  start() : Pump;

  /**
   * Stop the Pump. The Pump can be started and stopped multiple times.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  stop() : Pump;

  /**
   * Return the total number of items pumped by this pump.
   * 
   */
  numberPumped() : number;
}

export interface ReadStream<T> extends StreamBase {
  /**
   * Set an exception handler on the read stream.
   * @param handler  the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : ReadStream<T>;

  /**
   * Set a data handler. As data is read, the handler will be called with the data.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  handler(handler: ((res: T) => void) | Handler<T> | null | undefined) : ReadStream<T>;

  /**
   * Pause the {@code ReadStream}, it sets the buffer in {@code fetch} mode and clears the actual demand.
   *  <p>
   *  While it's paused, no data will be sent to the data {@code handler}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pause() : ReadStream<T>;

  /**
   * Resume reading, and sets the buffer in {@code flowing} mode.
   *  <p/>
   *  If the {@code ReadStream} has been paused, reading will recommence on it.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  resume() : ReadStream<T>;

  /**
   * Fetch the specified {@code amount} of elements. If the {@code ReadStream} has been paused, reading will
   *  recommence with the specified {@code amount} of items, otherwise the specified {@code amount} will
   *  be added to the current stream demand.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  fetch(amount: number) : ReadStream<T>;

  /**
   * Set an end handler. Once the stream has ended, and there is no more data to be read, this handler will be called.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : ReadStream<T>;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<T>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<T>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<T>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

export abstract class RecordParser implements Handler<Buffer>, ReadStream<Buffer> {
  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  setOutput(output: ((res: Buffer) => void) | Handler<Buffer>) : void;

  /**
   * Like {@link #newDelimited(String)} but set the {@code output} that will receive whole records
   *  which have been parsed.
   * @param delim  the initial delimiter string
   * @param output  handler that will receive the output
   * 
   */
  static newDelimited(delim: string, output: ((res: Buffer) => void) | Handler<Buffer>) : RecordParser;

  /**
   * Like {@link #newDelimited(String)} but wraps the {@code stream}. The {@code stream} handlers will be set/unset
   *  when the {@link #handler(Handler)} is set.
   *  <p/>
   *  The {@code pause()}/{@code resume()} operations are propagated to the {@code stream}.
   * @param delim  the initial delimiter string
   * @param stream  the wrapped stream
   * 
   */
  static newDelimited(delim: string, stream: ReadStream<Buffer>) : RecordParser;

  /**
   * Create a new {@code RecordParser} instance, initially in delimited mode, and where the delimiter can be represented
   *  by the String {@code} delim endcoded in latin-1 . Don't use this if your String contains other than latin-1 characters.
   *  <p>
   *  {@code output} Will receive whole records which have been parsed.
   * @param delim  the initial delimiter string
   * 
   */
  static newDelimited(delim: string) : RecordParser;

  /**
   * Create a new {@code RecordParser} instance, initially in delimited mode, and where the delimiter can be represented
   *  by the {@code Buffer} delim.
   *  <p>
   * @param delim  the initial delimiter buffer
   * 
   */
  static newDelimited(delim: Buffer) : RecordParser;

  /**
   * Like {@link #newDelimited(Buffer)} but set the {@code output} that will receive whole records
   *  which have been parsed.
   * @param delim  the initial delimiter buffer
   * @param output  handler that will receive the output
   * 
   */
  static newDelimited(delim: Buffer, output: ((res: Buffer) => void) | Handler<Buffer>) : RecordParser;

  /**
   * Like {@link #newDelimited(Buffer)} but wraps the {@code stream}. The {@code stream} handlers will be set/unset
   *  when the {@link #handler(Handler)} is set.
   *  <p/>
   *  The {@code pause()}/{@code resume()} operations are propagated to the {@code stream}.
   * @param delim  the initial delimiter buffer
   * @param stream  the wrapped stream
   * 
   */
  static newDelimited(delim: Buffer, stream: ReadStream<Buffer>) : RecordParser;

  /**
   * Create a new {@code RecordParser} instance, initially in fixed size mode, and where the record size is specified
   *  by the {@code size} parameter.
   *  <p>
   *  {@code output} Will receive whole records which have been parsed.
   * @param size  the initial record size
   * 
   */
  static newFixed(size: number) : RecordParser;

  /**
   * Like {@link #newFixed(int)} but set the {@code output} that will receive whole records
   *  which have been parsed.
   * @param size  the initial record size
   * @param output  handler that will receive the output
   * 
   */
  static newFixed(size: number, output: ((res: Buffer) => void) | Handler<Buffer>) : RecordParser;

  /**
   * Like {@link #newFixed(int)} but wraps the {@code stream}. The {@code stream} handlers will be set/unset
   *  when the {@link #handler(Handler)} is set.
   *  <p/>
   *  The {@code pause()}/{@code resume()} operations are propagated to the {@code stream}.
   * @param size  the initial record size
   * @param stream  the wrapped stream
   * 
   */
  static newFixed(size: number, stream: ReadStream<Buffer>) : RecordParser;

  /**
   * Flip the parser into delimited mode, and where the delimiter can be represented
   *  by the String {@code delim} encoded in latin-1 . Don't use this if your String contains other than latin-1 characters.
   *  <p>
   *  This method can be called multiple times with different values of delim while data is being parsed.
   * @param delim  the new delimeter
   * 
   */
  delimitedMode(delim: string) : void;

  /**
   * Flip the parser into delimited mode, and where the delimiter can be represented
   *  by the delimiter {@code delim}.
   *  <p>
   *  This method can be called multiple times with different values of delim while data is being parsed.
   * @param delim  the new delimiter
   * 
   */
  delimitedMode(delim: Buffer) : void;

  /**
   * Flip the parser into fixed size mode, where the record size is specified by {@code size} in bytes.
   *  <p>
   *  This method can be called multiple times with different values of size while data is being parsed.
   * @param size  the new record size
   * 
   */
  fixedSizeMode(size: number) : void;

  /**
   * Set the maximum allowed size for a record when using the delimited mode.
   *  The delimiter itself does not count for the record size.
   *  <p>
   *  If a record is longer than specified, an {@link IllegalStateException} will be thrown.
   * @param size the maximum record size
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  maxRecordSize(size: number) : RecordParser;

  /**
   * This method is called to provide the parser with data.
   * @param buffer  a chunk of data
   * 
   */
  handle(buffer: Buffer) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : RecordParser;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : RecordParser;

  pause() : RecordParser;

  fetch(amount: number) : RecordParser;

  resume() : RecordParser;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : RecordParser;
}

import { PemKeyCertOptions } from './options';
import { PemTrustOptions } from './options';

export abstract class SelfSignedCertificate {
  /**
   * Provides the {@link KeyCertOptions} RSA private key file in PEM format corresponding to the {@link #privateKeyPath()}
   * @return a {@link PemKeyCertOptions} based on the generated certificate.
   * 
   */
  keyCertOptions() : PemKeyCertOptions;

  /**
   * Provides the {@link TrustOptions} X.509 certificate file in PEM format corresponding to the {@link #certificatePath()}
   * @return a {@link PemTrustOptions} based on the generated certificate.
   * 
   */
  trustOptions() : PemTrustOptions;

  /**
   * Filesystem path to the RSA private key file in PEM format
   * @return the absolute path to the private key.
   * 
   */
  privateKeyPath() : string;

  /**
   * Filesystem path to the X.509 certificate file in PEM format .
   * @return the absolute path to the certificate.
   * 
   */
  certificatePath() : string;

  /**
   * Delete the private key and certificate files.
   * 
   */
  delete() : void;

  /**
   * Create a new {@code SelfSignedCertificate} instance.
   * @return a new instance.
   * 
   */
  static create() : SelfSignedCertificate;

  /**
   * Create a new {@code SelfSignedCertificate} instance with a fully-qualified domain name,
   * @param fqdn a fully qualified domain name.
   * @return a new instance.
   * 
   */
  static create(fqdn: string) : SelfSignedCertificate;
}

export abstract class ServerWebSocket implements WebSocketBase {
  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: Buffer) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * When a {@code WebSocket} is created it automatically registers an event handler with the event bus - the ID of that
   *  handler is given by this method.
   *  <p>
   *  Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * @return the binary handler id
   * 
   */
  binaryHandlerID() : string;

  /**
   * When a {@code WebSocket} is created it automatically registers an event handler with the eventbus, the ID of that
   *  handler is given by {@code textHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * 
   */
  textHandlerID() : string;

  /**
   * Returns the WebSocket sub protocol selected by the WebSocket handshake.
   *  <p/>
   *  On the server, the value will be {@code null} when the handler receives the websocket callback as the
   *  handshake will not be completed yet.
   * 
   */
  subProtocol() : string;

  /**
   * Writes a ping frame to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   *  <p>
   *  There is no handler for ping frames because RFC 6455  clearly
   *  states that the only response to a ping frame is a pong frame with identical contents.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   * Writes a pong frame to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   *  <p>
   *  There is no need to manually write a pong frame, as the server and client both handle responding to a ping from with a pong from
   *  automatically and this is exposed to users. RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> states that pongs may be sent unsolicited in order
   *  to implement a one way heartbeat.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   * Set a text message handler on the connection. This handler will be called similar to the
   *  {@link #binaryMessageHandler(Handler)}, but the buffer will be converted to a String first
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textMessageHandler(handler: ((res: string) => void) | Handler<string> | null | undefined) : WebSocketBase;

  /**
   * Set a binary message handler on the connection. This handler serves a similar purpose to {@link #handler(Handler)}
   *  except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   *  into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal()} to find the boundaries).
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryMessageHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Set a pong frame handler on the connection.  This handler will be invoked every time a pong frame is received
   *  on the server, and can be used by both clients and servers since the RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> do not
   *  specify whether the client or server sends a ping.
   *  <p>
   *  Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  There is no ping handler since ping frames should immediately be responded to with a pong frame with identical content
   *  <p>
   *  Pong frames may be received unsolicited.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pongHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   * Calls {@link #close(Handler)}
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link #close()} but with an {@code handler} called when the operation completes
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending a close frame with specified status code. You can give a look at various close payloads
   *  here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   *  <p/>
   *  No more messages can be sent.
   * @param statusCode Status code
   * 
   */
  close(statusCode: number) : void;

  /**
   * Same as {@link #close(short)} but with an {@code handler} called when the operation completes
   * 
   */
  close(statusCode: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads
   *  here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   *  <p/>
   *  No more messages can be sent.
   * @param statusCode Status code
   * @param reason reason of closure
   * 
   */
  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * Same as {@link #close(short, String)} but with an {@code handler} called when the operation completes
   * 
   */
  close(statusCode: number, reason: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   *
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   *
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : ServerWebSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : ServerWebSocket;

  pause() : ServerWebSocket;

  resume() : ServerWebSocket;

  fetch(amount: number) : ServerWebSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : ServerWebSocket;

  write(data: Buffer) : ServerWebSocket;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  setWriteQueueMaxSize(maxSize: number) : ServerWebSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : ServerWebSocket;

  writeFrame(frame: WebSocketFrame) : ServerWebSocket;

  writeFrame(frame: WebSocketFrame, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeFinalTextFrame(text: string) : ServerWebSocket;

  writeFinalTextFrame(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeFinalBinaryFrame(data: Buffer) : ServerWebSocket;

  writeFinalBinaryFrame(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeBinaryMessage(data: Buffer) : ServerWebSocket;

  writeBinaryMessage(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeTextMessage(text: string) : ServerWebSocket;

  writeTextMessage(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : ServerWebSocket;

  frameHandler(handler: ((res: WebSocketFrame) => void) | Handler<WebSocketFrame> | null | undefined) : ServerWebSocket;

  uri() : string;

  /**
   *
   * @return the WebSocket handshake path.
   * 
   */
  path() : string;

  /**
   *
   * @return the WebSocket handshake query string.
   * 
   */
  query() : string | null;

  /**
   *
   * @return the headers in the WebSocket handshake
   * 
   */
  headers() : MultiMap;

  /**
   * Accept the WebSocket and terminate the WebSocket handshake.
   *  <p/>
   *  This method should be called from the WebSocket handler to explicitly accept the WebSocket and
   *  terminate the WebSocket handshake.
   * @throws IllegalStateException when the WebSocket handshake is already set
   * 
   */
  accept() : void;

  /**
   * Reject the WebSocket.
   *  <p>
   *  Calling this method from the WebSocket handler when it is first passed to you gives you the opportunity to reject
   *  the WebSocket, which will cause the WebSocket handshake to fail by returning
   *  a {@literal 502} response code.
   *  <p>
   *  You might use this method, if for example you only want to accept WebSockets with a particular path.
   * @throws IllegalStateException when the WebSocket handshake is already set
   * 
   */
  reject() : void;

  /**
   * Like {@link #reject()} but with a {@code status}.
   * 
   */
  reject(status: number) : void;

  /**
   * Set an asynchronous result for the handshake, upon completion of the specified {@code future}, the
   *  WebSocket will either be
   * 
   *  <ul>
   *    <li>accepted when the {@code future} succeeds with the HTTP {@literal 101} status code</li>
   *    <li>rejected when the {@code future} is succeeds with an HTTP status code different than {@literal 101}</li>
   *    <li>rejected when the {@code future} fails with the HTTP status code {@code 500}</li>
   *  </ul>
   * 
   *  The provided future might be completed by the WebSocket itself, e.g calling the {@link #close()} method
   *  will try to accept the handshake and close the WebSocket afterward. Thus it is advised to try to complete
   *  the {@code future} with {@link Future#tryComplete} or {@link Future#tryFail}.
   *  <p>
   *  This method should be called from the WebSocket handler to explicitly set an asynchronous handshake.
   *  <p>
   *  Calling this method will override the {@code future} completion handler.
   * @param future the future to complete with
   * @throws IllegalStateException when the WebSocket has already an asynchronous result
   * 
   */
  setHandshake(future: Future<number>) : void;

  /**
   * {@inheritDoc}
   * 
   *  <p>
   *  The WebSocket handshake will be accepted when it hasn't yet been settled or when an asynchronous handshake
   *  is in progress.
   * 
   */
  close() : void;

  /**
   *
   * @return SSLSession associated with the underlying socket. Returns null if connection is
   *          not SSL.
   * @see javax.net.ssl.SSLSession
   * 
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

export abstract class SharedData {
  /**
   * Get the cluster wide map with the specified name. The map is accessible to all nodes in the cluster and data
   *  put into the map from any node is visible to to any other node.
   * @param name  the name of the map
   * @param resultHandler  the map will be returned asynchronously in this handler
   * @throws IllegalStateException if the parent {@link io.vertx.core.Vertx} instance is not clustered
   * 
   */
  getClusterWideMap<K, V>(name: string, resultHandler: ((res: AsyncResult<AsyncMap<K, V>>) => void) | Handler<AsyncResult<AsyncMap<K, V>>>) : void;

  /**
   * Get the {@link AsyncMap} with the specified name. When clustered, the map is accessible to all nodes in the cluster
   *  and data put into the map from any node is visible to to any other node.
   *  <p>
   *    <strong>WARNING</strong>: In clustered mode, asynchronous shared maps rely on distributed data structures provided by the cluster manager.
   *    Beware that the latency relative to asynchronous shared maps operations can be much higher in clustered than in local mode.
   *  </p>
   * @param name the name of the map
   * @param resultHandler the map will be returned asynchronously in this handler
   * 
   */
  getAsyncMap<K, V>(name: string, resultHandler: ((res: AsyncResult<AsyncMap<K, V>>) => void) | Handler<AsyncResult<AsyncMap<K, V>>>) : void;

  /**
   * Get the {@link AsyncMap} with the specified name.
   *  <p>
   *  When clustered, the map is <b>NOT</b> accessible to all nodes in the cluster.
   *  Only the instance which created the map can put and retrieve data from this map.
   * @param name the name of the map
   * @param resultHandler the map will be returned asynchronously in this handler
   * 
   */
  getLocalAsyncMap<K, V>(name: string, resultHandler: ((res: AsyncResult<AsyncMap<K, V>>) => void) | Handler<AsyncResult<AsyncMap<K, V>>>) : void;

  /**
   * Get an asynchronous lock with the specified name. The lock will be passed to the handler when it is available.
   *  <p>
   *    In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *    even from a single thread, can happen in non-sequential order.
   *  </p>
   * @param name  the name of the lock
   * @param resultHandler  the handler
   * 
   */
  getLock(name: string, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Like {@link #getLock(String, Handler)} but specifying a timeout. If the lock is not obtained within the timeout
   *  a failure will be sent to the handler.
   *  <p>
   *    In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *    even from a single thread, can happen in non-sequential order.
   *  </p>
   * @param name  the name of the lock
   * @param timeout  the timeout in ms
   * @param resultHandler  the handler
   * 
   */
  getLockWithTimeout(name: string, timeout: number, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Get an asynchronous local lock with the specified name. The lock will be passed to the handler when it is available.
   *  <p>
   *    In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *    even from a single thread, can happen in non-sequential order.
   *  </p>
   * @param name  the name of the lock
   * @param resultHandler  the handler
   * 
   */
  getLocalLock(name: string, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Like {@link #getLocalLock(String, Handler)} but specifying a timeout. If the lock is not obtained within the timeout
   *  a failure will be sent to the handler.
   *  <p>
   *    In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *    even from a single thread, can happen in non-sequential order.
   *  </p>
   * @param name  the name of the lock
   * @param timeout  the timeout in ms
   * @param resultHandler  the handler
   * 
   */
  getLocalLockWithTimeout(name: string, timeout: number, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Get an asynchronous counter. The counter will be passed to the handler.
   * @param name  the name of the counter.
   * @param resultHandler  the handler
   * 
   */
  getCounter(name: string, resultHandler: ((res: AsyncResult<Counter>) => void) | Handler<AsyncResult<Counter>>) : void;

  /**
   * Get an asynchronous local counter. The counter will be passed to the handler.
   * @param name  the name of the counter.
   * @param resultHandler  the handler
   * 
   */
  getLocalCounter(name: string, resultHandler: ((res: AsyncResult<Counter>) => void) | Handler<AsyncResult<Counter>>) : void;

  /**
   * Return a {@code LocalMap} with the specific {@code name}.
   * @param name  the name of the map
   * @return the msp
   * 
   */
  getLocalMap<K, V>(name: string) : LocalMap<K, V>;
}

export abstract class SocketAddress {
  /**
   * Create a inet socket address, {@code host} must be non {@code null} and {@code port} must be between {@code 0}
   *  and {@code 65536}.
   * @param port the address port
   * @param host the address host
   * @return the created socket address
   * 
   */
  static inetSocketAddress(port: number, host: string) : SocketAddress;

  /**
   * Create a domain socket address.
   * @param path the address path
   * @return the created socket address
   * 
   */
  static domainSocketAddress(path: string) : SocketAddress;

  /**
   *
   * @return the address host or {@code null} for a domain socket
   * 
   */
  host() : string;

  /**
   *
   * @return the address port or {@code -1} for a domain socket
   * 
   */
  port() : number;

  /**
   *
   * @return the address path or {@code null} for a inet socket
   * 
   */
  path() : string;
}

export abstract class SrvRecord {
  /**
   * Returns the priority for this service record.
   * 
   */
  priority() : number;

  /**
   * Returns the weight of this service record.
   * 
   */
  weight() : number;

  /**
   * Returns the port the service is running on.
   * 
   */
  port() : number;

  /**
   * Returns the name for the server being queried.
   * 
   */
  name() : string;

  /**
   * Returns the protocol for the service being queried (i.e. "_tcp").
   * 
   */
  protocol() : string;

  /**
   * Returns the service's name (i.e. "_http").
   * 
   */
  service() : string;

  /**
   * Returns the name of the host for the service.
   * 
   */
  target() : string | null;
}

export interface StreamBase {
  /**
   * Set an exception handler.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : StreamBase;
}

export abstract class TimeoutStream implements ReadStream<number> {
  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<number>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<number>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<number>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : TimeoutStream;

  handler(handler: ((res: number) => void) | Handler<number> | null | undefined) : TimeoutStream;

  pause() : TimeoutStream;

  resume() : TimeoutStream;

  fetch(amount: number) : TimeoutStream;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : TimeoutStream;

  /**
   * Cancels the timeout. Note this has the same effect as calling {@link #handler(Handler)} with a null
   *  argument.
   * 
   */
  cancel() : void;
}

import { NetServerOptions } from './options';
import { DeploymentOptions } from './options';
import { DnsClientOptions } from './options';
import { VertxOptions } from './options';
import { HttpServerOptions } from './options';
import { HttpClientOptions } from './options';
import { DatagramSocketOptions } from './options';
import { NetClientOptions } from './options';

export abstract class Vertx implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Creates a non clustered instance using default options.
   * @return the instance
   * 
   */
  static vertx() : Vertx;

  /**
   * Creates a non clustered instance using the specified options
   * @param options  the options to use
   * @return the instance
   * 
   */
  static vertx(options: VertxOptions) : Vertx;

  /**
   * Creates a clustered instance using the specified options.
   *  <p>
   *  The instance is created asynchronously and the resultHandler is called with the result when it is ready.
   * @param options  the options to use
   * @param resultHandler  the result handler that will receive the result
   * 
   */
  static clusteredVertx(options: VertxOptions, resultHandler: ((res: AsyncResult<Vertx>) => void) | Handler<AsyncResult<Vertx>>) : void;

  /**
   * Gets the current context
   * @return The current context or null if no current context
   * 
   */
  static currentContext() : Context | null;

  /**
   * Gets the current context, or creates one if there isn't one
   * @return The current context (created if didn't exist)
   * 
   */
  getOrCreateContext() : Context;

  /**
   * Create a TCP/SSL server using the specified options
   * @param options  the options to use
   * @return the server
   * 
   */
  createNetServer(options: NetServerOptions) : NetServer;

  /**
   * Create a TCP/SSL server using default options
   * @return the server
   * 
   */
  createNetServer() : NetServer;

  /**
   * Create a TCP/SSL client using the specified options
   * @param options  the options to use
   * @return the client
   * 
   */
  createNetClient(options: NetClientOptions) : NetClient;

  /**
   * Create a TCP/SSL client using default options
   * @return the client
   * 
   */
  createNetClient() : NetClient;

  /**
   * Create an HTTP/HTTPS server using the specified options
   * @param options  the options to use
   * @return the server
   * 
   */
  createHttpServer(options: HttpServerOptions) : HttpServer;

  /**
   * Create an HTTP/HTTPS server using default options
   * @return the server
   * 
   */
  createHttpServer() : HttpServer;

  /**
   * Create a HTTP/HTTPS client using the specified options
   * @param options  the options to use
   * @return the client
   * 
   */
  createHttpClient(options: HttpClientOptions) : HttpClient;

  /**
   * Create a HTTP/HTTPS client using default options
   * @return the client
   * 
   */
  createHttpClient() : HttpClient;

  /**
   * Create a datagram socket using the specified options
   * @param options  the options to use
   * @return the socket
   * 
   */
  createDatagramSocket(options: DatagramSocketOptions) : DatagramSocket;

  /**
   * Create a datagram socket using default options
   * @return the socket
   * 
   */
  createDatagramSocket() : DatagramSocket;

  /**
   * Get the filesystem object. There is a single instance of FileSystem per Vertx instance.
   * @return the filesystem object
   * 
   */
  fileSystem() : FileSystem;

  /**
   * Get the event bus object. There is a single instance of EventBus per Vertx instance.
   * @return the event bus object
   * 
   */
  eventBus() : EventBus;

  /**
   * Create a DNS client to connect to a DNS server at the specified host and port, with the default query timeout (5 seconds)
   *  <p/>
   * @param port  the port
   * @param host  the host
   * @return the DNS client
   * 
   */
  createDnsClient(port: number, host: string) : DnsClient;

  /**
   * Create a DNS client to connect to the DNS server configured by {@link VertxOptions#getAddressResolverOptions()}
   *  <p>
   *  DNS client takes the first configured resolver address provided by {@link DnsResolverProvider#nameServerAddresses()}}
   * @return the DNS client
   * 
   */
  createDnsClient() : DnsClient;

  /**
   * Create a DNS client to connect to a DNS server
   * @param options the client options
   * @return the DNS client
   * 
   */
  createDnsClient(options: DnsClientOptions) : DnsClient;

  /**
   * Get the shared data object. There is a single instance of SharedData per Vertx instance.
   * @return the shared data object
   * 
   */
  sharedData() : SharedData;

  /**
   * Set a one-shot timer to fire after {@code delay} milliseconds, at which point {@code handler} will be called with
   *  the id of the timer.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @param handler  the handler that will be called with the timer ID when the timer fires
   * @return the unique ID of the timer
   * 
   */
  setTimer(delay: number, handler: ((res: number) => void) | Handler<number>) : number;

  /**
   * Returns a one-shot timer as a read stream. The timer will be fired after {@code delay} milliseconds after
   *  the {@link ReadStream#handler} has been called.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @return the timer stream
   * 
   */
  timerStream(delay: number) : TimeoutStream;

  /**
   * Set a periodic timer to fire every {@code delay} milliseconds, at which point {@code handler} will be called with
   *  the id of the timer.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @param handler  the handler that will be called with the timer ID when the timer fires
   * @return the unique ID of the timer
   * 
   */
  setPeriodic(delay: number, handler: ((res: number) => void) | Handler<number>) : number;

  /**
   * Returns a periodic timer as a read stream. The timer will be fired every {@code delay} milliseconds after
   *  the {@link ReadStream#handler} has been called.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @return the periodic stream
   * 
   */
  periodicStream(delay: number) : TimeoutStream;

  /**
   * Cancels the timer with the specified {@code id}.
   * @param id  The id of the timer to cancel
   * @return true if the timer was successfully cancelled, or false if the timer does not exist.
   * 
   */
  cancelTimer(id: number) : boolean;

  /**
   * Puts the handler on the event queue for the current context so it will be run asynchronously ASAP after all
   *  preceeding events have been handled.
   * @param action - a handler representing the action to execute
   * 
   */
  runOnContext(action: ((res: void) => void) | Handler<void>) : void;

  /**
   * Stop the the Vertx instance and release any resources held by it.
   *  <p>
   *  The instance cannot be used after it has been closed.
   *  <p>
   *  The actual close is asynchronous and may not complete until after the call has returned.
   * 
   */
  close() : void;

  /**
   * Like {@link #close} but the completionHandler will be called when the close is complete
   * @param completionHandler  The handler will be notified when the close is complete.
   * 
   */
  close(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Deploy a verticle instance given a name.
   *  <p>
   *  Given the name, Vert.x selects a {@link VerticleFactory} instance to use to instantiate the verticle.
   *  <p>
   *  For the rules on how factories are selected please consult the user manual.
   * @param name  the name.
   * 
   */
  deployVerticle(name: string) : void;

  /**
   * Like {@link #deployVerticle(String)} but the completionHandler will be notified when the deployment is complete.
   *  <p>
   *  If the deployment is successful the result will contain a String representing the unique deployment ID of the
   *  deployment.
   *  <p>
   *  This deployment ID can subsequently be used to undeploy the verticle.
   * @param name  The identifier
   * @param completionHandler  a handler which will be notified when the deployment is complete
   * 
   */
  deployVerticle(name: string, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Like {@link #deployVerticle(Verticle)} but {@link io.vertx.core.DeploymentOptions} are provided to configure the
   *  deployment.
   * @param name  the name
   * @param options  the deployment options.
   * 
   */
  deployVerticle(name: string, options: DeploymentOptions) : void;

  /**
   * Like {@link #deployVerticle(String, Handler)} but {@link io.vertx.core.DeploymentOptions} are provided to configure the
   *  deployment.
   * @param name  the name
   * @param options  the deployment options.
   * @param completionHandler  a handler which will be notified when the deployment is complete
   * 
   */
  deployVerticle(name: string, options: DeploymentOptions, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Undeploy a verticle deployment.
   *  <p>
   *  The actual undeployment happens asynchronously and may not complete until after the method has returned.
   * @param deploymentID  the deployment ID
   * 
   */
  undeploy(deploymentID: string) : void;

  /**
   * Like {@link #undeploy(String) } but the completionHandler will be notified when the undeployment is complete.
   * @param deploymentID  the deployment ID
   * @param completionHandler  a handler which will be notified when the undeployment is complete
   * 
   */
  undeploy(deploymentID: string, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Return a Set of deployment IDs for the currently deployed deploymentIDs.
   * @return Set of deployment IDs
   * 
   */
  deploymentIDs() : string[];

  /**
   * Is this Vert.x instance clustered?
   * @return true if clustered
   * 
   */
  isClustered() : boolean;

  /**
   * Safely execute some blocking code.
   *  <p>
   *  Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
   *  <p>
   *  When the code is complete the handler {@code resultHandler} will be called with the result on the original context
   *  (e.g. on the original event loop of the caller).
   *  <p>
   *  A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
   *  the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
   *  method if it failed.
   *  <p>
   *  In the {@code blockingCodeHandler} the current context remains the original context and therefore any task
   *  scheduled in the {@code blockingCodeHandler} will be executed on the this context and not on the worker thread.
   *  <p>
   *  The blocking code should block for a reasonable amount of time (i.e no more than a few seconds). Long blocking operations
   *  or polling operations (i.e a thread that spin in a loop polling events in a blocking fashion) are precluded.
   *  <p>
   *  When the blocking operation lasts more than the 10 seconds, a message will be printed on the console by the
   *  blocked thread checker.
   *  <p>
   *  Long blocking operations should use a dedicated thread managed by the application, which can interact with
   *  verticles using the event-bus or {@link Context#runOnContext(Handler)}
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param ordered  if true then if executeBlocking is called several times on the same context, the executions
   *                  for that context will be executed serially, not in parallel. if false then they will be no ordering
   *                  guarantees
   * @param <T> the type of the result
   * 
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Future<T>) => void) | Handler<Future<T>>, ordered: boolean, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Like {@link #executeBlocking(Handler, boolean, Handler)} called with ordered = true.
   * 
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Future<T>) => void) | Handler<Future<T>>, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Like {@link #createSharedWorkerExecutor(String, int)} but with the {@link VertxOptions#setWorkerPoolSize} {@code poolSize}.
   * 
   */
  createSharedWorkerExecutor(name: string) : WorkerExecutor;

  /**
   * Like {@link #createSharedWorkerExecutor(String, int, long)} but with the {@link VertxOptions#setMaxWorkerExecuteTime} {@code maxExecuteTime}.
   * 
   */
  createSharedWorkerExecutor(name: string, poolSize: number) : WorkerExecutor;

  /**
   * Like {@link #createSharedWorkerExecutor(String, int, long, TimeUnit)} but with the {@link TimeUnit#NANOSECONDS ns unit}.
   * 
   */
  createSharedWorkerExecutor(name: string, poolSize: number, maxExecuteTime: number) : WorkerExecutor;

  /**
   * Create a named worker executor, the executor should be closed when it's not needed anymore to release
   *  resources.<p/>
   * 
   *  This method can be called mutiple times with the same {@code name}. Executors with the same name will share
   *  the same worker pool. The worker pool size , max execute time and unit of max execute time are set when the worker pool is created and
   *  won't change after.<p>
   * 
   *  The worker pool is released when all the {@link WorkerExecutor} sharing the same name are closed.
   * @param name the name of the worker executor
   * @param poolSize the size of the pool
   * @param maxExecuteTime the value of max worker execute time
   * @param maxExecuteTimeUnit the value of unit of max worker execute time
   * @return the named worker executor
   * 
   */
  createSharedWorkerExecutor(name: string, poolSize: number, maxExecuteTime: number, maxExecuteTimeUnit: any) : WorkerExecutor;

  /**
   *
   * @return whether the native transport is used
   * 
   */
  isNativeTransportEnabled() : boolean;

  /**
   * Set a default exception handler for {@link Context}, set on {@link Context#exceptionHandler(Handler)} at creation.
   * @param handler the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : Vertx;

  /**
   * Deploy a verticle instance that you have created yourself.
   *  <p>
   *  Vert.x will assign the verticle a context and start the verticle.
   *  <p>
   *  The actual deploy happens asynchronously and may not complete until after the call has returned.
   * @param verticle  the verticle instance to deploy.
   * 
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */) : void;

  /**
   * Like {@link #deployVerticle(Verticle)} but the completionHandler will be notified when the deployment is complete.
   *  <p>
   *  If the deployment is successful the result will contain a string representing the unique deployment ID of the
   *  deployment.
   *  <p>
   *  This deployment ID can subsequently be used to undeploy the verticle.
   * @param verticle  the verticle instance to deploy
   * @param completionHandler  a handler which will be notified when the deployment is complete
   * 
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Like {@link #deployVerticle(Verticle)} but {@link io.vertx.core.DeploymentOptions} are provided to configure the
   *  deployment.
   * @param verticle  the verticle instance to deploy
   * @param options  the deployment options.
   * 
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */, options: DeploymentOptions) : void;

  /**
   * Like {@link #deployVerticle(Verticle, DeploymentOptions)} but {@link Verticle} instance is created by invoking the
   *  {@code verticleSupplier}.
   *  <p>
   *  The supplier will be invoked as many times as {@link DeploymentOptions#getInstances()}.
   *  It must not return the same instance twice.
   *  <p>
   *  Note that the supplier will be invoked on the caller thread.
   * 
   */
  deployVerticle(verticleSupplier: any /* java.util.function.Supplier<io.vertx.core.Verticle> */, options: DeploymentOptions) : void;

  /**
   * Like {@link #deployVerticle(Verticle, Handler)} but {@link io.vertx.core.DeploymentOptions} are provided to configure the
   *  deployment.
   * @param verticle  the verticle instance to deploy
   * @param options  the deployment options.
   * @param completionHandler  a handler which will be notified when the deployment is complete
   * 
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */, options: DeploymentOptions, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Like {@link #deployVerticle(Verticle, DeploymentOptions, Handler)} but {@link Verticle} instance is created by
   *  invoking the {@code verticleSupplier}.
   *  <p>
   *  The supplier will be invoked as many times as {@link DeploymentOptions#getInstances()}.
   *  It must not return the same instance twice.
   *  <p>
   *  Note that the supplier will be invoked on the caller thread.
   * 
   */
  deployVerticle(verticleSupplier: any /* java.util.function.Supplier<io.vertx.core.Verticle> */, options: DeploymentOptions, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Register a {@code VerticleFactory} that can be used for deploying Verticles based on an identifier.
   * @param factory the factory to register
   * 
   */
  registerVerticleFactory(factory: any /* io.vertx.core.spi.VerticleFactory */) : void;

  /**
   * Unregister a {@code VerticleFactory}
   * @param factory the factory to unregister
   * 
   */
  unregisterVerticleFactory(factory: any /* io.vertx.core.spi.VerticleFactory */) : void;

  /**
   * Return the Set of currently registered verticle factories.
   * @return the set of verticle factories
   * 
   */
  verticleFactories() : any /* io.vertx.core.spi.VerticleFactory */[];

  /**
   * Return the Netty EventLoopGroup used by Vert.x
   * @return the EventLoopGroup
   * 
   */
  nettyEventLoopGroup() : any /* io.netty.channel.EventLoopGroup */;
}

export abstract class WebSocket implements WebSocketBase {
  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: Buffer) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * When a {@code WebSocket} is created it automatically registers an event handler with the event bus - the ID of that
   *  handler is given by this method.
   *  <p>
   *  Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * @return the binary handler id
   * 
   */
  binaryHandlerID() : string;

  /**
   * When a {@code WebSocket} is created it automatically registers an event handler with the eventbus, the ID of that
   *  handler is given by {@code textHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * 
   */
  textHandlerID() : string;

  /**
   * Returns the WebSocket sub protocol selected by the WebSocket handshake.
   *  <p/>
   *  On the server, the value will be {@code null} when the handler receives the websocket callback as the
   *  handshake will not be completed yet.
   * 
   */
  subProtocol() : string;

  /**
   * Writes a ping frame to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   *  <p>
   *  There is no handler for ping frames because RFC 6455  clearly
   *  states that the only response to a ping frame is a pong frame with identical contents.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   * Writes a pong frame to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   *  <p>
   *  There is no need to manually write a pong frame, as the server and client both handle responding to a ping from with a pong from
   *  automatically and this is exposed to users. RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> states that pongs may be sent unsolicited in order
   *  to implement a one way heartbeat.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   * Set a text message handler on the connection. This handler will be called similar to the
   *  {@link #binaryMessageHandler(Handler)}, but the buffer will be converted to a String first
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textMessageHandler(handler: ((res: string) => void) | Handler<string> | null | undefined) : WebSocketBase;

  /**
   * Set a binary message handler on the connection. This handler serves a similar purpose to {@link #handler(Handler)}
   *  except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   *  into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal()} to find the boundaries).
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryMessageHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Set a pong frame handler on the connection.  This handler will be invoked every time a pong frame is received
   *  on the server, and can be used by both clients and servers since the RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> do not
   *  specify whether the client or server sends a ping.
   *  <p>
   *  Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  There is no ping handler since ping frames should immediately be responded to with a pong frame with identical content
   *  <p>
   *  Pong frames may be received unsolicited.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pongHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   * Calls {@link #close(Handler)}
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending the default close frame.
   *  <p/>
   *  No more messages can be sent.
   * 
   */
  close() : void;

  /**
   * Same as {@link #close()} but with an {@code handler} called when the operation completes
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending a close frame with specified status code. You can give a look at various close payloads
   *  here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   *  <p/>
   *  No more messages can be sent.
   * @param statusCode Status code
   * 
   */
  close(statusCode: number) : void;

  /**
   * Same as {@link #close(short)} but with an {@code handler} called when the operation completes
   * 
   */
  close(statusCode: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads
   *  here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   *  <p/>
   *  No more messages can be sent.
   * @param statusCode Status code
   * @param reason reason of closure
   * 
   */
  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * Same as {@link #close(short, String)} but with an {@code handler} called when the operation completes
   * 
   */
  close(statusCode: number, reason: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   *
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   *
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : WebSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocket;

  pause() : WebSocket;

  resume() : WebSocket;

  fetch(amount: number) : WebSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocket;

  write(data: Buffer) : WebSocket;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  setWriteQueueMaxSize(maxSize: number) : WebSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocket;

  writeFrame(frame: WebSocketFrame) : WebSocket;

  writeFrame(frame: WebSocketFrame, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeFinalTextFrame(text: string) : WebSocket;

  writeFinalTextFrame(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeFinalBinaryFrame(data: Buffer) : WebSocket;

  writeFinalBinaryFrame(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeBinaryMessage(data: Buffer) : WebSocket;

  writeBinaryMessage(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeTextMessage(text: string) : WebSocket;

  writeTextMessage(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocket;

  frameHandler(handler: ((res: WebSocketFrame) => void) | Handler<WebSocketFrame> | null | undefined) : WebSocket;

  /**
   *
   * @return SSLSession associated with the underlying socket. Returns null if connection is
   *          not SSL.
   * @see javax.net.ssl.SSLSession
   * 
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

export interface WebSocketBase extends ReadStream<Buffer>, WriteStream<Buffer> {
  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: Buffer) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   *  <p/>
   *  The stream will be resumed when the pipe will be wired to a {@code WriteStream}.
   * @return a pipe
   * 
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link #pipeTo(WriteStream, Handler)} but with no completion handler.
   * 
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this {@code ReadStream} to the {@code WriteStream}.
   *  <p>
   *  Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   *  <p>
   *  Once this stream has ended or failed, the write stream will be ended and the {@code handler} will be
   *  called with the result.
   * @param dst the destination write stream
   * 
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : WebSocketBase;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  pause() : WebSocketBase;

  resume() : WebSocketBase;

  fetch(amount: number) : WebSocketBase;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocketBase;

  write(data: Buffer) : WebSocketBase;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  setWriteQueueMaxSize(maxSize: number) : WebSocketBase;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocketBase;

  /**
   * When a {@code WebSocket} is created it automatically registers an event handler with the event bus - the ID of that
   *  handler is given by this method.
   *  <p>
   *  Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * @return the binary handler id
   * 
   */
  binaryHandlerID() : string;

  /**
   * When a {@code WebSocket} is created it automatically registers an event handler with the eventbus, the ID of that
   *  handler is given by {@code textHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * 
   */
  textHandlerID() : string;

  /**
   * Returns the WebSocket sub protocol selected by the WebSocket handshake.
   *  <p/>
   *  On the server, the value will be {@code null} when the handler receives the websocket callback as the
   *  handshake will not be completed yet.
   * 
   */
  subProtocol() : string;

  /**
   * Write a WebSocket frame to the connection
   * @param frame  the frame to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFrame(frame: WebSocketFrame) : WebSocketBase;

  /**
   * Same as {@link #writeFrame(WebSocketFrame)} but with an {@code handler} called when the operation completes
   * 
   */
  writeFrame(frame: WebSocketFrame, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Write a final WebSocket text frame to the connection
   * @param text  The text to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFinalTextFrame(text: string) : WebSocketBase;

  /**
   * Same as {@link #writeFinalTextFrame(String, Handler)} but with an {@code handler} called when the operation completes
   * 
   */
  writeFinalTextFrame(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Write a final WebSocket binary frame to the connection
   * @param data  The data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFinalBinaryFrame(data: Buffer) : WebSocketBase;

  /**
   * Same as {@link #writeFinalBinaryFrame(Buffer, Handler)} but with an {@code handler} called when the operation completes
   * 
   */
  writeFinalBinaryFrame(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Writes a (potentially large) piece of binary data to the connection. This data might be written as multiple frames
   *  if it exceeds the maximum WebSocket frame size.
   * @param data  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeBinaryMessage(data: Buffer) : WebSocketBase;

  /**
   * Same as {@link #writeBinaryMessage(Buffer)} but with an {@code handler} called when the operation completes
   * 
   */
  writeBinaryMessage(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Writes a (potentially large) piece of text data to the connection. This data might be written as multiple frames
   *  if it exceeds the maximum WebSocket frame size.
   * @param text  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeTextMessage(text: string) : WebSocketBase;

  /**
   * Same as {@link #writeTextMessage(String)} but with an {@code handler} called when the operation completes
   * 
   */
  writeTextMessage(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Writes a ping frame to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   *  <p>
   *  There is no handler for ping frames because RFC 6455  clearly
   *  states that the only response to a ping frame is a pong frame with identical contents.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   * Writes a pong frame to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   *  <p>
   *  There is no need to manually write a pong frame, as the server and client both handle responding to a ping from with a pong from
   *  automatically and this is exposed to users. RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> states that pongs may be sent unsolicited in order
   *  to implement a one way heartbeat.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   * Set a close handler. This will be called when the WebSocket is closed.
   *  <p/>
   *  After this callback, no more messages are expected.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocketBase;

  /**
   * Set a frame handler on the connection. This handler will be called when frames are read on the connection.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  frameHandler(handler: ((res: WebSocketFrame) => void) | Handler<WebSocketFrame> | null | undefined) : WebSocketBase;

  /**
   * Set a text message handler on the connection. This handler will be called similar to the
   *  {@link #binaryMessageHandler(Handler)}, but the buffer will be converted to a String first
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textMessageHandler(handler: ((res: string) => void) | Handler<string> | null | undefined) : WebSocketBase;

  /**
   * Set a binary message handler on the connection. This handler serves a similar purpose to {@link #handler(Handler)}
   *  except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   *  into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal()} to find the boundaries).
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryMessageHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Set a pong frame handler on the connection.  This handler will be invoked every time a pong frame is received
   *  on the server, and can be used by both clients and servers since the RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> do not
   *  specify whether the client or server sends a ping.
   *  <p>
   *  Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  There is no ping handler since ping frames should immediately be responded to with a pong frame with identical content
   *  <p>
   *  Pong frames may be received unsolicited.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pongHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   * Calls {@link #close(Handler)}
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending the default close frame.
   *  <p/>
   *  No more messages can be sent.
   * 
   */
  close() : void;

  /**
   * Same as {@link #close()} but with an {@code handler} called when the operation completes
   * 
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending a close frame with specified status code. You can give a look at various close payloads
   *  here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   *  <p/>
   *  No more messages can be sent.
   * @param statusCode Status code
   * 
   */
  close(statusCode: number) : void;

  /**
   * Same as {@link #close(short)} but with an {@code handler} called when the operation completes
   * 
   */
  close(statusCode: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads
   *  here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   *  <p/>
   *  No more messages can be sent.
   * @param statusCode Status code
   * @param reason reason of closure
   * 
   */
  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * Same as {@link #close(short, String)} but with an {@code handler} called when the operation completes
   * 
   */
  close(statusCode: number, reason: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   *
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   *
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  /**
   *
   * @return SSLSession associated with the underlying socket. Returns null if connection is
   *          not SSL.
   * @see javax.net.ssl.SSLSession
   * 
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

export abstract class WebSocketFrame {
  /**
   * Create a binary WebSocket frame.
   * @param data  the data for the frame
   * @param isFinal  true if it's the final frame in the WebSocket message
   * @return the frame
   * 
   */
  static binaryFrame(data: Buffer, isFinal: boolean) : WebSocketFrame;

  /**
   * Create a text WebSocket frame.
   * @param str  the string for the frame
   * @param isFinal  true if it's the final frame in the WebSocket message
   * @return the frame
   * 
   */
  static textFrame(str: string, isFinal: boolean) : WebSocketFrame;

  /**
   * Create a ping WebSocket frame.  Will be a final frame. There is no option for non final ping frames.
   * @param data the bytes for the frame, may be at most 125 bytes
   * @return the frame
   * 
   */
  static pingFrame(data: Buffer) : WebSocketFrame;

  /**
   * Create a pong WebSocket frame.  Will be a final frame. There is no option for non final pong frames.
   * @param data the bytes for the frame, may be at most 125 bytes
   * @return the frame
   * 
   */
  static pongFrame(data: Buffer) : WebSocketFrame;

  /**
   * Create a continuation frame
   * @param data  the data for the frame
   * @param isFinal true if it's the final frame in the WebSocket message
   * @return the frame
   * 
   */
  static continuationFrame(data: Buffer, isFinal: boolean) : WebSocketFrame;

  /**
   *
   * @return true if it's a text frame
   * 
   */
  isText() : boolean;

  /**
   *
   * @return true if it's a binary frame
   * 
   */
  isBinary() : boolean;

  /**
   *
   * @return true if it's a continuation frame
   * 
   */
  isContinuation() : boolean;

  /**
   *
   * @return true if it's close frame
   * 
   */
  isClose() : boolean;

  /**
   *
   * @return the content of this frame as a UTF-8 string and returns the
   *  converted string. Only use this for text frames.
   * 
   */
  textData() : string;

  /**
   *
   * @return the data of the frame
   * 
   */
  binaryData() : Buffer;

  /**
   *
   * @return true if this is the final frame.
   * 
   */
  isFinal() : boolean;

  /**
   *
   * @return status code of close frame. Only use this for close frames
   * 
   */
  closeStatusCode() : number;

  /**
   *
   * @return string explaining close reason. Only use this for close frames
   * 
   */
  closeReason() : string;
}

export abstract class WorkerExecutor implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   * @implSpec  The default implementation returns {@code false}
   * @return {@code true} if metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   * Safely execute some blocking code.
   *  <p>
   *  Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
   *  <p>
   *  When the code is complete the handler {@code resultHandler} will be called with the result on the original context
   *  (i.e. on the original event loop of the caller).
   *  <p>
   *  A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
   *  the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
   *  method if it failed.
   *  <p>
   *  In the {@code blockingCodeHandler} the current context remains the original context and therefore any task
   *  scheduled in the {@code blockingCodeHandler} will be executed on the this context and not on the worker thread.
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param ordered  if true then if executeBlocking is called several times on the same context, the executions
   *                  for that context will be executed serially, not in parallel. if false then they will be no ordering
   *                  guarantees
   * @param <T> the type of the result
   * 
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Future<T>) => void) | Handler<Future<T>>, ordered: boolean, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Like {@link #executeBlocking(Handler, boolean, Handler)} called with ordered = true.
   * 
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Future<T>) => void) | Handler<Future<T>>, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Close the executor.
   * 
   */
  close() : void;
}

export interface WriteStream<T> extends StreamBase {
  /**
   * Set an exception handler on the write stream.
   * @param handler  the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : WriteStream<T>;

  /**
   * Write some data to the stream. The data is put on an internal write queue, and the write actually happens
   *  asynchronously. To avoid running out of memory by putting too much on the write queue,
   *  check the {@link #writeQueueFull} method before writing. This is done automatically if using a {@link Pump}.
   * @param data  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(data: T) : WriteStream<T>;

  /**
   * Same as {@link #write(T)} but with an {@code handler} called when the operation completes
   * 
   */
  write(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WriteStream<T>;

  /**
   * Ends the stream.
   *  <p>
   *  Once the stream has ended, it cannot be used any more.
   * 
   */
  end() : void;

  /**
   * Same as {@link #end()} but with an {@code handler} called when the operation completes
   * 
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link #end()} but writes some data to the stream before ending.
   * @implSpec The default default implementation calls sequentially {@link #write(Object)} then {@link #end()}
   * @apiNote Implementations might want to perform a single operation
   * @param data the data to write
   * 
   */
  end(data: T) : void;

  /**
   * Same as {@link #end(T)} but with an {@code handler} called when the operation completes
   * 
   */
  end(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Set the maximum size of the write queue to {@code maxSize}. You will still be able to write to the stream even
   *  if there is more than {@code maxSize} items in the write queue. This is used as an indicator by classes such as
   *  {@code Pump} to provide flow control.
   *  <p/>
   *  The value is defined by the implementation of the stream, e.g in bytes for a
   *  {@link io.vertx.core.net.NetSocket}, the number of {@link io.vertx.core.eventbus.Message} for a
   *  {@link io.vertx.core.eventbus.MessageProducer}, etc...
   * @param maxSize  the max size of the write stream
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWriteQueueMaxSize(maxSize: number) : WriteStream<T>;

  /**
   * This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   * Set a drain handler on the stream. If the write queue is full, then the handler will be called when the write
   *  queue is ready to accept buffers again. See {@link Pump} for an example of this being used.
   *  <p/>
   *  The stream implementation defines when the drain handler, for example it could be when the queue size has been
   *  reduced to {@code maxSize / 2}.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WriteStream<T>;
}
